From 45c5ae88d2b4080338c044df8191d241892d2560 Mon Sep 17 00:00:00 2001
From: Anton Kikin <a.kikin@tano-systems.com>
Date: Fri, 25 Jun 2021 04:34:49 +0300
Subject: [PATCH 1/5] baikal-m: Add support for Baikal-M platforms

Imported changes from baikal-arm64-5.2-20210608 (Baikal-M SDK 5.2 20210608)
applied to vanilla kernel 5.4.114.

Signed-off-by: Anton Kikin <a.kikin@tano-systems.com>
---
 arch/arm64/Kconfig.platforms                  |   31 +
 arch/arm64/boot/dts/Makefile                  |    1 +
 arch/arm64/boot/dts/baikal/Makefile           |    9 +
 arch/arm64/boot/dts/baikal/bm-dbm.dts         |  363 ++++
 arch/arm64/boot/dts/baikal/bm-mbm.dtsi        |  232 +++
 arch/arm64/boot/dts/baikal/bm-mbm10.dts       |   30 +
 arch/arm64/boot/dts/baikal/bm-mbm20.dts       |   72 +
 arch/arm64/boot/dts/baikal/bm-qemu.dts        |  163 ++
 arch/arm64/boot/dts/baikal/bm1000-clocks.dtsi |  383 ++++
 .../arm64/boot/dts/baikal/bm1000-cpufreq.dtsi |  249 +++
 arch/arm64/boot/dts/baikal/bm1000.dtsi        | 1043 +++++++++++
 drivers/clk/Makefile                          |    1 +
 drivers/clk/baikal/Makefile                   |    1 +
 drivers/clk/baikal/clk-baikal.c               |  435 +++++
 drivers/cpufreq/cpufreq-dt-platdev.c          |    2 +
 drivers/firmware/efi/arm-runtime.c            |    3 +
 drivers/gpu/drm/Kconfig                       |    1 +
 drivers/gpu/drm/Makefile                      |    1 +
 drivers/gpu/drm/baikal/Kconfig                |   13 +
 drivers/gpu/drm/baikal/Makefile               |   10 +
 drivers/gpu/drm/baikal/baikal-hdmi.c          |  117 ++
 drivers/gpu/drm/baikal/baikal_vdu_connector.c |  424 +++++
 drivers/gpu/drm/baikal/baikal_vdu_crtc.c      |  377 ++++
 drivers/gpu/drm/baikal/baikal_vdu_debugfs.c   |  132 ++
 drivers/gpu/drm/baikal/baikal_vdu_drm.h       |   81 +
 drivers/gpu/drm/baikal/baikal_vdu_drv.c       |  396 +++++
 drivers/gpu/drm/baikal/baikal_vdu_plane.c     |  193 +++
 drivers/gpu/drm/baikal/baikal_vdu_regs.h      |  148 ++
 drivers/gpu/drm/bridge/synopsys/Kconfig       |   17 +
 drivers/gpu/drm/bridge/synopsys/Makefile      |    1 +
 .../bridge/synopsys/baikal-hdmi-ahb-audio.c   |  686 ++++++++
 .../drm/bridge/synopsys/dw-hdmi-ahb-audio.c   |    7 +-
 drivers/gpu/drm/bridge/synopsys/dw-hdmi-ext.h |  159 ++
 drivers/gpu/drm/panfrost/panfrost_gpu.c       |   43 +-
 drivers/gpu/drm/panfrost/panfrost_job.c       |   10 +-
 drivers/gpu/drm/panfrost/panfrost_mmu.c       |   32 +-
 drivers/hwmon/Kconfig                         |    9 +
 drivers/hwmon/Makefile                        |    1 +
 drivers/hwmon/pvt.c                           |  638 +++++++
 drivers/i2c/busses/Kconfig                    |    3 +
 drivers/i2c/busses/Makefile                   |    1 +
 drivers/i2c/busses/i2c-baikal-smbus.c         |  487 ++++++
 drivers/misc/Kconfig                          |   17 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/tp_bmc.c                         |  747 ++++++++
 drivers/mmc/host/sdhci-of-dwcmshc.c           |   49 +-
 drivers/mmc/host/sdhci.c                      |   59 +-
 drivers/mmc/host/sdhci.h                      |   12 +
 drivers/net/ethernet/amd/Kconfig              |    7 +
 drivers/net/ethernet/amd/xgbe/Makefile        |    1 +
 drivers/net/ethernet/amd/xgbe/baikal-mdio.c   |  635 +++++++
 drivers/net/ethernet/amd/xgbe/xgbe-desc.c     |    5 +
 drivers/net/ethernet/amd/xgbe/xgbe-dev.c      |    4 +
 drivers/net/ethernet/amd/xgbe/xgbe-drv.c      |  117 +-
 drivers/net/ethernet/amd/xgbe/xgbe-main.c     |   22 +-
 drivers/net/ethernet/amd/xgbe/xgbe-platform.c |   41 +
 drivers/net/ethernet/amd/xgbe/xgbe.h          |   23 +
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |    8 +
 drivers/net/ethernet/stmicro/stmmac/Makefile  |    3 +-
 .../ethernet/stmicro/stmmac/dwmac-baikal.c    |  227 +++
 .../ethernet/stmicro/stmmac/dwmac1000_core.c  |    1 +
 .../ethernet/stmicro/stmmac/dwmac1000_dma.c   |   45 +-
 .../ethernet/stmicro/stmmac/dwmac1000_dma.h   |   26 +
 .../net/ethernet/stmicro/stmmac/dwmac_lib.c   |    8 +
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |   47 +
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  302 +++-
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.c  | 1536 +++++++++++++++++
 .../net/ethernet/stmicro/stmmac/stmmac_xsk.h  |   49 +
 drivers/net/phy/Kconfig                       |   13 +
 drivers/net/phy/Makefile                      |    2 +
 drivers/net/phy/mdio-be-gpio.c                |  540 ++++++
 drivers/net/phy/mv88x2222.c                   |  473 +++++
 drivers/pci/controller/dwc/Kconfig            |   11 +
 drivers/pci/controller/dwc/Makefile           |    1 +
 drivers/pci/controller/dwc/pcie-baikal.c      |  718 ++++++++
 drivers/spi/Kconfig                           |    3 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-db-espi.c                     |  431 +++++
 drivers/spi/spi-db-espi.h                     |  170 ++
 drivers/tty/serial/8250/8250_dw.c             |    7 +-
 drivers/usb/dwc3/Kconfig                      |    9 +
 drivers/usb/dwc3/Makefile                     |    1 +
 drivers/usb/dwc3/dwc3-baikal.c                |  126 ++
 drivers/video/Kconfig                         |    2 +
 include/linux/marvell_phy.h                   |    2 +
 include/linux/mfd/baikal/lcru-pcie.h          |  140 ++
 samples/Kconfig                               |    7 +
 samples/Makefile                              |    1 +
 sound/soc/codecs/tlv320aic3x.c                |    3 +
 sound/soc/dwc/Makefile                        |    1 +
 sound/soc/dwc/be_snd.c                        |  129 ++
 sound/soc/dwc/dwc-i2s.c                       |   37 +-
 tools/build/Makefile.include                  |    4 +
 93 files changed, 13704 insertions(+), 125 deletions(-)
 create mode 100644 arch/arm64/boot/dts/baikal/Makefile
 create mode 100644 arch/arm64/boot/dts/baikal/bm-dbm.dts
 create mode 100644 arch/arm64/boot/dts/baikal/bm-mbm.dtsi
 create mode 100644 arch/arm64/boot/dts/baikal/bm-mbm10.dts
 create mode 100644 arch/arm64/boot/dts/baikal/bm-mbm20.dts
 create mode 100644 arch/arm64/boot/dts/baikal/bm-qemu.dts
 create mode 100644 arch/arm64/boot/dts/baikal/bm1000-clocks.dtsi
 create mode 100644 arch/arm64/boot/dts/baikal/bm1000-cpufreq.dtsi
 create mode 100644 arch/arm64/boot/dts/baikal/bm1000.dtsi
 create mode 100644 drivers/clk/baikal/Makefile
 create mode 100644 drivers/clk/baikal/clk-baikal.c
 create mode 100644 drivers/gpu/drm/baikal/Kconfig
 create mode 100644 drivers/gpu/drm/baikal/Makefile
 create mode 100644 drivers/gpu/drm/baikal/baikal-hdmi.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_connector.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_crtc.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_drm.h
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_drv.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_plane.c
 create mode 100644 drivers/gpu/drm/baikal/baikal_vdu_regs.h
 create mode 100644 drivers/gpu/drm/bridge/synopsys/baikal-hdmi-ahb-audio.c
 create mode 100644 drivers/gpu/drm/bridge/synopsys/dw-hdmi-ext.h
 create mode 100644 drivers/hwmon/pvt.c
 create mode 100644 drivers/i2c/busses/i2c-baikal-smbus.c
 create mode 100644 drivers/misc/tp_bmc.c
 create mode 100644 drivers/net/ethernet/amd/xgbe/baikal-mdio.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.h
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.h
 create mode 100644 drivers/net/phy/mdio-be-gpio.c
 create mode 100644 drivers/net/phy/mv88x2222.c
 create mode 100644 drivers/pci/controller/dwc/pcie-baikal.c
 create mode 100644 drivers/spi/spi-db-espi.c
 create mode 100644 drivers/spi/spi-db-espi.h
 create mode 100644 drivers/usb/dwc3/dwc3-baikal.c
 create mode 100644 include/linux/mfd/baikal/lcru-pcie.h
 create mode 100644 sound/soc/dwc/be_snd.c

diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 9dccf4db3..41dfd6767 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -29,6 +29,25 @@ config ARCH_ALPINE
 	  This enables support for the Annapurna Labs Alpine
 	  Soc family.
 
+config ARCH_BAIKAL
+	bool "Baikal Electronics Baikal-M SoC Family"
+	select GPIOLIB
+	select PINCTRL
+	select OF_GPIO
+	select I2C_BAIKAL_SMBUS
+	select GPIO_SYSFS
+	select GPIO_DWAPB
+	select GPIO_GENERIC
+	select STMMAC_ETH
+	select STMMAC_PLATFORM
+	select PHYLIB
+	select SPI_DESIGNWARE
+	select SPI_DW_MMIO
+	select DW_APB_TIMER
+	select DW_APB_TIMER_OF
+	help
+	  This enables support for Baikal Electronics Baikal-M SoC Family
+
 config ARCH_BCM2835
 	bool "Broadcom BCM2835 family"
 	select TIMER_OF
@@ -293,6 +312,18 @@ config ARCH_ZX
 	help
 	  This enables support for ZTE ZX SoC Family
 
+# The GPIO number here must be sorted by descending number.
+# In a case of multiplatform kernel we want the highest value
+# required by selected platforms
+config ARCH_NR_GPIO
+    int
+    default 64 if ARCH_BAIKAL
+    default 0
+    help
+      Maximum number of GPIOs in the system.
+
+      If unsure, leave the default value.
+
 config ARCH_ZYNQMP
 	bool "Xilinx ZynqMP Family"
 	select ZYNQMP_FIRMWARE
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index f19b762c0..c9702db89 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -7,6 +7,7 @@ subdir-y += amd
 subdir-y += amlogic
 subdir-y += apm
 subdir-y += arm
+subdir-y += baikal
 subdir-y += bitmain
 subdir-y += broadcom
 subdir-y += cavium
diff --git a/arch/arm64/boot/dts/baikal/Makefile b/arch/arm64/boot/dts/baikal/Makefile
new file mode 100644
index 000000000..9729c6e3d
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_BAIKAL) += bm-dbm.dtb
+dtb-$(CONFIG_ARCH_BAIKAL) += bm-mbm10.dtb
+dtb-$(CONFIG_ARCH_BAIKAL) += bm-mbm20.dtb
+dtb-$(CONFIG_ARCH_BAIKAL) += bm-qemu.dtb
+
+always		:= $(dtb-y)
+subdir-y	:= $(dts-dirs)
+clean-files	:= *.dtb
diff --git a/arch/arm64/boot/dts/baikal/bm-dbm.dts b/arch/arm64/boot/dts/baikal/bm-dbm.dts
new file mode 100644
index 000000000..5139aa917
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm-dbm.dts
@@ -0,0 +1,363 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree source for Baikal Electronics DBM board
+ * Copyright (C) 2019-2021 Baikal Electronics, JSC
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/input/input.h>
+#include "bm1000.dtsi"
+
+/ {
+	model = "Baikal Electronics Baikal-M evaluation board";
+	compatible = "baikal,baikal-m";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen { };
+
+	panel {
+		compatible = "panel-lvds";
+		width-mm = <223>;
+		height-mm = <125>;
+		data-mapping = "vesa-24";
+		panel-timing {
+			/* 1920x1080 @60Hz */
+			clock-frequency = <148500000>;
+			hactive = <1920>;
+			vactive = <1080>;
+			hsync-len = <44>;
+			hfront-porch = <88>;
+			hback-porch = <148>;
+			vsync-len = <5>;
+			vfront-porch = <4>;
+			vback-porch = <36>;
+		};
+		port {
+			panel0_lvds0: endpoint@0 {
+				remote-endpoint = <&vdu_lvds0_pads>;
+			};
+			panel0_lvds1: endpoint@1 {
+				remote-endpoint = <&vdu_lvds1_pads>;
+			};
+		};
+	};
+
+	buttons-backlight {
+		compatible = "gpio-keys";
+		autorepeat;
+		button-brightness-down {
+			label = "Brightness Down Button";
+			linux,code = <KEY_BRIGHTNESSDOWN>;
+			gpios = <&porta 18 GPIO_ACTIVE_LOW>;
+			debounce-interval = <50>;
+		};
+		button-brightness-up {
+			label = "Brightness Up Button";
+			linux,code = <KEY_BRIGHTNESSUP>;
+			gpios = <&porta 17 GPIO_ACTIVE_LOW>;
+			debounce-interval = <50>;
+		};
+		button-brightness-toggle {
+			label = "Brightness Toggle Button";
+			linux,code = <KEY_BRIGHTNESS_TOGGLE>;
+			gpios = <&porta 31 GPIO_ACTIVE_LOW>;
+			debounce-interval = <50>;
+		};
+	};
+
+	sound {
+		compatible = "baikal,snd_soc_be";
+		baikal,cpu-dai = <&i2s>;
+		baikal,audio-codec = <&tlv320aic3x>;
+	};
+};
+
+&ddr2 {
+	status = "okay";
+};
+
+&espi0 {
+	cs-gpios = <&porta 28 1>; /* todo: get real gpio */
+	status = "okay";
+
+	/* test device #0 */
+	espi_test0 {
+		compatible = "rohm,dh2228fv"; /* same as spidev */
+		reg = <0>;
+		spi-max-frequency = <12000000>;
+		status = "okay";
+	};
+};
+
+&gmac0 {
+	status = "okay";
+	snps,reset-gp-out;
+	snps,reset-active-low;
+};
+
+&gmac1 {
+	status = "okay";
+	snps,reset-gp-out;
+	snps,reset-active-low;
+};
+
+&gpio {
+	status = "okay";
+};
+
+&gpu {
+	system-coherency = <0>;
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+
+	tlv320aic3x: tlv320aic3x@18 {
+		#sound-dai-cells = <0>;
+		compatible = "ti,tlv320aic3x";
+		reg = <0x18>;
+		gpio-reset = <&porta 4 GPIO_ACTIVE_LOW>;
+		status = "okay";
+		ai3x-micbias-vg = <1>;
+		ai3x-ocmv = <1>;
+	};
+
+	rtc@56 {
+		compatible = "abracon,abeoz9";
+		reg = <0x56>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2s {
+	status = "okay";
+	sound-dai = <&tlv320aic3x>;
+	system-clock-frequency = <12000000>;
+};
+
+&mmc0 {
+	status = "okay";
+#if 0
+	/* emmc */
+	non-removable;
+	bus-width = <8>;
+	max-clock = <200000000>;
+#else
+	/* sd */
+	disable-wp;
+	bus-width = <4>;
+	max-clock = <25000000>;
+#endif
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&pcie1 {
+	status = "okay";
+};
+
+&pcie2 {
+	status = "okay";
+};
+
+&pcie_lcru {
+	status = "okay";
+};
+
+&pvt0 {
+	status = "okay";
+};
+
+&pvt1 {
+	status = "okay";
+};
+
+&pvt2 {
+	status = "okay";
+};
+
+&pvt3 {
+	status = "okay";
+};
+
+&pvt_mali {
+	status = "okay";
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&smbus0 {
+	status = "okay";
+};
+
+&smbus1 {
+	status = "okay";
+};
+
+&spi0 {
+	num-cs = <4>;
+	cs-gpios =
+		<&porta 24 1>, /* ss0 xp8 - DD53 normal flash */
+		<&porta 25 1>, /* ss1 xp9 */
+		<&porta 26 1>, /* ss2 xp10 */
+		<&porta 27 1>; /* ss3 xp11 */
+	status = "okay";
+
+	/* SPI flash chip #1 */
+	flash0: m25p80@0 {
+		compatible = "micron,n25q256a", "jedec,spi-nor";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <12500000>;
+		status = "okay";
+
+		/* Flash chip0 partitions */
+		mtd0@0 {
+			label = "bl1";
+			reg = <0x00000000 0x00040000>;
+			read-only;
+		};
+
+		mtd1@40000 {
+			label = "fip";
+			reg = <0x00040000 0x007c0000>;
+		};
+
+		mtd2@800000 {
+			label = "rescue";
+			reg = <0x00800000 0x01800000>;
+		};
+	};
+};
+
+#if 0
+/* undefined */
+&spi1 {
+	num-cs = <4>;
+	cs-gpios =
+		<&porta 20 1>, /* ss0 xp15 - DD57 boot flash */
+		<&porta 21 1>, /* ss1 xp16 */
+		<&porta 22 1>, /* ss2 xp17 */
+		<&porta 23 1>; /* ss3 xp18 */
+	status = "okay";
+
+	/* SPI flash chip #2 */
+	flash0: m25p80@0 {
+		compatible = "micron,n25q256a", "jedec,spi-nor";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <12500000>;
+		status = "okay";
+
+		/* Flash chip1 partitions */
+		mtd0@0 {
+			label = "fip_backup";
+			reg = <0x00000000 0x00400000>;
+			read-only;
+		};
+
+		mtd1@400000 {
+			label = "env_backup";
+			reg = <0x00400000 0x00100000>;
+			read-only;
+		};
+
+		mtd2@500000 {
+			label = "data1";
+			reg = <0x00500000 0x01b00000>;
+		};
+	};
+};
+#endif
+
+&timer1 {
+	status = "okay";
+};
+
+&timer2 {
+	status = "okay";
+};
+
+&timer3 {
+	status = "okay";
+};
+
+&timer4 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&usb2 {
+	status = "okay";
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&vdec {
+	status = "okay";
+};
+
+&vdu0 {
+	status = "okay";
+	enable-gpios = <&porta 16 GPIO_ACTIVE_LOW>;
+	backlight {
+		min-brightness-level = <10>;
+		default-brightness-level = <60>;
+		brightness-level-step = <2>;
+		pwm-frequency = <20000>;
+	};
+	port {
+		vdu_lvds0_pads: endpoint@0 {
+			remote-endpoint = <&panel0_lvds0>;
+		};
+		vdu_lvds1_pads: endpoint@1 {
+			remote-endpoint = <&panel0_lvds1>;
+		};
+		/*vdu_lvds2_pads: endpoint@2 {
+			remote-endpoint = <&panel0_lvds2>;
+		};
+		vdu_lvds3_pads: endpoint@3 {
+			remote-endpoint = <&panel0_lvds3>;
+		};*/
+	};
+};
+
+&vdu1 {
+	status = "okay";
+};
+
+&xgmac0 {
+	status = "okay";
+};
+
+&xgmac1 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/baikal/bm-mbm.dtsi b/arch/arm64/boot/dts/baikal/bm-mbm.dtsi
new file mode 100644
index 000000000..ef4f7e1ed
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm-mbm.dtsi
@@ -0,0 +1,232 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree include file for MBM-compatible boards
+ * Copyright (C) 2021 Baikal Electronics, JSC
+ */
+
+#include "bm1000.dtsi"
+
+/ {
+	model = "Baikal Electronics Baikal-M mitx board";
+	compatible = "baikal,baikal-m";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen { };
+
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "MITX-Sound-Card";
+		simple-audio-card,bitclock-master = <&codec0>;
+		simple-audio-card,frame-master = <&codec0>;
+		simple-audio-card,widgets =
+			"Microphone", "Mic Jack",
+			"Headphone", "Headphones",
+			"Speaker", "AUX Out",
+			"Line", "Line In";
+		simple-audio-card,routing =
+			"Headphones", "RHP",
+			"Headphones", "LHP",
+			"AUX Out", "AUXOUT1",
+			"AUX Out", "AUXOUT2",
+			"L2", "Mic Jack",
+			"R2", "Mic Jack",
+			"LAUX", "Line In",
+			"RAUX", "Line In";
+		simple-audio-card,mic-det-gpio = <&porta 26 GPIO_ACTIVE_LOW>;
+		simple-audio-card,format = "i2s";
+		simple-audio-card,cpu {
+			sound-dai = <&i2s>;
+		};
+		codec0: simple-audio-card,codec {
+			sound-dai = <&nau8822 0>;
+		};
+	};
+};
+
+&ddr2 {
+	status = "okay";
+};
+
+&gpio {
+	status = "okay";
+};
+
+&gpu {
+	system-coherency = <0>;
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+
+	bmc@8 {
+		compatible = "tp,mitx2-bmc", "t-platforms,mitx2-bmc";
+		reg = <0x08>;
+	};
+
+	nau8822: nau8822@1a {
+		compatible = "nuvoton,nau8822";
+		#sound-dai-cells = <1>;
+		reg = <0x1a>;
+	};
+
+	gpio@50 {
+		compatible = "nxp,pca9670";
+		#gpio-cells = <2>;
+		gpio-controller;
+		reg = <0x50>;
+	};
+
+	rtc@51 {
+		compatible = "nxp,pcf2129", "nxp,pcf2127";
+		reg = <0x51>;
+	};
+
+	hwmon@52 {
+		compatible = "tp,bm_mitx_hwmon";
+		reg = <0x52>;
+	};
+
+	eeprom@53 {
+		compatible = "atmel,24c32";
+		pagesize = <32>;
+		reg = <0x53>;
+	};
+
+	ps2port@54 {
+		compatible = "tp,tp_serio";
+		reg = <0x54>;
+		interrupt-parent = <&porta>;
+		interrupts = <14 8>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2s {
+	status = "okay";
+	system-clock-frequency = <12000000>;
+	#sound-dai-cells = <0>;
+};
+
+&mdio0 {
+	status = "disabled";
+};
+
+&mmc0 {
+	status = "okay";
+	disable-wp;
+	bus-width = <4>;
+	max-clock = <25000000>;
+};
+
+&pcie0 {
+	status = "okay";
+	reset-gpios = <&porta 6 GPIO_ACTIVE_LOW>;
+};
+
+&pcie2 {
+	status = "okay";
+	reset-gpios = <&porta 3 GPIO_ACTIVE_LOW>;
+};
+
+&pcie_lcru {
+	status = "okay";
+};
+
+&porta {
+	pcieclk {
+		gpio-hog;
+		gpios = <1 GPIO_ACTIVE_LOW>;
+		output-high;
+		line-name = "pcie-x8-clock";
+	};
+};
+
+&pvt0 {
+	status = "okay";
+};
+
+&pvt1 {
+	status = "okay";
+};
+
+&pvt2 {
+	status = "okay";
+};
+
+&pvt3 {
+	status = "okay";
+};
+
+&pvt_mali {
+	status = "okay";
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&smbus0 {
+	status = "okay";
+};
+
+&smbus1 {
+	status = "okay";
+};
+
+&spi0 {
+	num-cs = <4>;
+	cs-gpios = <0>;
+	status = "okay";
+};
+
+&timer1 {
+	status = "okay";
+};
+
+&timer2 {
+	status = "okay";
+};
+
+&timer3 {
+	status = "okay";
+};
+
+&timer4 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+};
+
+&usb2 {
+	status = "okay";
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&vdec {
+	status = "okay";
+};
+
+&vdu1 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/baikal/bm-mbm10.dts b/arch/arm64/boot/dts/baikal/bm-mbm10.dts
new file mode 100644
index 000000000..995e5b240
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm-mbm10.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree source for MBM10-compatible boards:
+ *   - TP-TF307-MB-A0 Rev.1.0 (BM1BM1-A)
+ *   - TF307-MB-S-C Rev.3.0
+ *
+ * Copyright (C) 2021 Baikal Electronics, JSC
+ */
+
+/dts-v1/;
+
+#include "bm-mbm.dtsi"
+
+/ {
+	sound {
+		simple-audio-card,hp-det-gpio = <&porta 27 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&gmac0 {
+	status = "okay";
+	snps,reset-gp-out;
+	snps,reset-active-low;
+};
+
+&gmac1 {
+	status = "okay";
+	snps,reset-gp-out;
+	snps,reset-active-low;
+};
diff --git a/arch/arm64/boot/dts/baikal/bm-mbm20.dts b/arch/arm64/boot/dts/baikal/bm-mbm20.dts
new file mode 100644
index 000000000..492b50f76
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm-mbm20.dts
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree source for MBM20-compatible boards:
+ *   - TF307-MB-S-D Rev.4.0 (BM1BM1-D)
+ *
+ * Copyright (C) 2021 Baikal Electronics, JSC
+ */
+
+/dts-v1/;
+
+#include "bm-mbm.dtsi"
+
+/ {
+	panel {
+		/* In order to utilize LVDS LCD panel, make sure that
+		   status is "okay" along with &vdu0 status (see below). */
+		status = "disabled";
+		compatible = "panel-lvds";
+		width-mm = <223>;
+		height-mm = <125>;
+		data-mapping = "vesa-24";
+		enable-gpios = <&porta 16 GPIO_ACTIVE_HIGH>;
+		panel-timing {
+			/* 1920x1080 @60Hz */
+			clock-frequency = <148500000>;
+			hactive = <1920>;
+			vactive = <1080>;
+			hsync-len = <44>;
+			hfront-porch = <88>;
+			hback-porch = <148>;
+			vsync-len = <5>;
+			vfront-porch = <4>;
+			vback-porch = <36>;
+		};
+		port {
+			panel0_lvds0: endpoint@0 {
+				remote-endpoint = <&vdu_lvds0_pads>;
+			};
+			panel0_lvds1: endpoint@1 {
+				remote-endpoint = <&vdu_lvds1_pads>;
+			};
+		};
+	};
+
+	sound {
+		simple-audio-card,hp-det-gpio = <&porta 29 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&gmac0 {
+	status = "okay";
+	snps,reset-gpios = <&porta 19 GPIO_ACTIVE_LOW>;
+};
+
+&gmac1 {
+	status = "okay";
+	snps,reset-gpios = <&porta 20 GPIO_ACTIVE_LOW>;
+};
+
+&vdu0 {
+	/* In order to utilize LVDS LCD panel, make sure that
+	   status is "okay" along with panel status (see above). */
+	status = "disabled";
+	port {
+		vdu_lvds0_pads: endpoint@0 {
+			remote-endpoint = <&panel0_lvds0>;
+		};
+		vdu_lvds1_pads: endpoint@1 {
+			remote-endpoint = <&panel0_lvds1>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/baikal/bm-qemu.dts b/arch/arm64/boot/dts/baikal/bm-qemu.dts
new file mode 100644
index 000000000..c6350c0aa
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm-qemu.dts
@@ -0,0 +1,163 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree source for Baikal-M software emulator (QEMU) platform
+ * Copyright (C) 2018-2021 Baikal Electronics, JSC
+ */
+
+/dts-v1/;
+
+#include "bm1000.dtsi"
+
+/*
+ * Device "flash@0" was added to allow UEFI to boot on emulator.
+ * TODO: the tree should be replaced by actual Baikal-M component tree
+ */
+
+/ {
+	model = "Baikal Electronics Baikal-M virtual platform";
+	compatible = "baikal,baikal-m";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		bootargs = "root=/dev/ram rw rootwait console=ttyS0,115200n8 earlyprintk=uart8250,mmio32,0x20230000,115200";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		/* 16GB */
+		reg = <0x00000000 0x80000000 0x0 0x80000000
+		       0x00000008 0x80000000 0x1 0x80000000>;
+	};
+
+	/* XXX: Temporary fix for qemu to work */
+	/* Device is necessary for UEFI to boot on QEMU, need to replace it with something later */
+	flash@0 {
+		compatible = "cfi-flash";
+		reg = <0x0 0x4000000 0x0 0x4000000>;
+		bank-width = <0x4>;
+	};
+
+	panel: panel {
+		compatible = "auo,b133htn01";		/* 1920x1080 */
+		/*compatible = "auo,b133xtn01;		/* 1366x768 */
+		/*compatible = "auo,b101aw03";		/* 1024x600 */
+		/*compatible = "innolux,g121x1-l03";	/* 1024x768 */
+		/*compatible = "auo,b101ean01";		/* 1280x800 */
+
+		port {
+			lcd_panel: endpoint {
+				remote-endpoint = <&vdu_pads>;
+			};
+		};
+	};
+
+	/*panel_hdmi: panel {
+		compatible = "edt,et057090dhu";
+
+		port {
+			lcd_hdmi_panel: endpoint {
+				remote-endpoint = <&vdu_hdmi_pads>;
+			};
+		};
+	};*/
+};
+
+&gmac0 {
+	status = "okay";
+};
+
+&gmac1 {
+	status = "okay";
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&spi0 {
+	num-cs = <6>;
+	status = "okay";
+
+	/* SPI flash chip #1 */
+	flash0: m25p80@0 {
+		compatible = "micron,n25q256a", "jedec,spi-nor";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <50000000>;
+		status = "okay";
+
+		/* Flash chip0 partitions */
+		mtd0@0 {
+			label = "fip";
+			reg = <0x00000000 0x00400000>;
+			read-only;
+		};
+
+		mtd1@400000 {
+			label = "env";
+			reg = <0x00400000 0x00100000>;
+		};
+
+		mtd2@500000 {
+			label = "kernel";
+			reg = <0x00500000 0x00400000>;
+		};
+
+		mtd3@900000 {
+			label = "rootfs";
+			reg = <0x00900000 0x00800000>;
+		};
+
+		mtd4@1100000 {
+			label = "data0";
+			reg = <0x01100000 0x00f00000>;
+		};
+	};
+
+	/* SPI flash chip #2 */
+	flash1: m25p80@1 {
+		compatible = "micron,n25q256a", "jedec,spi-nor";
+		reg = <1>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <50000000>;
+		status = "okay";
+
+		/* Flash chip1 partitions */
+		mtd0@0 {
+			label = "fip_backup";
+			reg = <0x00000000 0x00400000>;
+			read-only;
+		};
+
+		mtd1@400000 {
+			label = "env_backup";
+			reg = <0x00400000 0x00100000>;
+			read-only;
+		};
+
+		mtd2@500000 {
+			label = "data1";
+			reg = <0x00500000 0x01b00000>;
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&vdu0 {
+	port {
+		vdu_pads: endpoint {
+			remote-endpoint = <&lcd_panel>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/baikal/bm1000-clocks.dtsi b/arch/arm64/boot/dts/baikal/bm1000-clocks.dtsi
new file mode 100644
index 000000000..08b033fbe
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm1000-clocks.dtsi
@@ -0,0 +1,383 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree include file for BE-M1000 SoC clocks
+ * Copyright (C) 2017-2021 Baikal Electronics, JSC
+ */
+
+/ {
+	/* external oscillator */
+	osc25: oscillator25 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <25000000>;
+		clock-output-names = "osc25";
+	};
+
+	/* external oscillator */
+	osc27: oscillator27 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <27000000>;
+		clock-output-names = "osc27";
+	};
+
+	cmu_cluster0: cmu_cluster0 {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-ca57_cmu0";
+		#clock-cells = <0>;
+		clocks = <&osc25>;
+		cmu-id = <0x28000000>;
+		max = <1500000000>;
+		min = <500000000>;
+		clock-frequency = <1500000000>;
+	};
+
+	cmu_cluster1: cmu_cluster1 {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-ca57_cmu1";
+		#clock-cells = <0>;
+		clocks = <&osc25>;
+		cmu-id = <0xc000000>;
+		max = <1500000000>;
+		min = <500000000>;
+		clock-frequency = <1500000000>;
+	};
+
+	cmu_cluster2: cmu_cluster2 {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-ca57_cmu2";
+		#clock-cells = <0>;
+		clocks = <&osc25>;
+		cmu-id = <0xa000000>;
+		max = <1500000000>;
+		min = <500000000>;
+		clock-frequency = <1500000000>;
+	};
+
+	cmu_cluster3: cmu_cluster3 {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-ca57_cmu3";
+		#clock-cells = <0>;
+		clocks = <&osc25>;
+		cmu-id = <0x26000000>;
+		max = <1500000000>;
+		min = <500000000>;
+		clock-frequency = <1500000000>;
+	};
+
+	cmu0_avlsp: cmu0_avlsp {
+		compatible = "baikal,cmu";
+		#clock-cells = <1>;
+		clock-output-names = "baikal-avlsp_cmu0";
+		clock-names =
+			"gpio",		// <0>
+			"uart1",	// <1>
+			"uart2",	// <2>
+			"apb",		// <3>
+			"spi",		// <4>
+			"espi",		// <5>
+			"i2c1",		// <6>
+			"i2c2",		// <7>
+			"timer1",	// <8>
+			"timer2",	// <9>
+			"timer3",	// <10>
+			"timer4",	// <11>
+			"dmac",		// <12>
+			"smbus1",	// <13>
+			"smbus2",	// <14>
+			"mshc_axi",	// <17>
+			"mshc_ahb",	// <18>
+			"mshc_tx_x2",	// <19>
+			"mshc_b",	// <20>
+			"mshc_tm",	// <21>
+			"mshc_cqetm",	// <22>
+			"hwa_clu",	// <23>
+			"hwa_clu_hf",	// <24>
+			"hwa_axi",	// <25>
+			"vdu_axi",	// <26>
+			"smmu";		// <27>
+		clock-indices =
+			<0>, <1>, <2>, <3>, <4>, <5>, <6>, <7>, <8>, <9>,
+			<10>, <11>, <12>, <13>, <14>, <17>, <18>, <19>,
+			<20>, <21>, <22>, <23>, <24>, <25>, <26>, <27>;
+		clocks = <&osc25>;
+		cmu-id = <0x20000000>;
+		max = <2100000000>;
+		min = <800000>;
+		clock-frequency = <1200000000>;
+	};
+
+	cmu1_avlsp: cmu1_avlsp {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-avlsp_cmu1";
+		#clock-cells = <0>;
+		clocks = <&osc27>;
+		cmu-id = <0x20010000>;
+		max = <2100000000>;
+		min = <13500000>;
+		clock-frequency = <1039500000>;
+	};
+
+	cmu_mali: cmu_mali {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-mali-cmu";
+		#clock-cells = <0>;
+		clocks = <&osc25>;
+		clock-names = "aclk";
+		cmu-id = <0x2a000000>;
+		max = <800000000>;
+		min = <400000000>;
+		clock-frequency = <750000000>;
+	};
+
+	cmu0_xgbe: cmu0_xgbe {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-xgbe-cmu0";
+		#clock-cells = <1>;
+		clocks = <&osc25>;
+		clock-names = "csr50mhz", "gmac0_tx2", "gmac1_tx2", "hdmi_aclk", "isfr";
+		clock-indices = <0>, <10>, <13>, <15>, <17>;
+		cmu-id = <0x30000000>;
+		max = <1250000000>;
+		min = <50000000>;
+		clock-frequency = <1250000000>;
+	};
+
+	cmu1_xgbe: cmu1_xgbe {
+		compatible = "baikal,cmu";
+		clock-output-names = "baikal-xgbe-cmu1";
+		#clock-cells = <1>;
+		clocks = <&osc27>;
+		clock-indices = <0>;
+		clock-names = "pixelclk";
+		cmu-id = <0x30010000>;
+		max = <600000000>;
+		min = <13500000>;
+		clock-frequency = <25250000>;
+	};
+
+	clocks {
+		ref_clk: ref_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <25000000>;
+			clock-output-names = "refclk";
+		};
+
+		cpu_clk: cpu_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <1500000000>;
+			clock-output-names = "cpuclk";
+		};
+
+		apb_clk: apb_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <200000000>;
+			clock-output-names = "apb_pclk";
+		};
+
+		uart_clk: uart_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <7273800>;
+			clock-output-names = "soc_uartclk";
+		};
+
+		i2c_clk: i2c_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <100000000>;
+			clock-output-names = "soc_i2cclk";
+		};
+
+		smbus_clk: smbus_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_smbusclk";
+		};
+
+		timer1_clk: timer1_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_timer1clk";
+		};
+
+		timer2_clk: timer2_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_timer2clk";
+		};
+
+		timer3_clk: timer3_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_timer3clk";
+		};
+
+		timer4_clk: timer4_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_timer4clk";
+		};
+
+		gpio_clk: gpio_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <1000000>;
+			clock-output-names = "soc_gpioclk";
+		};
+
+		spi_clk: spi_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "soc_spiclk";
+		};
+
+		soc_ethclk: ethclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "eth_clk";
+		};
+
+		soc_xgbeclk: xgbeclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <156250000>;
+			clock-output-names = "xgbe_clk";
+		};
+
+		soc_smc50mhz: clk50mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <50000000>;
+			clock-output-names = "smc_clk";
+		};
+
+		soc_faxiclk: refclk400mhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <400000000>;
+			clock-output-names = "faxi_clk";
+		};
+
+		soc_tmp_clk: refclkXXXmhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <100000000>;
+			clock-output-names = "tmpclk";
+		};
+
+		gpu_clk: gpu_clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <750000000>;
+			clock-output-names = "gpuclk";
+		};
+		gpu_opp_table: opp_table_gpu {
+			compatible = "operating-points-v2", "operating-points-v2-mali";
+
+			opp@400000000 {
+				opp-hz = /bits/ 64 <400000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@450000000 {
+				opp-hz = /bits/ 64 <450000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@500000000 {
+				opp-hz = /bits/ 64 <500000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@550000000 {
+				opp-hz = /bits/ 64 <550000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@600000000 {
+				opp-hz = /bits/ 64 <600000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@650000000 {
+				opp-hz = /bits/ 64 <650000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@700000000 {
+				opp-hz = /bits/ 64 <700000000>;
+				clock-latency-ns = <10000000>;
+			};
+			opp@750000000 {
+				opp-hz = /bits/ 64 <750000000>;
+				clock-latency-ns = <10000000>;
+			};
+		};
+
+		clk_ahb: clk_ahb {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <100000000>;
+			clock-output-names = "clk_ahb";
+		};
+
+		clk_xin: clk_xin {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <100000000>;
+			clock-output-names = "clk_xin";
+		};
+
+		cortex_cmu: cmu@cortex {
+			compatible = "baikal,cmu-device-clock";
+			#clock-cells = <1>;
+			clock-frequency = <1000000000>;
+			clock-output-names = "baikal-cmu";
+		};
+
+		avlsp_cmu1: cmu1@avlsp {
+			compatible = "baikal,cmu-device-clock";
+			#clock-cells = <1>;
+			clock-indices = <26>;
+			clock-frequency = <240000000>;
+			clock-output-names = "baikal-cmu";
+		};
+
+		xgbe_cmu0: cmu0@xgbe {
+			compatible = "fixed-clock";
+			#clock-cells = <1>;
+			clock-indices = <0>, <10>, <13>, <15>, <17>;
+			clock-output-names = "csr50_clk", "gmac0_tx2", "gmac1_tx2", "vdu_aclk", "hdmi_sfr_clk";
+			clock-frequency = <50000000>, <250000000>, <250000000>, <416666667>, <25000000>;
+		};
+
+		xgbe_cmu1: cmu1@xgbe {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <600000000>;
+			clock-output-names = "baikal-cmu";
+		};
+
+		usb_clk: usb_clk@1f04d074 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-names = "usbclk";
+			clock-frequency = <500000000>;
+			clock-output-names = "usbclk";
+		};
+
+		cmu1_avlsp_div7: cmu1_avlsp_div7 {
+			compatible = "allwinner,sun4i-a10-pll3-2x-clk", "fixed-factor-clock";
+			clocks = <&cmu1_avlsp>;
+			#clock-cells = <0>;
+			clock-div = <7>;
+			clock-mult = <1>;
+			clock-output-names = "lvds_clk";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/baikal/bm1000-cpufreq.dtsi b/arch/arm64/boot/dts/baikal/bm1000-cpufreq.dtsi
new file mode 100644
index 000000000..76fee58d8
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm1000-cpufreq.dtsi
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree include file for BE-M1000 SoC CPU frequencies
+ * Copyright (C) 2020-2021 Baikal Electronics, JSC
+ */
+
+/ {
+	cpufreq {
+		cluster0_opp: opp_table0 {
+			compatible = "operating-points-v2";
+			opp-shared;
+
+			opp@1500 {
+				opp-hz = /bits/ 64 <1500000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1400 {
+				opp-hz = /bits/ 64 <1400000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1300 {
+				opp-hz = /bits/ 64 <1300000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1200 {
+				opp-hz = /bits/ 64 <1200000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1100 {
+				opp-hz = /bits/ 64 <1100000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1000 {
+				opp-hz = /bits/ 64 <1000000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@900 {
+				opp-hz = /bits/ 64 <900000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@800 {
+				opp-hz = /bits/ 64 <800000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@700 {
+				opp-hz = /bits/ 64 <700000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@600 {
+				opp-hz = /bits/ 64 <600000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@500 {
+				opp-hz = /bits/ 64 <500000000>;
+				clock-latency-ns = <10000000>;
+			};
+		};
+
+		cluster1_opp: opp_table1 {
+			compatible = "operating-points-v2";
+			opp-shared;
+
+			opp@1500 {
+				opp-hz = /bits/ 64 <1500000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1400 {
+				opp-hz = /bits/ 64 <1400000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1300 {
+				opp-hz = /bits/ 64 <1300000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1200 {
+				opp-hz = /bits/ 64 <1200000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1100 {
+				opp-hz = /bits/ 64 <1100000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1000 {
+				opp-hz = /bits/ 64 <1000000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@900 {
+				opp-hz = /bits/ 64 <900000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@800 {
+				opp-hz = /bits/ 64 <800000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@700 {
+				opp-hz = /bits/ 64 <700000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@600 {
+				opp-hz = /bits/ 64 <600000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@500 {
+				opp-hz = /bits/ 64 <500000000>;
+				clock-latency-ns = <10000000>;
+			};
+		};
+
+		cluster2_opp: opp_table2 {
+			compatible = "operating-points-v2";
+			opp-shared;
+
+			opp@1500 {
+				opp-hz = /bits/ 64 <1500000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1400 {
+				opp-hz = /bits/ 64 <1400000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1300 {
+				opp-hz = /bits/ 64 <1300000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1200 {
+				opp-hz = /bits/ 64 <1200000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1100 {
+				opp-hz = /bits/ 64 <1100000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1000 {
+				opp-hz = /bits/ 64 <1000000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@900 {
+				opp-hz = /bits/ 64 <900000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@800 {
+				opp-hz = /bits/ 64 <800000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@700 {
+				opp-hz = /bits/ 64 <700000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@600 {
+				opp-hz = /bits/ 64 <600000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@500 {
+				opp-hz = /bits/ 64 <500000000>;
+				clock-latency-ns = <10000000>;
+			};
+		};
+
+		cluster3_opp: opp_table3 {
+			compatible = "operating-points-v2";
+			opp-shared;
+
+			opp@1500 {
+				opp-hz = /bits/ 64 <1500000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1400 {
+				opp-hz = /bits/ 64 <1400000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1300 {
+				opp-hz = /bits/ 64 <1300000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1200 {
+				opp-hz = /bits/ 64 <1200000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1100 {
+				opp-hz = /bits/ 64 <1100000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@1000 {
+				opp-hz = /bits/ 64 <1000000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@900 {
+				opp-hz = /bits/ 64 <900000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@800 {
+				opp-hz = /bits/ 64 <800000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@700 {
+				opp-hz = /bits/ 64 <700000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@600 {
+				opp-hz = /bits/ 64 <600000000>;
+				clock-latency-ns = <10000000>;
+			};
+
+			opp@500 {
+				opp-hz = /bits/ 64 <500000000>;
+				clock-latency-ns = <10000000>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/baikal/bm1000.dtsi b/arch/arm64/boot/dts/baikal/bm1000.dtsi
new file mode 100644
index 000000000..a146a36e4
--- /dev/null
+++ b/arch/arm64/boot/dts/baikal/bm1000.dtsi
@@ -0,0 +1,1043 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device tree include file for BE-M1000 SoC
+ * Copyright (C) 2017-2021 Baikal Electronics, JSC
+ */
+
+#include "bm1000-clocks.dtsi"
+#include "bm1000-cpufreq.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/*
+ * ARM GIC v3 bindings assume interrupts (in each range) counting from 0:
+ * PPI: 0..15
+ * SPI: 0..987
+ * Baikal-M documentation ("Interrupt map") places all interrupts into the
+ * linear map: SGI (0..15), PPI (16..31), SPI(32-1019).
+ * So real interrupts in this device tree must be calculated
+ * in the following manner:
+ * PPI_real = PPI_from_documentation - 16
+ * SPI_real = SPI_from_documentation - 32
+ */
+
+/ {
+	compatible = "baikal,arm", "baikal,baikal-m-soc", "simple-bus";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	interrupt-parent = <&gic>;
+
+	aliases {
+		ethernet1		= &gmac0;
+		ethernet2		= &gmac1;
+		ethernet3		= &xgmac0;
+		ethernet4		= &xgmac1;
+		gic			= &gic;
+		gpio			= &gpio;
+		i2c0			= &i2c0;
+		i2c1			= &i2c1;
+		i2s			= &i2s;
+		memory-controller1	= &ddr1;
+		memory-controller2	= &ddr2;
+		mmc0			= &mmc0;
+		pvt0			= &pvt0;
+		pvt1			= &pvt1;
+		pvt2			= &pvt2;
+		pvt3			= &pvt3;
+		pvt_mali		= &pvt_mali;
+		sata0			= &sata0;
+		sata1			= &sata1;
+		serial0			= &uart0;
+		serial1			= &uart1;
+		smbus0			= &smbus0;
+		smbus1			= &smbus1;
+		spi			= &spi0;
+		ssi0			= &spi0;
+		timer1			= &timer1;
+		timer2			= &timer2;
+		timer3			= &timer3;
+		timer4			= &timer4;
+		usb2			= &usb2;
+		usb3			= &usb3;
+		vdec			= &vdec;
+		vdu_lvds		= &vdu0;
+	};
+
+	psci {
+		compatible = "arm,psci-1.0", "arm,psci-0.2";
+		method = "smc";
+	};
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* Do not use 'cpu-map'. It leads to wrong topology. */
+
+		CPU0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x0>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster0>;
+			next-level-cache = <&cluster0_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster0_opp>;
+		};
+
+		CPU1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x1>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster0>;
+			next-level-cache = <&cluster0_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster0_opp>;
+		};
+
+		CPU2: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x100>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster1>;
+			next-level-cache = <&cluster1_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster1_opp>;
+		};
+
+		CPU3: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x101>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster1>;
+			next-level-cache = <&cluster1_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster1_opp>;
+		};
+
+		CPU4: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x200>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster2>;
+			next-level-cache = <&cluster2_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster2_opp>;
+		};
+
+		CPU5: cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x201>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster2>;
+			next-level-cache = <&cluster2_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster2_opp>;
+		};
+
+		CPU6: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x300>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster3>;
+			next-level-cache = <&cluster3_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster3_opp>;
+		};
+
+		CPU7: cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x301>;
+			enable-method = "psci";
+			i-cache-size = <0xc000>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <256>;
+			d-cache-size = <0x8000>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <256>;
+			clocks = <&cmu_cluster3>;
+			next-level-cache = <&cluster3_l2>;
+			clock-names = "baikal-ca57_cmu";
+			operating-points-v2 = <&cluster3_opp>;
+		};
+
+		cluster0_l2: l2-cache0 {
+			compatible = "cache";
+			cache-size = <0x100000>;
+			cache-line-size = <64>;
+			cache-sets = <1024>;
+			cache-unified;
+			cache-level = <2>;
+			next-level-cache = <&l3>;
+		};
+
+		cluster1_l2: l2-cache1 {
+			compatible = "cache";
+			cache-size = <0x100000>;
+			cache-line-size = <64>;
+			cache-sets = <1024>;
+			cache-unified;
+			cache-level = <2>;
+			next-level-cache = <&l3>;
+		};
+
+		cluster2_l2: l2-cache2 {
+			compatible = "cache";
+			cache-size = <0x100000>;
+			cache-line-size = <64>;
+			cache-sets = <1024>;
+			cache-unified;
+			cache-level = <2>;
+			next-level-cache = <&l3>;
+		};
+
+		cluster3_l2: l2-cache3 {
+			compatible = "cache";
+			cache-size = <0x100000>;
+			cache-line-size = <64>;
+			cache-sets = <1024>;
+			cache-unified;
+			cache-level = <2>;
+			next-level-cache = <&l3>;
+		};
+
+		l3: l3-cache {
+			cache-size = <0x800000>;
+			cache-unified;
+			cache-level = <3>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* DDR: DDR0 (0e200000, 10000, SPI_161-166_?) */
+		ddr1: memory-controller1@e200000 {
+			compatible = "be,emc", "be,memory-controller";
+			reg = <0x0 0x0e200000 0x0 0x10000>;
+			interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>, /* ddr dfi alert err */
+				     <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc corrected err */
+				     <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc uncorrected err */
+				     <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>, /* ddr sbr done */
+				     <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc corrected err fault */
+				     <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>; /* ddr ecc uncorrected err fault */
+			clocks = <&soc_smc50mhz>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		/* DDR: DDR0_PHY (0e210000, 10000, ?) */
+
+		/* DDR: DDR1 (22200000, 10000, SPI_171-176_?) */
+		ddr2: memory-controller2@22200000 {
+			compatible = "be,emc", "be,memory-controller";
+			reg = <0x0 0x22200000 0x0 0x10000>;
+			interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>, /* ddr dfi alert err */
+				     <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc corrected err */
+				     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc uncorrected err */
+				     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>, /* ddr sbr done */
+				     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>, /* ddr ecc corrected err fault */
+				     <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>; /* ddr ecc uncorrected err fault */
+			clocks = <&soc_smc50mhz>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		/* PCIe LCRU */
+		pcie_lcru: lcru@2000000 {
+			compatible = "syscon";
+			reg = <0x0 0x2000000 0x0 0x80000>;
+			/*big-endian;*/
+			status = "disabled";
+		};
+
+		/* PCIe x4 #0 */
+		pcie0: pcie@2200000 {
+			compatible = "baikal,pcie-m", "snps,dw-pcie";
+			reg = <0x0 0x02200000 0x0 0x1000>,   /* RC config space */
+			      <0x0 0x40100000 0x0 0x100000>; /* PCI config space */
+			reg-names = "dbi", "config";
+			interrupts = <GIC_SPI 426 IRQ_TYPE_LEVEL_HIGH>, /* AER */
+				     <GIC_SPI 429 IRQ_TYPE_LEVEL_HIGH>; /* MSI */
+			#interrupt-cells = <1>;
+			baikal,pcie-lcru = <&pcie_lcru 0>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			ranges = <0x81000000 0x0 0x00000000 0x0 0x40200000 0x0 0x00100000>, /* I/O */
+				 <0x82000000 0x0 0x40000000 0x4 0x00000000 0x0 0x40000000>; /* 32b non-prefetchable memory */
+			msi-parent = <&its 0x0>;
+			msi-map = <0x0 &its 0x0 0x10000>;
+			num-lanes = <4>;
+			num-viewport = <4>;
+			bus-range = <0x0 0xff>;
+			status = "disabled";
+		};
+
+		/* PCIe x4 #1 */
+		pcie1: pcie@2210000 {
+			compatible = "baikal,pcie-m", "snps,dw-pcie";
+			reg = <0x0 0x02210000 0x0 0x1000>,   /* RC config space */
+			      <0x0 0x50100000 0x0 0x100000>; /* PCI config space */
+			reg-names = "dbi", "config";
+			interrupts = <GIC_SPI 402 IRQ_TYPE_LEVEL_HIGH>,	/* AER */
+				     <GIC_SPI 405 IRQ_TYPE_LEVEL_HIGH>;	/* MSI */
+			#interrupt-cells = <1>;
+			baikal,pcie-lcru = <&pcie_lcru 1>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			ranges = <0x81000000 0x0 0x00100000 0x0 0x50000000 0x0 0x00100000>, /* I/O */
+				 <0x82000000 0x0 0x40000000 0x5 0x00000000 0x0 0x40000000>; /* 32b non-prefetchable memory */
+			msi-parent = <&its 0x0>;
+			msi-map = <0x0 &its 0x0 0x10000>;
+			num-lanes = <4>;
+			num-viewport = <4>;
+			bus-range = <0x0 0xff>;
+			status = "disabled";
+		};
+
+		/* PCIe x8 */
+		pcie2: pcie@2220000 {
+			compatible = "baikal,pcie-m", "snps,dw-pcie";
+			reg = <0x0 0x02220000 0x0 0x1000>,   /* RC config space */
+			      <0x0 0x60000000 0x0 0x100000>; /* PCI config space */
+			reg-names = "dbi", "config";
+			interrupts = <GIC_SPI 378 IRQ_TYPE_LEVEL_HIGH>, /* AER */
+				     <GIC_SPI 381 IRQ_TYPE_LEVEL_HIGH>; /* MSI */
+			#interrupt-cells = <1>;
+			baikal,pcie-lcru = <&pcie_lcru 2>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			ranges = <0x81000000 0x0 0x00200000 0x0 0x60100000 0x0 0x00100000>, /* I/O */
+				 <0x82000000 0x0 0x80000000 0x6 0x00000000 0x0 0x80000000>; /* 32b non-prefetchable memory */
+			msi-parent = <&its 0x0>;
+			msi-map = <0x0 &its 0x0 0x10000>;
+			num-lanes = <8>;
+			num-viewport = <4>;
+			bus-range = <0x0 0xff>;
+			status = "disabled";
+		};
+
+		/* PVT_0: PVT0 (28200000, 10000, SPI_151_H) */
+		pvt0: pvt0@28200000 {
+			compatible = "baikal,pvt";
+			reg = <0x0 0x28200000 0x0 0x10000>;
+			pvt_id = <0>;
+			interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* PVT_1: PVT1 (0c200000, 10000, SPI_153_H) */
+		pvt1: pvt1@c200000 {
+			compatible = "baikal,pvt";
+			reg = <0x0 0x0c200000 0x0 0x10000>;
+			pvt_id = <1>;
+			interrupts = <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* PVT_2: PVT2 (0a200000, 10000, SPI_155_H) */
+		pvt2: pvt2@a200000 {
+			compatible = "baikal,pvt";
+			reg = <0x0 0x0a200000 0x0 0x10000>;
+			pvt_id = <2>;
+			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* PVT_3: PVT3 (26200000, 10000, SPI_157_H) */
+		pvt3: pvt3@26200000 {
+			compatible = "baikal,pvt";
+			reg = <0x0 0x26200000 0x0 0x10000>;
+			pvt_id = <3>;
+			interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* PVT_MALI: PVT (2a060000, 10000, SPI_253_H) */
+		pvt_mali: pvt_mali@2a060000 {
+			compatible = "baikal,pvt";
+			reg = <0x0 0x2a060000 0x0 0x10000>;
+			pvt_id = <4>;
+			interrupts = <GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		/* AVLSP: GPIO32 (20200000, 10000, SPI_131_H) */
+		gpio: gpio@20200000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x20200000 0x0 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+
+			porta: gpio-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				#gpio-cells = <2>;
+				gpio-controller;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+				#interrupt-cells = <2>;
+				interrupt-controller;
+				interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		/* AVLSP: SPI (20210000, 10000, SPI_132_H) */
+		spi0: spi@20210000 {
+			compatible = "snps,dw-apb-ssi", "snps,dw-spi";
+			reg = <0x0 0x20210000 0x0 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cmu0_avlsp 4>;
+			clock-names = "soc_spiclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: I2S (20220000, 1000, SPI_136-139_H) */
+		i2s: i2s@20220000 {
+			compatible = "snps,designware-i2s";
+			reg = <0x0 0x20220000 0x0 0x10000>;
+			interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>, /* rx_da */
+				     <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>, /* rx_or */
+				     <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>, /* tx_emp */
+				     <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>; /* tx_or */
+			/*dmas = <&dma 2>, <&dma 3>;*/
+			/*dma-names = "tx", "rx";*/
+			/*#sound-dai-cells = <0>;*/
+			clocks = <&soc_tmp_clk>;
+			clock-names = "i2sclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: UART1 (20230000, 10000, SPI_133_H) */
+		uart0: serial0@20230000 {
+			compatible = "snps,dw-apb-uart"; /* "snps,uart-16550-compatible" */
+			reg = <0x0 0x20230000 0x0 0x10000>;
+			interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&cmu0_avlsp 1>, <&apb_clk>;
+			clock-names = "soc_uartclk", "apb_pclk";
+			/*dcd-override;*/
+			/*dsr-override;*/
+			/*cts-override;*/
+			/*ri-override;*/
+			status = "disabled";
+		};
+
+		/* AVLSP: UART2 (20240000, 10000, SPI_134_H) */
+		uart1: serial1@20240000 {
+			compatible = "snps,dw-apb-uart"; /* "snps,uart-16550-compatible" */
+			reg = <0x0 0x20240000 0x0 0x10000>;
+			interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&cmu0_avlsp 2>, <&apb_clk>;
+			clock-names = "soc_uartclk", "apb_pclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: I2C1 (20250000, 10000, SPI_140_H) */
+		i2c0: i2c0@20250000 {
+			compatible = "snps,designware-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20250000 0x0 0x10000>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+			i2c-sda-hold-time-ns = <500>;
+			clock-frequency = <400000>;
+			clocks = <&i2c_clk>;
+			clock-names = "soc_i2cclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: I2C2 (20260000, 10000, SPI_141_H) */
+		i2c1: i2c1@20260000 {
+			compatible = "snps,designware-i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20260000 0x0 0x10000>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+			i2c-sda-hold-time-ns = <500>;
+			clock-frequency = <400000>;
+			clocks = <&i2c_clk>;
+			clock-names = "soc_i2cclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: SMBus1 (20270000, 10000, SPI_142_?) */
+		smbus0: smbus0@20270000 {
+			compatible = "be,smbus";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20270000 0x0 0x10000>;
+			interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&smbus_clk>;
+			clock-names = "soc_smbusclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: SMBus2 (20280000, 10000, SPI_143_?) */
+		smbus1: smbus1@20280000 {
+			compatible = "be,smbus";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20280000 0x0 0x10000>;
+			interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency = <100000>;
+			clocks = <&smbus_clk>;
+			clock-names = "soc_smbusclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: Timers (20290000, 10000, SPI_127_L) */
+		timer1: timer1@20290000 {
+			compatible = "snps,dw-apb-timer-osc";
+			reg = <0x0 0x20290000 0x0 0x14>;
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency  = <50000000>;
+			clocks = <&timer1_clk>;
+			clock-names = "soc_timer1clk";
+			status = "disabled";
+		};
+
+		/* AVLSP: Timers (20290000, 10000, SPI_128_L) */
+		timer2: timer2@20290014 {
+			compatible = "snps,dw-apb-timer-sp";
+			reg = <0x0 0x20290014 0x0 0x14>;
+			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency  = <50000000>;
+			clocks = <&timer2_clk>;
+			clock-names = "soc_timer2clk";
+			status = "disabled";
+		};
+
+		/* AVLSP: Timers (20290000, 10000, SPI_129_L) */
+		timer3: timer3@20290028 {
+			compatible = "snps,dw-apb-timer-sp";
+			reg = <0x0 0x20290028 0x0 0x14>;
+			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency  = <50000000>;
+			clocks = <&timer3_clk>;
+			clock-names = "soc_timer3clk";
+			status = "disabled";
+		};
+
+		/* AVLSP: Timers (20290000, 10000, SPI_130_L) */
+		timer4: timer4@2029003c {
+			compatible = "snps,dw-apb-timer-sp";
+			reg = <0x0 0x2029003c 0x0 0x14>;
+			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+			clock-frequency  = <50000000>;
+			clocks = <&timer4_clk>;
+			clock-names = "soc_timer4clk";
+			status = "disabled";
+		};
+
+		/* AVLSP: eSPI (202a0000, 10000, SPI_135_?) */
+		espi0: espi0@202a0000 {
+			compatible = "be,espi";
+			reg = <0x0 0x202a0000 0x0 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cmu0_avlsp 5>;
+			clock-names = "soc_espiclk";
+			status = "disabled";
+			/*
+			 * Block Configuration:
+			 * - master/slave
+			 * - 32-bit APB slave
+			 * - tx-fifo = rx-fifo = 256 byte
+			 * - 4 SPI IO channels
+			 * - 8 slave select IO channels
+			 * - DMA - missing
+			 * - M-flash controller - missing
+			 */
+		};
+
+		/* AVLSP: DMAC (202b0000, 10000, SPI_41-80_H) */
+		lsdma: dma@202b0000 {
+			compatible = "snps,dma-spear1340";
+			reg = <0x0 0x202b0000 0x0 0x10000>;
+			/* TODO: interrupts */
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			dma-channels = <8>;
+			dma-requests = <16>;
+			dma-masters = <2>;
+			#dma-cells = <3>;
+			chan_allocation_order = <1>;
+			chan_priority = <1>;
+			block_size = <0xfff>;
+			data_width = <3 3 0 0>;
+			clocks = <&soc_tmp_clk>;
+			clock-names = "tmpclk";
+			status = "disabled";
+		};
+
+		/* AVLSP: HDA (202c0000, 10000, SPI_86_H) */
+
+		/* AVLSP: VDU (202d0000, 10000, SPI_144-145_?) */
+		vdu0: vdu_lvds@202d0000 {
+			compatible = "baikal,vdu";
+			reg = <0x0 0x202d0000 0x0 0x1000>;
+			interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>, /* VDU INTR */
+				     <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>; /* VDU INTR_CDD */
+			clocks = <&cmu1_avlsp_div7>, <&cmu0_avlsp 26>;
+			clock-names = "pclk", "aclk";
+			lvds-out;
+			status = "disabled";
+		};
+
+		/* AVLSP: SD/eMMC (202e0000, 10000, SPI_83-84_H) */
+		mmc0: mmc@202e0000 {
+			compatible = "snps,dwcmshc-sdhci";
+			reg = <0x0 0x202e0000 0x0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			clock-names = "bus", "core";
+			clocks = <&cmu0_avlsp 18>, <&cmu0_avlsp 19>;
+			status = "disabled";
+		};
+
+		vdec: vdec@24200000 {
+			compatible = "baikal,d5500-vxd";
+			reg = <0x0 0x24200000 0x0 0x10000>;
+			interrupts = <GIC_SPI 497 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		gpu: gpu@2a200000 {
+			compatible = "arm,mali-midgard", "arm,mali-t628";
+			#cooling-cells = <2>; /* min followed by max */
+			reg = <0x0 0x2a200000 0x0 0x4000>;
+			interrupts = <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "job", "mmu", "gpu";
+			clocks = <&cmu_mali>;
+			clock-names = "gpuclk";
+			operating-points-v2 = <&gpu_opp_table>;
+		};
+
+		/* USB MM: USB2 (2c400000, 100000, SPI_267-268_H, SPI_277_H) */
+		usb2: usb2@2c400000 {
+			compatible = "be,baikal-dwc3";
+			status = "disabled";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			clocks = <&usb_clk>;
+			clock-names = "usb";
+			dma-coherent;
+
+			dwc3@2c400000 {
+				compatible = "snps,dwc3", "synopsys,dwc3", "generic-xhci";
+				reg = <0x0 0x2c400000 0x0 0x100000>;
+				interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 236 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				dma-coherent;
+				maximum-speed = "high-speed";
+			};
+		};
+
+		/* USB MM: USB3 (2c500000, 100000, SPI_269-276_H, SPI_278_H) */
+		usb3: usb3@2c500000 {
+			compatible = "be,baikal-dwc3";
+			status = "disabled";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			clocks = <&usb_clk>;
+			clock-names = "usb";
+
+			dwc3@2c500000 {
+				compatible = "snps,dwc3", "synopsys,dwc3", "generic-xhci";
+				reg = <0x0 0x2c500000 0x0 0x100000>;
+				interrupts = <GIC_SPI 237 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 239 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 240 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 241 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 242 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 243 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>;
+				dr_mode = "host";
+				dma-coherent;
+			};
+		};
+
+		/* USB MM: SATA0 (2c600000, 10000, SPI_265_H) */
+		sata0: sata0@2c600000 {
+			compatible = "snps,dwc-ahci", "generic-ahci";
+			reg = <0x0 0x2c600000 0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
+			ports-implemented = <1>;
+			dma-coherent;
+			clocks = <&soc_faxiclk>;
+			clock-names = "sataclk";
+			status = "disabled";
+		};
+
+		/* USB MM: SATA1 (2c610000, 10000, SPI_266_H) */
+		sata1: sata1@2c610000 {
+			compatible = "snps,dwc-ahci", "generic-ahci";
+			reg = <0x0 0x2c610000 0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 234 IRQ_TYPE_LEVEL_HIGH>;
+			ports-implemented = <1>;
+			dma-coherent;
+			clocks = <&soc_faxiclk>;
+			clock-names = "sataclk";
+			status = "disabled";
+		};
+
+		/* DMA-330: DMAC ("secure",     2c620000, 10000, SPI_255-263_H) */
+		/*               ("non-secure", 2c630000, 10000, ?) */
+		dma: dma@2c620000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0x0 0x2c620000 0 0x1000>;
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <32>;
+			interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 227 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 230 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 231 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&soc_faxiclk>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		/* GIC-500: GICV3 (2d000000, 400000, *) */
+		gic: interrupt-controller@2d000000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <3>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			interrupt-controller;
+			/* TODO: gic memory map */
+			reg = <0x0 0x2d000000 0x0 0x10000>,  /* GICD, GIC Distributor interface */
+			      <0x0 0x2d100000 0x0 0x200000>; /* GICR, GIC Redistributors */
+			      /* Optional ranges: TODO */
+			    /*<0x0 0x2d0xxxxx 0x0 0x2000>,*/ /* GICC, GIC CPU interface */
+			    /*<0x0 0x2d0xxxxx 0x0 0x2000>,*/ /* GICH, GIC Hypervisor interface */
+			    /*<0x0 0x2d0xxxxx 0x0 0x2000>;*/ /* GICV, GIC Virtual CPU interface */
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+			/* GIC.v3 Interrupt Translation Service */
+			its: its@2d020000 {
+				compatible = "arm,gic-v3-its";
+				msi-controller;
+				#msi-cells = <1>;
+				reg = <0x0 0x2d020000 0x0 0x20000>; /* GITS */
+			};
+		};
+
+		/* XGBE MM: GMAC0 (30240000, 10000, SPI_323_H) */
+		gmac0: eth0@30240000 {
+			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+			reg = <0x0 0x30240000 0x0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 291 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			max-speed = <1000>;
+			clocks = <&soc_ethclk>, <&cmu0_xgbe 10>;
+			clock-names = "stmmaceth", "tx2_clk";
+			snps,fixed-burst;
+			mac-address = [ 00 00 00 00 00 00 ];
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			phy-mode = "rgmii-id";
+			phy-handle = <&gmac0_phy>;
+			snps,reset-delays-us = <0 10200 1000>;
+			status = "disabled";
+			dma-coherent;
+
+			gmdio0: gmac0_mdio {
+				compatible = "snps,dwmac-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				gmac0_phy: ethernet-phy@3 {
+					compatible = "micrel,ksz9031", "ethernet-phy-id0022.1620", "ethernet-phy-ieee802.3-c22";
+					reg = <0x3>;
+					txd0-skew-ps = <0>;
+					txd1-skew-ps = <0>;
+					txd2-skew-ps = <0>;
+					txd3-skew-ps = <0>;
+					txc-skew-ps  = <0xff>;
+				};
+			};
+		};
+
+		/* XGBE MM: GMAC1 (30250000, 10000, SPI_324_H) */
+		gmac1: eth1@30250000 {
+			compatible = "be,dwmac", "snps,dwmac-3.710", "snps,dwmac";
+			reg = <0x0 0x30250000 0x0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 292 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			max-speed = <1000>;
+			clocks = <&soc_ethclk>, <&cmu0_xgbe 13>;
+			clock-names = "stmmaceth", "tx2_clk";
+			snps,fixed-burst;
+			mac-address = [ 00 00 00 00 00 00 ];
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			phy-mode = "rgmii-id";
+			phy-handle = <&gmac1_phy>;
+			snps,reset-delays-us = <0 10200 1000>;
+			status = "disabled";
+			dma-coherent;
+
+			gmdio1: gmac1_mdio {
+				compatible = "snps,dwmac-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				gmac1_phy: ethernet-phy@3 {
+					compatible = "micrel,ksz9031", "ethernet-phy-id0022.1620", "ethernet-phy-ieee802.3-c22";
+					reg = <0x3>;
+					txd0-skew-ps = <0>;
+					txd1-skew-ps = <0>;
+					txd2-skew-ps = <0>;
+					txd3-skew-ps = <0>;
+					txc-skew-ps  = <0xff>;
+				};
+			};
+		};
+
+		/* Baikal internal MDIO */
+		mdio0: be-mdio {
+			compatible = "be,mdio-gpio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			mdc-pin = <&porta 30 GPIO_ACTIVE_HIGH>;
+			mdio-pin = <&porta 29 GPIO_ACTIVE_HIGH>;
+			clocks = <&gpio_clk>;
+			clock-names = "gpioclk";
+
+			mv_ch0: ethernet-phy@c {
+				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+				reg = <0x0c>;
+				phy-mode = "xgmii";
+				mv,line-mode = "KR";
+				mv,host-mode = "KX4";
+			};
+
+			mv_ch2: ethernet-phy@e {
+				compatible = "marvell,88x2222", "ethernet-phy-ieee802.3-c45";
+				reg = <0x0e>;
+				phy-mode = "xgmii";
+				mv,line-mode = "KR";
+				mv,host-mode = "KX4";
+			};
+		};
+
+		/* XGMAC0 */
+		xgmac0: eth2@30200000 {
+			compatible = "amd,xgbe-seattle-v1a";
+			reg = <0x0 0x30200000 0x0 0x10000>,
+			      <0x0 0x30210000 0x0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 293 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 294 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 295 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 296 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 297 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 298 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 299 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 300 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 301 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 302 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 303 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 304 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 305 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 306 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 307 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 308 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 309 IRQ_TYPE_LEVEL_HIGH>;
+			fsl,num-rx-queues=<3>;
+			clocks = <&soc_xgbeclk>, <&soc_xgbeclk>, <&soc_xgbeclk>;
+			clock-names = "dma_clk", "ptp_clk", "xgbe_clk";
+			phy-mode = "xgmii";
+			mac-address = [ 00 20 13 ba 1c a1 ];
+			local-mac-address = [ 00 20 13 ba 1c a1 ];
+			be,pcs-mode = "KX4";
+			ext-phy-handle = <&mv_ch0>;
+			status = "disabled";
+			amd,per-channel-interrupt;
+			amd,speed-set = <0>;
+			#stream-id-cells = <16>;
+		};
+
+		/* XGMAC1 */
+		xgmac1: eth3@30220000 {
+			compatible = "amd,xgbe-seattle-v1a";
+			reg = <0x0 0x30220000 0x0 0x10000>,
+			      <0x0 0x30230000 0x0 0x10000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 310 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 311 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 312 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 313 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 314 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 315 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 316 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 317 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 318 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 319 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 320 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 321 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 322 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 323 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 324 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 325 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 326 IRQ_TYPE_LEVEL_HIGH>;
+			fsl,num-rx-queues=<3>;
+			clocks = <&soc_xgbeclk>, <&soc_xgbeclk>, <&soc_xgbeclk>;
+			clock-names = "dma_clk", "ptp_clk", "xgbe_clk";
+			phy-mode = "xgmii";
+			mac-address = [ 00 20 13 ba 1c a2 ];
+			local-mac-address = [ 00 20 13 ba 1c a2 ];
+			be,pcs-mode = "KX4";
+			ext-phy-handle = <&mv_ch2>;
+			status = "disabled";
+			amd,per-channel-interrupt;
+			amd,speed-set = <0>;
+			#stream-id-cells = <16>;
+		 };
+
+		/* HDMI VDU (30260000, 10000, SPI_361-362_?) */
+		vdu1: vdu_hdmi@30260000 {
+			compatible = "baikal,vdu";
+			reg = <0x0 0x30260000 0x0 0x1000>;
+			interrupts = <GIC_SPI 329 IRQ_TYPE_LEVEL_HIGH>, /* VDU INTR */
+				     <GIC_SPI 330 IRQ_TYPE_LEVEL_HIGH>; /* VDU INTR_CDD */
+			clocks = <&cmu1_xgbe 0>, <&ref_clk>;
+			clock-names = "pclk", "aclk";
+			status = "disabled";
+
+			port {
+				vdu_hdmi_out: endpoint {
+					remote-endpoint = <&hdmi_tx_in>;
+				};
+			};
+		};
+
+		hdmi: hdmi@30280000 {
+			compatible = "baikal,hdmi";
+			reg = <0 0x30280000 0 0x20000>;
+			reg-io-width = <4>;
+			interrupts = <GIC_SPI 331 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&xgbe_cmu0 0>, <&xgbe_cmu0 17>;
+			clock-names = "iahb", "isfr";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					hdmi_tx_in: endpoint {
+						remote-endpoint = <&vdu_hdmi_out>;
+					};
+				};
+				port@1 {
+					reg = <1>;
+					hdmi_tx_out: endpoint {
+						remote-endpoint = <&hdmi_con>;
+					};
+				};
+			};
+		};
+	}; /* end of soc node */
+
+	hdmi-out {
+		compatible = "hdmi-connector";
+		label = "HDMI0 OUT";
+		type = "a";
+
+		port {
+			hdmi_con: endpoint {
+				remote-endpoint = <&hdmi_tx_out>;
+			};
+		};
+	};
+};
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 0138fb14e..6ed8cddd3 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -72,6 +72,7 @@ obj-y					+= analogbits/
 obj-$(CONFIG_COMMON_CLK_AT91)		+= at91/
 obj-$(CONFIG_ARCH_ARTPEC)		+= axis/
 obj-$(CONFIG_ARC_PLAT_AXS10X)		+= axs10x/
+obj-$(CONFIG_ARCH_BAIKAL)		+= baikal/
 obj-y					+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
diff --git a/drivers/clk/baikal/Makefile b/drivers/clk/baikal/Makefile
new file mode 100644
index 000000000..56aa4de40
--- /dev/null
+++ b/drivers/clk/baikal/Makefile
@@ -0,0 +1 @@
+obj-y += clk-baikal.o
\ No newline at end of file
diff --git a/drivers/clk/baikal/clk-baikal.c b/drivers/clk/baikal/clk-baikal.c
new file mode 100644
index 000000000..82928d69b
--- /dev/null
+++ b/drivers/clk/baikal/clk-baikal.c
@@ -0,0 +1,435 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * clk-baikal.c - Baikal-M clock driver.
+ *
+ * Copyright (C) 2015,2016,2020,2021 Baikal Electronics JSC
+ * Author: Ekaterina Skachko <ekaterina.skachko@baikalelectronics.ru>
+ */
+
+#include <asm/setup.h>
+#include <linux/arm-smccc.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#define CMU_PLL_SET_RATE		0
+#define CMU_PLL_GET_RATE		1
+#define CMU_PLL_ENABLE			2
+#define CMU_PLL_DISABLE			3
+#define CMU_PLL_ROUND_RATE		4
+#define CMU_PLL_IS_ENABLED		5
+#define CMU_CLK_CH_SET_RATE		6
+#define CMU_CLK_CH_GET_RATE		7
+#define CMU_CLK_CH_ENABLE		8
+#define CMU_CLK_CH_DISABLE		9
+#define CMU_CLK_CH_ROUND_RATE		10
+#define CMU_CLK_CH_IS_ENABLED		11
+
+struct baikal_clk_cmu {
+	struct clk_hw	hw;
+	uint32_t	cmu_id;
+	unsigned int	parent;
+	const char	*name;
+	spinlock_t	*lock;
+	void __iomem	*reg;
+	unsigned int	latency; /* ns */
+	unsigned int	min, max, step;
+	unsigned int	clk_ch_num;
+	uint32_t	is_clk_ch;
+};
+
+#define to_baikal_cmu(_hw) container_of(_hw, struct baikal_clk_cmu, hw)
+
+/* Pointer to the place on handling SMC CMU calls in monitor */
+#define BAIKAL_SMC_LCRU_ID	0x82000000
+
+static int baikal_clk_enable(struct clk_hw *hw)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	uint32_t cmd;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_ENABLE;
+	} else {
+		cmd = CMU_PLL_ENABLE;
+	}
+
+	/* If clock valid */
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, 0,
+			pclk->parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x): %s\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			res.a0 ? "error" : "ok");
+
+	return res.a0;
+}
+
+static void baikal_clk_disable(struct clk_hw *hw)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	uint32_t cmd;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_DISABLE;
+	} else {
+		cmd = CMU_PLL_DISABLE;
+	}
+
+	/* If clock valid */
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, 0,
+			pclk->parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x): %s\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			res.a0 ? "error" : "ok");
+}
+
+static int baikal_clk_is_enabled(struct clk_hw *hw)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	uint32_t cmd;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_IS_ENABLED;
+	} else {
+		cmd = CMU_PLL_IS_ENABLED;
+	}
+
+	/* If clock valid */
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, 0,
+			pclk->parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x): %s\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			res.a0 ? "true" : "false");
+
+	return res.a0;
+}
+
+static unsigned long baikal_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	uint32_t cmd;
+	unsigned long parent;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_GET_RATE;
+		parent = pclk->parent;
+	} else {
+		cmd = CMU_PLL_GET_RATE;
+		parent= parent_rate;
+	}
+
+	/* If clock valid */
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, 0,
+			parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x): %ld Hz\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			res.a0);
+
+	/* Return actual freq */
+	return res.a0;
+}
+
+static int baikal_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long parent_rate)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	uint32_t cmd;
+	unsigned long parent;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_SET_RATE;
+		parent = pclk->parent;
+	} else {
+		cmd = CMU_PLL_SET_RATE;
+		parent = parent_rate;
+	}
+
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, rate,
+			parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x, %ld Hz): %s\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			rate,
+			res.a0 ? "error" : "ok");
+
+	return res.a0;
+}
+
+static long baikal_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *prate)
+{
+	struct arm_smccc_res res;
+	struct baikal_clk_cmu *pclk = to_baikal_cmu(hw);
+	unsigned long parent;
+	uint32_t cmd;
+
+	if (pclk->is_clk_ch) {
+		cmd = CMU_CLK_CH_ROUND_RATE;
+		parent = pclk->parent;
+	} else {
+		cmd = CMU_PLL_ROUND_RATE;
+		parent = *prate;
+	}
+
+	/* If clock valid */
+	arm_smccc_smc(BAIKAL_SMC_LCRU_ID, pclk->cmu_id, cmd, rate,
+			parent, 0, 0, 0, &res);
+
+	pr_debug("%s(%s, %s@0x%x): %ld Hz\n",
+			__func__,
+			pclk->name,
+			pclk->is_clk_ch ? "clkch" : "pll",
+			pclk->cmu_id,
+			res.a0);
+
+	/* Return actual freq */
+	return res.a0;
+}
+
+const struct clk_ops be_clk_pll_ops = {
+	.enable = baikal_clk_enable,
+	.disable = baikal_clk_disable,
+	.is_enabled = baikal_clk_is_enabled,
+	.recalc_rate = baikal_clk_recalc_rate,
+	.set_rate = baikal_clk_set_rate,
+	.round_rate = baikal_clk_round_rate
+};
+
+static int baikal_clk_probe(struct platform_device *pdev)
+{
+	struct clk_init_data init;
+	struct clk_init_data *init_ch;
+	struct baikal_clk_cmu *cmu;
+	struct baikal_clk_cmu **cmu_ch;
+	struct device_node *node = pdev->dev.of_node;
+
+	struct clk *clk;
+	struct clk_onecell_data *clk_ch;
+
+	int number, i = 0;
+	u32 rc, index;
+	struct property *prop;
+	const __be32 *p;
+	const char *clk_ch_name;
+	const char *parent_name;
+
+	cmu = kmalloc(sizeof(struct baikal_clk_cmu *), GFP_KERNEL);
+	if (!cmu) {
+		pr_err("%s: could not allocate CMU clk\n", __func__);
+		kfree(cmu);
+		return -ENOMEM;
+	}
+
+	of_property_read_string(node, "clock-output-names", &cmu->name);
+	of_property_read_u32(node, "clock-frequency", &cmu->parent);
+	of_property_read_u32(node, "cmu-id", &cmu->cmu_id);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	/* Setup clock init structure */
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+	init.name = cmu->name;
+	init.ops = &be_clk_pll_ops;
+	init.flags = CLK_IGNORE_UNUSED;
+
+	cmu->hw.init = &init;
+	cmu->is_clk_ch = 0;
+
+	/* Register the clock */
+	pr_debug("%s: add %s, parent %s\n", __func__, cmu->name, parent_name ? parent_name : "null");
+	clk = clk_register(NULL, &cmu->hw);
+
+	if (IS_ERR(clk)) {
+		pr_err("%s: could not register clk %s\n", __func__, cmu->name);
+		return -ENOMEM;
+	}
+
+	/* Register the clock for lookup */
+	rc = clk_register_clkdev(clk, cmu->name, NULL);
+	if (rc != 0) {
+		pr_err("%s: could not register lookup clk %s\n",
+			__func__, cmu->name);
+	}
+
+	/* FIXME We probably SHOULDN'T enable it here */
+	clk_prepare_enable(clk);
+
+	number = of_property_count_u32_elems(node, "clock-indices");
+
+	if (number > 0) {
+		clk_ch = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+ 		if (!clk_ch) {
+			pr_err("%s: could not allocate CMU clk channel\n", __func__);
+			return -ENOMEM;
+ 		}
+
+		/* Get the last index to find out max number of children*/
+		of_property_for_each_u32(node, "clock-indices", prop, p, index) {
+			;
+		}
+
+		clk_ch->clks = kcalloc(index + 1, sizeof(struct clk *), GFP_KERNEL);
+		clk_ch->clk_num = index + 1;
+		cmu_ch = kcalloc((index + 1), sizeof(struct baikal_clk_cmu *), GFP_KERNEL);
+		if (!cmu_ch) {
+			kfree(clk_ch);
+			return -ENOMEM;
+		}
+		init_ch = kcalloc((number + 1), sizeof(struct clk_init_data), GFP_KERNEL);
+		if (!init_ch) {
+			pr_err("%s: could not allocate CMU init structure \n", __func__);
+			kfree(cmu_ch);
+			kfree(clk_ch);
+			return -ENOMEM;
+		}
+
+		of_property_for_each_u32(node, "clock-indices", prop, p, index) {
+			of_property_read_string_index(node, "clock-names",
+							i, &clk_ch_name);
+			pr_debug("%s: clkch <%s>, index %d, i %d\n", __func__, clk_ch_name, index, i);
+			init_ch[i].parent_names = &cmu->name;
+			init_ch[i].num_parents = 1;
+			init_ch[i].name = clk_ch_name;
+			init_ch[i].ops = &be_clk_pll_ops;
+			init_ch[i].flags = CLK_IGNORE_UNUSED;
+
+			cmu_ch[index] = kmalloc(sizeof(struct baikal_clk_cmu), GFP_KERNEL);
+			cmu_ch[index]->name = clk_ch_name;
+			cmu_ch[index]->cmu_id = index;
+			cmu_ch[index]->parent = cmu->cmu_id;
+			cmu_ch[index]->is_clk_ch = 1;
+			cmu_ch[index]->hw.init = &init_ch[i];
+			clk_ch->clks[index] = clk_register(NULL, &cmu_ch[index]->hw);
+
+			if (IS_ERR(clk_ch->clks[index])) {
+				pr_err("%s: could not register clk %s\n", __func__, clk_ch_name);
+			}
+
+			/* Register the clock for lookup */
+			rc = clk_register_clkdev(clk_ch->clks[index], clk_ch_name, NULL);
+			if (rc != 0) {
+				pr_err("%s: could not register lookup clk %s\n",
+					__func__, clk_ch_name);
+			}
+
+			/* FIXME We probably SHOULDN'T enable it here */
+			clk_prepare_enable(clk_ch->clks[index]);
+			i++;
+		}
+
+		return of_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get, clk_ch);
+	}
+
+	return of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get, clk);
+}
+
+static int baikal_clk_remove(struct platform_device *pdev)
+{
+	of_clk_del_provider(pdev->dev.of_node);
+
+	return 0;
+}
+
+static const struct of_device_id baikal_clk_of_match[] = {
+	{ .compatible = "baikal,cmu" },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver clk_avlsp_cmu0_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-avlsp-cmu0",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+static struct platform_driver clk_avlsp_cmu1_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-avlsp-cmu1",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+static struct platform_driver clk_ca57_cmu_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-ca57_cmu",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+static struct platform_driver clk_mali_cmu_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-mali-cmu",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+static struct platform_driver clk_xgbe_cmu0_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-xgbe-cmu0",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+static struct platform_driver clk_xgbe_cmu1_driver = {
+	.probe	= baikal_clk_probe,
+	.remove	= baikal_clk_remove,
+	.driver	= {
+		.name = "baikal-xgbe-cmu1",
+		.of_match_table = baikal_clk_of_match
+	}
+};
+
+module_platform_driver(clk_avlsp_cmu0_driver);
+module_platform_driver(clk_avlsp_cmu1_driver);
+module_platform_driver(clk_ca57_cmu_driver);
+module_platform_driver(clk_mali_cmu_driver);
+module_platform_driver(clk_xgbe_cmu0_driver);
+module_platform_driver(clk_xgbe_cmu1_driver);
+
+MODULE_DESCRIPTION("Baikal-M clock driver");
+MODULE_AUTHOR("Ekaterina Skachko <ekaterina.skachko@baikalelectronics.ru>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:baikal-cmu");
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index 1200842c3..e4d0a0e58 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -32,6 +32,8 @@ static const struct of_device_id whitelist[] __initconst = {
 	{ .compatible = "arm,integrator-ap", },
 	{ .compatible = "arm,integrator-cp", },
 
+	{ .compatible = "baikal,baikal-m", },
+
 	{ .compatible = "hisilicon,hi3660", },
 
 	{ .compatible = "fsl,imx27", },
diff --git a/drivers/firmware/efi/arm-runtime.c b/drivers/firmware/efi/arm-runtime.c
index e2ac5fa55..8318276ae 100644
--- a/drivers/firmware/efi/arm-runtime.c
+++ b/drivers/firmware/efi/arm-runtime.c
@@ -75,6 +75,9 @@ static bool __init efi_virtmap_init(void)
 			pr_warn("  EFI remap %pa: failed to create mapping (%d)\n",
 				&phys, ret);
 			return false;
+		} else {
+			pr_info("  EFI remap %pa => %llx\n",
+				&phys, (unsigned long long)md->virt_addr);
 		}
 		/*
 		 * If this entry covers the address of the UEFI system table,
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 649f17dfc..56eac1095 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -202,6 +202,7 @@ config DRM_SCHED
 source "drivers/gpu/drm/i2c/Kconfig"
 
 source "drivers/gpu/drm/arm/Kconfig"
+source "drivers/gpu/drm/baikal/Kconfig"
 
 config DRM_RADEON
 	tristate "ATI Radeon"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 82ff826b3..a9b4690ed 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -120,3 +120,4 @@ obj-$(CONFIG_DRM_LIMA)  += lima/
 obj-$(CONFIG_DRM_PANFROST) += panfrost/
 obj-$(CONFIG_DRM_ASPEED_GFX) += aspeed/
 obj-$(CONFIG_DRM_MCDE) += mcde/
+obj-$(CONFIG_DRM_BAIKAL_VDU) += baikal/
diff --git a/drivers/gpu/drm/baikal/Kconfig b/drivers/gpu/drm/baikal/Kconfig
new file mode 100644
index 000000000..a1bcdbe57
--- /dev/null
+++ b/drivers/gpu/drm/baikal/Kconfig
@@ -0,0 +1,13 @@
+config DRM_BAIKAL_VDU
+	tristate "DRM Support for Baikal-M VDU"
+	depends on DRM
+	depends on ARM || ARM64 || COMPILE_TEST
+	depends on COMMON_CLK
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_GEM_CMA_HELPER
+	select DRM_PANEL
+	select VT_HW_CONSOLE_BINDING if FRAMEBUFFER_CONSOLE
+	help
+	  Choose this option for DRM support for the Baikal-M Video Display Unit (VDU).
+	  If M is selected the module will be called baikal_vdu_drm.
diff --git a/drivers/gpu/drm/baikal/Makefile b/drivers/gpu/drm/baikal/Makefile
new file mode 100644
index 000000000..eb029494e
--- /dev/null
+++ b/drivers/gpu/drm/baikal/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+baikal_vdu_drm-y +=	baikal_vdu_connector.o \
+		baikal_vdu_crtc.o \
+		baikal_vdu_drv.o \
+		baikal_vdu_plane.o
+
+baikal_vdu_drm-$(CONFIG_DEBUG_FS) += baikal_vdu_debugfs.o
+
+obj-$(CONFIG_DRM_BAIKAL_VDU) += baikal_vdu_drm.o
+obj-$(CONFIG_DRM_BAIKAL_HDMI) += baikal-hdmi.o
diff --git a/drivers/gpu/drm/baikal/baikal-hdmi.c b/drivers/gpu/drm/baikal/baikal-hdmi.c
new file mode 100644
index 000000000..757b84086
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal-hdmi.c
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Baikal Electronics BE-M1000 DesignWare HDMI 2.0 Tx PHY support driver
+ *
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation
+ *
+ * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
+ */
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <drm/drm_modes.h>
+
+#include <drm/bridge/dw_hdmi.h>
+
+int fixed_clock = 0;
+int max_clock = 0;
+
+static const struct dw_hdmi_mpll_config baikal_hdmi_mpll_cfg[] = {
+	/* pixelclk      opmode  gmp         */
+	{  44900000, { { 0x00b3, 0x0000 }, }, },
+	{  90000000, { { 0x0072, 0x0001 }, }, },
+	{ 182750000, { { 0x0051, 0x0002 }, }, },
+	{ 340000000, { { 0x0040, 0x0003 }, }, },
+	{ 594000000, { { 0x1a40, 0x0003 }, }, },
+	{ ~0UL,      { { 0x0000, 0x0000 }, }, }
+};
+
+static const struct dw_hdmi_curr_ctrl baikal_hdmi_cur_ctr[] = {
+	/* pixelclk    current   */
+	{  44900000, { 0x0000, }, },
+	{  90000000, { 0x0008, }, },
+	{ 182750000, { 0x001b, }, },
+	{ 340000000, { 0x0036, }, },
+	{ 594000000, { 0x003f, }, },
+	{ ~0UL,      { 0x0000, }, }
+};
+
+static const struct dw_hdmi_phy_config baikal_hdmi_phy_cfg[] = {
+	/* pixelclk  symbol  term    vlev */
+	{ 148250000, 0x8009, 0x0004, 0x0232},
+	{ 218250000, 0x8009, 0x0004, 0x0230},
+	{ 288000000, 0x8009, 0x0004, 0x0273},
+	{ 340000000, 0x8029, 0x0004, 0x0273},
+	{ 594000000, 0x8039, 0x0004, 0x014a},
+	{ ~0UL,      0x0000, 0x0000, 0x0000}
+};
+
+static enum drm_mode_status baikal_hdmi_mode_valid(struct drm_connector *con,
+                          const struct drm_display_mode *mode)
+{
+	if (mode->clock < 13500)
+		return MODE_CLOCK_LOW;
+	if (mode->clock >= 340000)
+		return MODE_CLOCK_HIGH;
+	if (fixed_clock && mode->clock != fixed_clock)
+		return MODE_BAD;
+	if (max_clock && mode->clock > max_clock)
+		return MODE_BAD;
+
+	return MODE_OK;
+}
+
+static struct dw_hdmi_plat_data baikal_dw_hdmi_plat_data = {
+	.mpll_cfg   = baikal_hdmi_mpll_cfg,
+	.cur_ctr    = baikal_hdmi_cur_ctr,
+	.phy_config = baikal_hdmi_phy_cfg,
+	.mode_valid = baikal_hdmi_mode_valid,
+};
+
+static int baikal_dw_hdmi_probe(struct platform_device *pdev)
+{
+	struct dw_hdmi *hdmi;
+	hdmi = dw_hdmi_probe(pdev, &baikal_dw_hdmi_plat_data);
+	if (IS_ERR(hdmi)) {
+		return PTR_ERR(hdmi);
+	} else {
+		return 0;
+	}
+}
+
+static int baikal_dw_hdmi_remove(struct platform_device *pdev)
+{
+	struct dw_hdmi *hdmi = platform_get_drvdata(pdev);
+	dw_hdmi_remove(hdmi);
+	return 0;
+}
+
+static const struct of_device_id baikal_dw_hdmi_of_table[] = {
+	{ .compatible = "baikal,hdmi" },
+	{ /* Sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, baikal_dw_hdmi_of_table);
+
+static struct platform_driver baikal_dw_hdmi_platform_driver = {
+	.probe		= baikal_dw_hdmi_probe,
+	.remove		= baikal_dw_hdmi_remove,
+	.driver		= {
+		.name	= "baikal-dw-hdmi",
+		.of_match_table = baikal_dw_hdmi_of_table,
+	},
+};
+
+module_param(fixed_clock, int, 0644);
+module_param(max_clock, int, 0644);
+
+module_platform_driver(baikal_dw_hdmi_platform_driver);
+
+MODULE_AUTHOR("Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal BE-M1000 SoC DesignWare HDMI 2.0 Tx + Gen2 PHY Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_connector.c b/drivers/gpu/drm/baikal/baikal_vdu_connector.c
new file mode 100644
index 000000000..805e6e17e
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_connector.c
@@ -0,0 +1,424 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+/**
+ * baikal_vdu_connector.c
+ * Implementation of the connector functions for Baikal Electronics
+ * BE-M1000 SoC's VDU
+ */
+
+#include <linux/clk.h>
+#include <linux/input.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define BAIKAL_VDU_MIN_BRIGHTNESS	0
+#define BAIKAL_VDU_DEFAULT_BRIGHTNESS	50
+#define BAIKAL_VDU_BRIGHTNESS_STEP	5
+#define BAIKAL_VDU_DEFAULT_PWM_FREQ	10000
+
+static void baikal_vdu_connector_destroy(struct drm_connector *connector)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	if (priv->panel)
+		drm_panel_detach(priv->panel);
+
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static void baikal_vdu_connector_force(struct drm_connector *connector)
+{
+	struct baikal_vdu_private *priv = to_baikal_vdu_private(connector);
+	u32 cntl = readl(priv->regs + CR1);
+	if (connector->force == DRM_FORCE_OFF)
+		cntl &= ~CR1_LCE;
+	else
+		cntl |= CR1_LCE;
+	writel(cntl, priv->regs + CR1);
+}
+
+static enum drm_connector_status baikal_vdu_connector_detect(
+		struct drm_connector *connector, bool force)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	return (priv->panel ?
+		connector_status_connected :
+		connector_status_disconnected);
+}
+
+static int baikal_vdu_connector_helper_get_modes(
+		struct drm_connector *connector)
+{
+	struct baikal_vdu_private *priv =
+		to_baikal_vdu_private(connector);
+
+	if (!priv->panel)
+		return 0;
+
+	return drm_panel_get_modes(priv->panel);
+}
+
+int baikal_vdu_lvds_set_property(struct drm_connector *connector,
+				       struct drm_property *property,
+				       uint64_t value)
+{
+	struct drm_encoder *encoder = connector->encoder;
+
+	if (!encoder)
+		return -1;
+
+	if (!strcmp(property->name, "scaling mode")) {
+		uint64_t curval;
+		switch (value) {
+		case DRM_MODE_SCALE_FULLSCREEN:
+			break;
+		case DRM_MODE_SCALE_NO_SCALE:
+			break;
+		case DRM_MODE_SCALE_ASPECT:
+			break;
+		default:
+			goto set_prop_error;
+		}
+
+		if (drm_object_property_get_value(&connector->base,
+						     property,
+						     &curval))
+			goto set_prop_error;
+
+		if (curval == value)
+			goto set_prop_done;
+
+		if (drm_object_property_set_value(&connector->base,
+							property,
+							value))
+			goto set_prop_error;
+
+	} else if (!strcmp(property->name, "backlight")) {
+		if (drm_object_property_set_value(&connector->base,
+							property,
+							value))
+			goto set_prop_error;
+		else {
+			// TBD set backlight
+		}
+	} else if (!strcmp(property->name, "DPMS")) {
+		const struct drm_encoder_helper_funcs *hfuncs
+						= encoder->helper_private;
+		hfuncs->dpms(encoder, value);
+	}
+
+set_prop_done:
+	return 0;
+set_prop_error:
+	return -1;
+}
+
+static void baikal_vdu_lvds_encoder_dpms(struct drm_encoder *encoder, int mode)
+{
+	// TBD
+}
+
+const struct drm_connector_funcs connector_funcs = {
+	//.dpms = drm_atomic_helper_connector_dpms, // TODO sort this out
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = baikal_vdu_connector_detect,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+	.set_property = baikal_vdu_lvds_set_property,
+	.destroy = baikal_vdu_connector_destroy,
+	.force = baikal_vdu_connector_force,
+};
+
+const struct drm_connector_helper_funcs connector_helper_funcs = {
+	.get_modes = baikal_vdu_connector_helper_get_modes,
+};
+
+static const struct drm_encoder_funcs encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static const struct drm_encoder_helper_funcs baikal_vdu_lvds_helper_funcs = {
+	.dpms = baikal_vdu_lvds_encoder_dpms,
+	//.prepare = TBD,
+	//.mode_set = TBD,
+	//.commit = TBD,
+};
+
+int baikal_vdu_lvds_connector_create(struct drm_device *dev)
+{
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_connector *connector = &priv->connector;
+	struct drm_encoder *encoder = &priv->encoder;
+
+	drm_connector_init(dev, connector, &connector_funcs,
+			DRM_MODE_CONNECTOR_LVDS);
+	drm_encoder_init(dev, encoder, &encoder_funcs,
+			DRM_MODE_ENCODER_LVDS, NULL);
+	encoder->crtc = &priv->crtc;
+	encoder->possible_crtcs = BIT(drm_crtc_index(encoder->crtc));
+
+	drm_connector_attach_encoder(connector, encoder);
+
+	drm_encoder_helper_add(encoder, &baikal_vdu_lvds_helper_funcs);
+	drm_connector_helper_add(connector, &connector_helper_funcs);
+
+	drm_connector_register(connector);
+
+	drm_panel_attach(priv->panel, connector);
+
+	return 0;
+}
+
+static int baikal_vdu_backlight_update_status(struct backlight_device *bl_dev)
+{
+	struct baikal_vdu_private *priv = bl_get_data(bl_dev);
+	int brightness_on = 1;
+	int brightness = bl_dev->props.brightness;
+	u8 pwmdc;
+
+	if (bl_dev->props.power != FB_BLANK_UNBLANK ||
+	    bl_dev->props.fb_blank != FB_BLANK_UNBLANK ||
+	    bl_dev->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK)) {
+		brightness_on = 0;
+		brightness = priv->min_brightness;
+	}
+
+	if (priv->enable_gpio)
+		gpiod_set_value_cansleep(priv->enable_gpio, brightness_on);
+
+	pwmdc = brightness ? ((brightness << 6) / 25 - 1) : 0;
+
+	writel(pwmdc, priv->regs + PWMDCR);
+
+	return 0;
+}
+
+static const struct backlight_ops baikal_vdu_backlight_ops = {
+	.options        = BL_CORE_SUSPENDRESUME,
+	.update_status	= baikal_vdu_backlight_update_status,
+};
+
+static void baikal_vdu_input_event(struct input_handle *handle,
+				   unsigned int type, unsigned int code,
+				   int value)
+{
+	struct baikal_vdu_private *priv = handle->private;
+	int brightness;
+
+	if (type != EV_KEY || value == 0)
+		return;
+
+	switch (code) {
+	case KEY_BRIGHTNESSDOWN:
+		brightness = priv->bl_dev->props.brightness -
+			     priv->brightness_step;
+		if (brightness >= priv->min_brightness)
+			backlight_device_set_brightness(priv->bl_dev,
+							brightness);
+		break;
+
+	case KEY_BRIGHTNESSUP:
+		brightness = priv->bl_dev->props.brightness +
+			     priv->brightness_step;
+		backlight_device_set_brightness(priv->bl_dev, brightness);
+		break;
+
+	case KEY_BRIGHTNESS_TOGGLE:
+		priv->brightness_on = !priv->brightness_on;
+		if (priv->brightness_on)
+			backlight_enable(priv->bl_dev);
+		else
+			backlight_disable(priv->bl_dev);
+		break;
+
+	default:
+		return;
+	}
+
+	backlight_force_update(priv->bl_dev, BACKLIGHT_UPDATE_HOTKEY);
+}
+
+static int baikal_vdu_input_connect(struct input_handler *handler,
+				    struct input_dev *dev,
+				    const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int ret;
+
+	handle = kzalloc(sizeof(*handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->private = handler->private;
+	handle->name = KBUILD_MODNAME;
+	handle->dev = dev;
+	handle->handler = handler;
+
+	ret = input_register_handle(handle);
+	if (ret)
+		goto err_free_handle;
+
+	ret = input_open_device(handle);
+	if (ret)
+		goto err_unregister_handle;
+
+	return 0;
+
+err_unregister_handle:
+	input_unregister_handle(handle);
+err_free_handle:
+	kfree(handle);
+	return ret;
+}
+
+static void baikal_vdu_input_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id baikal_vdu_input_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
+
+	{ },    /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(input, baikal_vdu_input_ids);
+
+int baikal_vdu_backlight_create(struct drm_device *drm)
+{
+	struct baikal_vdu_private *priv = drm->dev_private;
+	struct device *dev = drm->dev;
+	struct backlight_properties props;
+	struct input_handler *handler;
+	struct device_node *node;
+	u32 min_brightness = BAIKAL_VDU_MIN_BRIGHTNESS;
+	u32 dfl_brightness = BAIKAL_VDU_DEFAULT_BRIGHTNESS;
+	u32 brightness_step = BAIKAL_VDU_BRIGHTNESS_STEP;
+	u32 pwm_frequency = 0;
+	int ret = 0;
+	unsigned long rate;
+	unsigned int pwmfr = 0;
+
+	priv->enable_gpio = devm_gpiod_get_optional(dev, "enable", GPIOD_ASIS);
+	if (IS_ERR(priv->enable_gpio)) {
+		dev_warn(dev, "failed to get ENABLE GPIO\n");
+		priv->enable_gpio = NULL;
+	}
+
+	if (priv->enable_gpio && gpiod_get_direction(priv->enable_gpio) != 0)
+		gpiod_direction_output(priv->enable_gpio, 1);
+
+	node = of_get_child_by_name(dev->of_node, "backlight");
+	if (!node)
+		return 0;
+
+	of_property_read_u32(node, "min-brightness-level", &min_brightness);
+	of_property_read_u32(node, "default-brightness-level", &dfl_brightness);
+	of_property_read_u32(node, "brightness-level-step", &brightness_step);
+	of_property_read_u32(node, "pwm-frequency", &pwm_frequency);
+
+	if (pwm_frequency == 0) {
+		dev_warn(dev, "using default PWM frequency %u\n",
+			 BAIKAL_VDU_DEFAULT_PWM_FREQ);
+		pwm_frequency = BAIKAL_VDU_DEFAULT_PWM_FREQ;
+	}
+
+	memset(&props, 0, sizeof(props));
+	props.max_brightness = 100;
+	props.type = BACKLIGHT_RAW;
+	props.scale = BACKLIGHT_SCALE_LINEAR;
+
+	if (min_brightness > props.max_brightness) {
+		dev_warn(dev, "invalid min brightness level: %u, using %u\n",
+			 min_brightness, props.max_brightness);
+		min_brightness = props.max_brightness;
+	}
+
+	if (dfl_brightness > props.max_brightness ||
+	    dfl_brightness < min_brightness) {
+		dev_warn(dev,
+			 "invalid default brightness level: %u, using %u\n",
+			 dfl_brightness, props.max_brightness);
+		dfl_brightness = props.max_brightness;
+	}
+
+	priv->min_brightness = min_brightness;
+	priv->brightness_step = brightness_step;
+	priv->brightness_on = true;
+
+	props.brightness = dfl_brightness;
+	props.power = FB_BLANK_UNBLANK;
+
+	priv->bl_dev =
+		devm_backlight_device_register(dev, dev_name(dev), dev, priv,
+					       &baikal_vdu_backlight_ops,
+					       &props);
+	if (IS_ERR(priv->bl_dev)) {
+		dev_err(dev, "failed to register backlight device\n");
+		ret = PTR_ERR(priv->bl_dev);
+		priv->bl_dev = NULL;
+		goto out;
+	}
+
+	handler = devm_kzalloc(dev, sizeof(*handler), GFP_KERNEL);
+	if (!handler) {
+		dev_err(dev, "failed to allocate input handler\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	handler->private = priv;
+	handler->event = baikal_vdu_input_event;
+	handler->connect = baikal_vdu_input_connect;
+	handler->disconnect = baikal_vdu_input_disconnect;
+	handler->name = KBUILD_MODNAME;
+	handler->id_table = baikal_vdu_input_ids;
+
+	ret = input_register_handler(handler);
+	if (ret) {
+		dev_err(dev, "failed to register input handler\n");
+		goto out;
+	}
+
+	/* Hold PWM Clock Domain Reset, disable clocking */
+	writel(0, priv->regs + PWMFR);
+
+	rate = clk_get_rate(priv->clk);
+	pwmfr |= PWMFR_PWMFCD(rate / pwm_frequency - 1) | PWMFR_PWMFCI;
+	writel(pwmfr, priv->regs + PWMFR);
+
+	/* Release PWM Clock Domain Reset, enable clocking */
+	writel(pwmfr | PWMFR_PWMPCR | PWMFR_PWMFCE, priv->regs + PWMFR);
+
+	backlight_update_status(priv->bl_dev);
+out:
+	of_node_put(node);
+	return ret;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_crtc.c b/drivers/gpu/drm/baikal/baikal_vdu_crtc.c
new file mode 100644
index 000000000..977cacdce
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_crtc.c
@@ -0,0 +1,377 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms of
+ * such GNU licence.
+ *
+ */
+
+/**
+ * baikal_vdu_crtc.c
+ * Implementation of the CRTC functions for Baikal Electronics BE-M1000 VDU driver
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/version.h>
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_vblank.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+struct baikal_vdu_crtc_mode_fixup {
+	int vdisplay;
+	int vfp_add;
+};
+
+static const struct baikal_vdu_crtc_mode_fixup mode_fixups[] = {
+	{ 480, 38 },
+	{ 600, 8 },
+	{ 720, 43 },
+	{ 768, 43 },
+	{ 800, 71 },
+	{ 864, 71 },
+	{ 900, 71 },
+	{ 960, 71 },
+	{ 1024, 25 },
+	{ 1050, 25 },
+	{ 1080, 8 },
+	{ 1200, 32 },
+	{ 1440, 27 },
+	{ ~0U },
+};
+
+irqreturn_t baikal_vdu_irq(int irq, void *data)
+{
+	struct drm_device *drm = data;
+	struct baikal_vdu_private *priv = drm->dev_private;
+	irqreturn_t status = IRQ_NONE;
+	u32 raw_stat;
+	u32 irq_stat;
+
+	irq_stat = readl(priv->regs + IVR);
+	raw_stat = readl(priv->regs + ISR);
+
+
+	if (irq_stat & INTR_VCT) {
+		priv->counters[10]++;
+		drm_crtc_handle_vblank(&priv->crtc);
+		status = IRQ_HANDLED;
+	}
+
+	if (irq_stat & INTR_FER) {
+		priv->counters[11]++;
+		priv->counters[12] = readl(priv->regs + DBAR);
+		priv->counters[13] = readl(priv->regs + DCAR);
+		priv->counters[14] = readl(priv->regs + MRR);
+		status = IRQ_HANDLED;
+	}
+
+	priv->counters[3] |= raw_stat;
+
+	/* Clear all interrupts */
+	writel(irq_stat, priv->regs + ISR);
+
+	return status;
+}
+
+bool baikal_vdu_crtc_mode_fixup(struct drm_crtc *crtc,
+					const struct drm_display_mode *mode,
+					struct drm_display_mode *adjusted_mode)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	memcpy(adjusted_mode, mode, sizeof(*mode));
+
+	if (!priv->mode_fixup)
+		return true;
+
+	if (priv->mode_fixup == -1) {
+		const struct baikal_vdu_crtc_mode_fixup *fixups = mode_fixups;
+		for (; fixups && fixups->vdisplay != ~0U; ++fixups) {
+			if (mode->vdisplay <= fixups->vdisplay)
+				break;
+		}
+		if (fixups->vdisplay == ~0U)
+			return true;
+		else
+			priv->mode_fixup = fixups->vfp_add;
+	}
+
+	adjusted_mode->vtotal += priv->mode_fixup;
+	adjusted_mode->vsync_start += priv->mode_fixup;
+	adjusted_mode->vsync_end += priv->mode_fixup;
+	adjusted_mode->clock = mode->clock * adjusted_mode->vtotal / mode->vtotal;
+
+	return true;
+}
+
+static void baikal_vdu_crtc_helper_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct drm_device *dev = crtc->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	const struct drm_display_mode *orig_mode = &crtc->state->mode;
+	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	unsigned long rate;
+	unsigned int ppl, hsw, hfp, hbp;
+	unsigned int lpp, vsw, vfp, vbp;
+	unsigned int reg;
+	int ret = 0;
+
+	drm_mode_debug_printmodeline(orig_mode);
+	drm_mode_debug_printmodeline(mode);
+
+	rate = mode->clock * 1000;
+
+	if (rate != clk_get_rate(priv->clk)) {
+		DRM_DEV_DEBUG_DRIVER(dev->dev, "Requested pixel clock is %lu Hz\n", rate);
+
+		/* hold clock domain reset; disable clocking */
+		writel(0, priv->regs + PCTR);
+
+		if (__clk_is_enabled(priv->clk))
+			clk_disable_unprepare(priv->clk);
+		ret = clk_set_rate(priv->clk, rate);
+
+		if (ret >= 0) {
+			clk_prepare_enable(priv->clk);
+			if (!__clk_is_enabled(priv->clk))
+				ret = -1;
+		}
+
+		/* release clock domain reset; enable clocking */
+		reg = readl(priv->regs + PCTR);
+		reg |= PCTR_PCR + PCTR_PCI;
+		writel(reg, priv->regs + PCTR);
+	}
+
+	if (ret < 0)
+		DRM_ERROR("Cannot set desired pixel clock (%lu Hz)\n", rate);
+
+	ppl = mode->hdisplay / 16;
+	if (priv->panel && priv-> ep_count == 2) {
+		hsw = mode->hsync_end - mode->hsync_start;
+		hfp = mode->hsync_start - mode->hdisplay - 1;
+	} else {
+		hsw = mode->hsync_end - mode->hsync_start - 1;
+		hfp = mode->hsync_start - mode->hdisplay;
+	}
+	hbp = mode->htotal - mode->hsync_end;
+
+	lpp = mode->vdisplay;
+	vsw = mode->vsync_end - mode->vsync_start;
+	vfp = mode->vsync_start - mode->vdisplay;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	writel((HTR_HFP(hfp) & HTR_HFP_MASK) |
+			(HTR_PPL(ppl) & HTR_PPL_MASK) |
+			(HTR_HBP(hbp) & HTR_HBP_MASK) |
+			(HTR_HSW(hsw) & HTR_HSW_MASK),
+			priv->regs + HTR);
+
+	if (mode->hdisplay > 4080 || ppl * 16 != mode->hdisplay)
+		writel((HPPLOR_HPPLO(mode->hdisplay) & HPPLOR_HPPLO_MASK) | HPPLOR_HPOE,
+				priv->regs + HPPLOR);
+
+	writel((VTR1_VSW(vsw) & VTR1_VSW_MASK) |
+			(VTR1_VFP(vfp) & VTR1_VFP_MASK) |
+			(VTR1_VBP(vbp) & VTR1_VBP_MASK),
+			priv->regs + VTR1);
+
+	writel(lpp & VTR2_LPP_MASK, priv->regs + VTR2);
+
+	writel((HVTER_VSWE(vsw >> VTR1_VSW_LSB_WIDTH) & HVTER_VSWE_MASK) |
+			(HVTER_HSWE(hsw >> HTR_HSW_LSB_WIDTH) & HVTER_HSWE_MASK) |
+			(HVTER_VBPE(vbp >> VTR1_VBP_LSB_WIDTH) & HVTER_VBPE_MASK) |
+			(HVTER_VFPE(vfp >> VTR1_VFP_LSB_WIDTH) & HVTER_VFPE_MASK) |
+			(HVTER_HBPE(hbp >> HTR_HBP_LSB_WIDTH) & HVTER_HBPE_MASK) |
+			(HVTER_HFPE(hfp >> HTR_HFP_LSB_WIDTH) & HVTER_HFPE_MASK),
+			priv->regs + HVTER);
+
+	/* Set polarities */
+	reg = readl(priv->regs + CR1);
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		reg |= CR1_HSP;
+	else
+		reg &= ~CR1_HSP;
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		reg |= CR1_VSP;
+	else
+		reg &= ~CR1_VSP;
+	reg |= CR1_DEP; // set DE to active high;
+	writel(reg, priv->regs + CR1);
+
+	crtc->hwmode = crtc->state->adjusted_mode;
+}
+
+static enum drm_mode_status baikal_vdu_mode_valid(struct drm_crtc *crtc,
+	                const struct drm_display_mode *mode)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+	if (!priv->mode_override && (mode->hdisplay > 2560 ||
+			mode->vdisplay > 1440))
+		return MODE_BAD;
+	else
+		return MODE_OK;
+}
+
+static void baikal_vdu_crtc_helper_enable(struct drm_crtc *crtc,
+					  struct drm_crtc_state *old_state)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+	struct drm_panel *panel = priv->panel;
+	struct device_node *panel_node;
+	const char *data_mapping;
+	u32 cntl, gpio;
+
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "enabling pixel clock\n");
+	clk_prepare_enable(priv->clk);
+
+	drm_panel_prepare(panel);
+
+	writel(ISCR_VSC_VFP, priv->regs + ISCR);
+
+	/* Set 16-word input FIFO watermark */
+	/* Enable and Power Up */
+	cntl = readl(priv->regs + CR1);
+	cntl &= ~(CR1_FDW_MASK | CR1_OPS_MASK);
+	cntl |= CR1_LCE | CR1_FDW_16_WORDS;
+
+	if (priv->type == VDU_TYPE_LVDS) {
+		panel_node = panel->dev->of_node;
+		if (of_property_read_string(panel_node, "data-mapping", &data_mapping)) {
+			cntl |= CR1_OPS_LCD18;
+		} else if (!strncmp(data_mapping, "vesa-24", 7))
+			cntl |= CR1_OPS_LCD24;
+		else if (!strncmp(data_mapping, "jeida-18", 8))
+			cntl |= CR1_OPS_LCD18;
+		else {
+			dev_warn(crtc->dev->dev, "%s data mapping is not supported, vesa-24 is set\n", data_mapping);
+			cntl |= CR1_OPS_LCD24;
+		}
+		gpio = GPIOR_UHD_ENB;
+		if (priv->ep_count == 4)
+			gpio |= GPIOR_UHD_QUAD_PORT;
+		else if (priv->ep_count == 2)
+			gpio |= GPIOR_UHD_DUAL_PORT;
+		else
+			gpio |= GPIOR_UHD_SNGL_PORT;
+		writel(gpio, priv->regs + GPIOR);
+	} else
+		cntl |= CR1_OPS_LCD24;
+	writel(cntl, priv->regs + CR1);
+
+	drm_panel_enable(priv->panel);
+	drm_crtc_vblank_on(crtc);
+}
+
+void baikal_vdu_crtc_helper_disable(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	drm_panel_disable(priv->panel);
+
+	drm_panel_unprepare(priv->panel);
+	drm_crtc_vblank_off(crtc);
+
+	/* Disable clock */
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "disabling pixel clock\n");
+	clk_disable_unprepare(priv->clk);
+}
+
+static void baikal_vdu_crtc_helper_atomic_flush(struct drm_crtc *crtc,
+					   struct drm_crtc_state *old_state)
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (crtc->state->active && drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+int baikal_vdu_enable_vblank(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	/* clear interrupt status */
+	writel(0x3ffff, priv->regs + ISR);
+
+	writel(INTR_VCT + INTR_FER, priv->regs + IMR);
+
+	return 0;
+}
+
+void baikal_vdu_disable_vblank(struct drm_crtc *crtc)
+{
+	struct baikal_vdu_private *priv = crtc->dev->dev_private;
+
+	/* clear interrupt status */
+	writel(0x3ffff, priv->regs + ISR);
+
+	writel(INTR_FER, priv->regs + IMR);
+}
+
+const struct drm_crtc_funcs crtc_funcs = {
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.reset = drm_atomic_helper_crtc_reset,
+	.destroy = drm_crtc_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+	.enable_vblank = baikal_vdu_enable_vblank,
+	.disable_vblank = baikal_vdu_disable_vblank,
+};
+
+const struct drm_crtc_helper_funcs crtc_helper_funcs = {
+	.mode_fixup = baikal_vdu_crtc_mode_fixup,
+	.mode_set_nofb = baikal_vdu_crtc_helper_mode_set_nofb,
+	.mode_valid = baikal_vdu_mode_valid,
+	.atomic_flush = baikal_vdu_crtc_helper_atomic_flush,
+	.disable = baikal_vdu_crtc_helper_disable,
+	.atomic_enable = baikal_vdu_crtc_helper_enable,
+
+};
+
+int baikal_vdu_crtc_create(struct drm_device *dev)
+{
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_crtc *crtc = &priv->crtc;
+
+	drm_crtc_init_with_planes(dev, crtc,
+				  &priv->primary, NULL,
+				  &crtc_funcs, "primary");
+	drm_crtc_helper_add(crtc, &crtc_helper_funcs);
+
+	/* XXX: The runtime clock disabling still results in
+	 * occasional system hangs, and needs debugging.
+	 */
+
+	DRM_DEV_DEBUG_DRIVER(crtc->dev->dev, "enabling pixel clock\n");
+	clk_prepare_enable(priv->clk);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c b/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
new file mode 100644
index 000000000..31b1a5ba0
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_debugfs.c
@@ -0,0 +1,132 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ *  Copyright  2017 Broadcom
+ */
+
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <drm/drm_debugfs.h>
+#include <drm/drm_device.h>
+#include <drm/drm_file.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define REGDEF(reg) { reg, #reg }
+static const struct {
+	u32 reg;
+	const char *name;
+} baikal_vdu_reg_defs[] = {
+	REGDEF(CR1),
+	REGDEF(HTR),
+	REGDEF(VTR1),
+	REGDEF(VTR2),
+	REGDEF(PCTR),
+	REGDEF(ISR),
+	REGDEF(IMR),
+	REGDEF(IVR),
+	REGDEF(ISCR),
+	REGDEF(DBAR),
+	REGDEF(DCAR),
+	REGDEF(DEAR),
+	REGDEF(PWMFR),
+	REGDEF(PWMDCR),
+	REGDEF(HVTER),
+	REGDEF(HPPLOR),
+	REGDEF(GPIOR),
+	REGDEF(OWER),
+	REGDEF(OWXSER0),
+	REGDEF(OWYSER0),
+	REGDEF(OWDBAR0),
+	REGDEF(OWDCAR0),
+	REGDEF(OWDEAR0),
+	REGDEF(OWXSER1),
+	REGDEF(OWYSER1),
+	REGDEF(OWDBAR1),
+	REGDEF(OWDCAR1),
+	REGDEF(OWDEAR1),
+	REGDEF(MRR),
+};
+
+int baikal_vdu_debugfs_regs(struct seq_file *m, void *unused)
+{
+	struct drm_info_node *node = (struct drm_info_node *)m->private;
+	struct drm_device *dev = node->minor->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(baikal_vdu_reg_defs); i++) {
+		seq_printf(m, "%s (0x%04x): 0x%08x\n",
+			   baikal_vdu_reg_defs[i].name, baikal_vdu_reg_defs[i].reg,
+			   readl(priv->regs + baikal_vdu_reg_defs[i].reg));
+	}
+
+	for (i = 0; i < ARRAY_SIZE(priv->counters); i++) {
+		seq_printf(m, "COUNTER[%d]: 0x%08x\n", i, priv->counters[i]);
+	}
+
+	return 0;
+}
+
+static ssize_t baikal_vdu_rg_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *filename = file->f_path.dentry->d_iname;
+	struct baikal_vdu_private *priv = file->f_inode->i_private;
+	char buf[16];
+	int len = 0;
+
+	if (!strcmp("htr", filename))
+		len = snprintf(buf, sizeof(buf), "%x\n", readl(priv->regs + HTR));
+	else if (!strcmp("vtr", filename))
+		len = snprintf(buf, sizeof(buf), "%x\n", readl(priv->regs + VTR1));
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t baikal_vdu_rg_write(struct file *file,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	struct baikal_vdu_private *priv = file->f_inode->i_private;
+	char *filename = file->f_path.dentry->d_iname;
+	u32 val;
+	int ret;
+
+	ret = kstrtouint_from_user(buf, count, 16, &val);
+	if (ret)
+		return ret;
+
+	if (!strcmp("htr", filename))
+		writel(val, priv->regs + HTR);
+	else if (!strcmp("vtr", filename))
+		writel(val, priv->regs + VTR1);
+
+	return count;
+}
+
+static const struct file_operations baikal_vdu_rg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.write = baikal_vdu_rg_write,
+	.read = baikal_vdu_rg_read,
+};
+
+static const struct drm_info_list baikal_vdu_debugfs_list[] = {
+	{"regs", baikal_vdu_debugfs_regs, 0},
+};
+
+int baikal_vdu_debugfs_init(struct drm_minor *minor)
+{
+	struct drm_device *dev = minor->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	debugfs_create_file("htr", S_IWUSR, minor->debugfs_root, priv, &baikal_vdu_rg_fops);
+	debugfs_create_file("vtr", S_IWUSR, minor->debugfs_root, priv, &baikal_vdu_rg_fops);
+	return drm_debugfs_create_files(baikal_vdu_debugfs_list,
+					ARRAY_SIZE(baikal_vdu_debugfs_list),
+					minor->debugfs_root, minor);
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_drm.h b/drivers/gpu/drm/baikal/baikal_vdu_drm.h
new file mode 100644
index 000000000..24b50f821
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_drm.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#ifndef __BAIKAL_VDU_DRM_H__
+#define __BAIKAL_VDU_DRM_H__
+
+#include <drm/drm_gem.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/backlight.h>
+
+/* Append new drm mode definition here, align with libdrm definition */
+#define DRM_MODE_SCALE_NO_SCALE	2
+
+#define VDU_TYPE_HDMI	0
+#define VDU_TYPE_LVDS	1
+
+#define to_baikal_vdu_private(x) \
+	container_of(x, struct baikal_vdu_private, connector)
+
+struct baikal_vdu_private {
+	struct drm_device *drm;
+	struct drm_crtc crtc;
+	struct drm_connector connector;
+	struct drm_encoder encoder;
+	struct drm_panel *panel;
+	struct drm_bridge *bridge;
+	struct drm_plane primary;
+	void *regs;
+	struct clk *clk;
+	spinlock_t lock;
+	u32 counters[20];
+	int mode_fixup;
+	int mode_override;
+	int type;
+	int ep_count;
+	u32 fb_addr;
+	u32 fb_end;
+	struct delayed_work update_work;
+
+	/* backlight */
+	struct gpio_desc *enable_gpio;
+	struct backlight_device *bl_dev;
+
+	int min_brightness;
+	int brightness_step;
+
+	bool brightness_on;
+};
+
+/* CRTC Functions */
+int baikal_vdu_crtc_create(struct drm_device *dev);
+irqreturn_t baikal_vdu_irq(int irq, void *data);
+
+int baikal_vdu_primary_plane_init(struct drm_device *dev);
+
+/* Connector Functions */
+int baikal_vdu_lvds_connector_create(struct drm_device *dev);
+
+/* Backlight Functions */
+int baikal_vdu_backlight_create(struct drm_device *drm);
+
+/* Debugfs functions */
+int baikal_vdu_debugfs_init(struct drm_minor *minor);
+
+/* Worker functions */
+void baikal_vdu_update_work(struct work_struct *work);
+
+#endif /* __BAIKAL_VDU_DRM_H__ */
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_drv.c b/drivers/gpu/drm/baikal/baikal_vdu_drv.c
new file mode 100644
index 000000000..ee07893c3
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_drv.c
@@ -0,0 +1,396 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ * All bugs by Alexey Sheplyakov <asheplyakov@altlinux.org>
+ *
+ * This driver is based on ARM PL111 DRM driver
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/version.h>
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_connector.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_irq.h>
+#include <drm/drm_of.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define DRIVER_NAME                 "baikal-vdu"
+#define DRIVER_DESC                 "DRM module for Baikal VDU"
+#define DRIVER_DATE                 "20210129"
+
+#define BAIKAL_SMC_SCP_LOG_DISABLE  0x82000200
+
+int mode_fixup = 0;
+int mode_override = 0;
+
+static struct drm_mode_config_funcs mode_config_funcs = {
+	.fb_create = drm_gem_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+const struct drm_encoder_funcs baikal_vdu_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+/* Walks the OF graph to find the endpoint node and then asks DRM
+ * to look up the panel or the bridge connected to the node found
+ */
+int baikal_vdu_find_panel_or_bridge(struct device *dev,
+		struct drm_panel **panel, struct drm_bridge **bridge)
+{
+	struct device_node *endpoint = NULL;
+	struct device_node *remote;
+	struct device_node *old_remote = NULL;
+	struct device_node *np = dev->of_node;
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct baikal_vdu_private *priv = drm->dev_private;
+	int ep_count = 0;
+
+	for_each_endpoint_of_node(np, endpoint) {
+
+		remote = of_graph_get_remote_port_parent(endpoint);
+		if (old_remote && remote != old_remote) {
+			dev_err(dev, "all endpoints must be connected to the same panel or bridge %d\n", ep_count);
+			of_node_put(endpoint);
+			return -EINVAL;
+		}
+
+		/* don't proceed if we have an endpoint but no panel node
+		 * or bridge node tied to it */
+		if (!remote) {
+			dev_err(dev, "no valid remote node connected to the endpoint@%d\n", ep_count);
+			of_node_put(endpoint);
+			return -EINVAL;
+		}
+
+		ep_count++;
+		of_node_put(remote);
+		old_remote = remote;
+	}
+
+	if (!ep_count) {
+		dev_err(dev, "no endpoints found connected either to panel or bridge\n");
+		return -EINVAL;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_err(dev, "not available for remote node\n");
+		return -EINVAL;
+	}
+
+	priv->ep_count = ep_count;
+
+	return drm_of_find_panel_or_bridge(np, 0, 0, panel, bridge);
+
+}
+
+static int baikal_vdu_remove_efifb(struct drm_device *dev)
+{
+	int err;
+	err = drm_fb_helper_remove_conflicting_framebuffers(NULL,
+							    "baikal-vdudrmfb",
+							    false);
+	if (err)
+		dev_warn(dev->dev, "failed to remove firmware framebuffer\n");
+	return err;
+}
+
+static int vdu_modeset_init(struct drm_device *dev)
+{
+	struct drm_mode_config *mode_config;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_encoder *encoder;
+	struct arm_smccc_res res;
+	int ret = 0;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	drm_mode_config_init(dev);
+	mode_config = &dev->mode_config;
+	mode_config->funcs = &mode_config_funcs;
+	mode_config->min_width = 1;
+	mode_config->max_width = 4095;
+	mode_config->min_height = 1;
+	mode_config->max_height = 4095;
+
+	ret = baikal_vdu_primary_plane_init(dev);
+	if (ret != 0) {
+		dev_err(dev->dev, "Failed to init primary plane\n");
+		goto out_config;
+	}
+
+	ret = baikal_vdu_crtc_create(dev);
+	if (ret) {
+		dev_err(dev->dev, "Failed to create crtc\n");
+		goto out_config;
+	}
+
+	ret = baikal_vdu_find_panel_or_bridge(dev->dev, &priv->panel, &priv->bridge);
+	if (ret == -EPROBE_DEFER) {
+		dev_info(dev->dev, "Bridge probe deferred\n");
+		goto out_config;
+	}
+
+	if (priv->bridge) {
+		encoder = &priv->encoder;
+		ret = drm_encoder_init(dev, encoder, &baikal_vdu_encoder_funcs,
+				       DRM_MODE_ENCODER_NONE, NULL);
+		if (ret) {
+			dev_err(dev->dev, "Failed to create DRM encoder\n");
+			goto out_config;
+		}
+		encoder->crtc = &priv->crtc;
+		encoder->possible_crtcs = BIT(drm_crtc_index(encoder->crtc));
+		priv->bridge->encoder = encoder;
+		encoder->bridge = priv->bridge;
+		ret = drm_bridge_attach(encoder, priv->bridge, NULL);
+		if (ret) {
+			dev_err(dev->dev, "Failed to attach DRM bridge %d\n", ret);
+			goto out_config;
+		}
+	} else if (priv->panel) {
+		ret = baikal_vdu_lvds_connector_create(dev);
+		if (ret) {
+			dev_err(dev->dev, "Failed to create DRM connector\n");
+			goto out_config;
+		}
+	} else
+		ret = -EINVAL;
+
+	if (ret) {
+		dev_err(dev->dev, "No bridge or panel attached!\n");
+		goto out_config;
+	}
+
+	priv->clk = clk_get(dev->dev, "pclk");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev->dev, "fatal: unable to get pclk, err %ld\n", PTR_ERR(priv->clk));
+		ret = PTR_ERR(priv->clk);
+		goto out_config;
+	}
+
+	priv->mode_fixup = mode_fixup;
+	priv->mode_override = mode_override;
+
+	baikal_vdu_remove_efifb(dev);
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret != 0) {
+		dev_err(dev->dev, "Failed to init vblank\n");
+		goto out_clk;
+	}
+
+	arm_smccc_smc(BAIKAL_SMC_SCP_LOG_DISABLE, 0, 0, 0, 0, 0, 0, 0, &res);
+	INIT_DEFERRABLE_WORK(&priv->update_work,
+			     baikal_vdu_update_work);
+
+	drm_mode_config_reset(dev);
+
+	drm_kms_helper_poll_init(dev);
+
+	ret = drm_dev_register(dev, 0);
+	if (ret)
+		goto out_clk;
+
+	drm_fbdev_generic_setup(dev, 32);
+	goto finish;
+
+out_clk:
+	clk_put(priv->clk);
+out_config:
+	drm_mode_config_cleanup(dev);
+finish:
+	return ret;
+}
+
+static const struct file_operations drm_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.release = drm_release,
+	.unlocked_ioctl = drm_ioctl,
+	.mmap = drm_gem_cma_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+};
+
+static struct drm_driver vdu_drm_driver = {
+	.driver_features = DRIVER_GEM |	DRIVER_MODESET | DRIVER_ATOMIC,
+	.lastclose = drm_fb_helper_lastclose,
+	.irq_handler = baikal_vdu_irq,
+	.ioctls = NULL,
+	.fops = &drm_fops,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = 1,
+	.minor = 0,
+	.patchlevel = 0,
+	.dumb_create = drm_gem_cma_dumb_create,
+	.dumb_destroy = drm_gem_dumb_destroy,
+	.dumb_map_offset = drm_gem_dumb_map_offset,
+	.gem_free_object_unlocked = drm_gem_cma_free_object,
+	.gem_print_info = drm_gem_cma_print_info,
+	.gem_vm_ops = &drm_gem_cma_vm_ops,
+
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.gem_prime_import = drm_gem_prime_import,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_export = drm_gem_prime_export,
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
+	.gem_prime_mmap = drm_gem_cma_prime_mmap,
+	.gem_prime_vmap = drm_gem_cma_prime_vmap,
+
+#if defined(CONFIG_DEBUG_FS)
+	.debugfs_init = baikal_vdu_debugfs_init,
+#endif
+};
+
+static int baikal_vdu_drm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct baikal_vdu_private *priv;
+	struct drm_device *drm;
+	struct resource *mem;
+	int irq;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->fb_end = 0;
+
+	drm = drm_dev_alloc(&vdu_drm_driver, dev);
+	if (IS_ERR(drm))
+		return PTR_ERR(drm);
+	platform_set_drvdata(pdev, drm);
+	priv->drm = drm;
+	drm->dev_private = priv;
+
+	if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0))) {
+		dev_err(dev, "%s no MMIO resource specified\n", __func__);
+		return -EINVAL;
+	}
+
+	priv->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "%s MMIO allocation failed\n", __func__);
+		return PTR_ERR(priv->regs);
+	}
+
+	/* turn off interrupts before requesting the irq */
+	writel(0, priv->regs + IMR);
+
+	if (!(irq = platform_get_irq(pdev, 0))) {
+		dev_err(dev, "%s no IRQ resource specified\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_init(&priv->lock);
+
+	ret = drm_irq_install(drm, irq);
+	if (ret != 0) {
+		dev_err(dev, "%s IRQ %d allocation failed\n", __func__, irq);
+		return ret;
+	}
+
+	if (pdev->dev.of_node && of_property_read_bool(pdev->dev.of_node, "lvds-out"))
+		priv->type = VDU_TYPE_LVDS;
+	else
+		priv->type = VDU_TYPE_HDMI;
+
+	ret = vdu_modeset_init(drm);
+	if (ret != 0) {
+		dev_err(dev, "Failed to init modeset\n");
+		goto dev_unref;
+	}
+
+	ret = baikal_vdu_backlight_create(drm);
+	if (ret != 0) {
+		dev_err(dev, "Failed to create backlight\n");
+		goto backlight_failed;
+	}
+
+	return 0;
+
+backlight_failed:
+	drm_mode_config_cleanup(drm);
+dev_unref:
+	writel(0, priv->regs + IMR);
+	writel(0x3ffff, priv->regs + ISR);
+	drm_irq_uninstall(drm);
+	drm->dev_private = NULL;
+	drm_dev_put(drm);
+	return ret;
+}
+
+static int baikal_vdu_drm_remove(struct platform_device *pdev)
+{
+	struct drm_device *drm = platform_get_drvdata(pdev);
+
+	drm_dev_unregister(drm);
+	drm_mode_config_cleanup(drm);
+	drm_irq_uninstall(drm);
+	drm->dev_private = NULL;
+	drm_dev_put(drm);
+
+	return 0;
+}
+
+static const struct of_device_id baikal_vdu_of_match[] = {
+	{ .compatible = "baikal,vdu" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, baikal_vdu_of_match);
+
+static struct platform_driver baikal_vdu_platform_driver = {
+	.probe  = baikal_vdu_drm_probe,
+	.remove = baikal_vdu_drm_remove,
+	.driver = {
+		.name   = DRIVER_NAME,
+		.of_match_table = baikal_vdu_of_match,
+	},
+};
+
+module_param(mode_fixup, int, 0644);
+module_param(mode_override, int, 0644);
+
+module_platform_driver(baikal_vdu_platform_driver);
+
+MODULE_AUTHOR("Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal Electronics BE-M1000 Video Display Unit (VDU) DRM Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_SOFTDEP("pre: baikal_hdmi");
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_plane.c b/drivers/gpu/drm/baikal/baikal_vdu_plane.c
new file mode 100644
index 000000000..266173868
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_plane.c
@@ -0,0 +1,193 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (c) 2006-2008 Intel Corporation
+ * Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
+ * Copyright (C) 2011 Texas Instruments
+ * (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_graph.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "baikal_vdu_drm.h"
+#include "baikal_vdu_regs.h"
+
+#define BAIKAL_SMC_VDU_UPDATE	0x82000100
+
+void baikal_vdu_update_work(struct work_struct *work)
+{
+	struct arm_smccc_res res;
+	unsigned long flags;
+	struct baikal_vdu_private *priv = container_of(work, struct baikal_vdu_private,
+			update_work.work);
+	int count = 0;
+	u64 t1, t2;
+	t1 = read_sysreg(CNTVCT_EL0);
+	spin_lock_irqsave(&priv->lock, flags);
+	arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, priv->fb_addr, priv->fb_end, 0, 0, 0, 0, 0, &res);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	if (res.a0 == -EBUSY)
+		priv->counters[15]++;
+	else
+		priv->counters[16]++;
+	while (res.a0 == -EBUSY && count < 10) {
+		count++;
+		usleep_range(10000, 20000);
+		res.a0 = 0;
+		spin_lock_irqsave(&priv->lock, flags);
+		arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, priv->fb_addr, priv->fb_end, 0, 0, 0, 0, 0, &res);
+		spin_unlock_irqrestore(&priv->lock, flags);
+		if (res.a0 == -EBUSY)
+			priv->counters[15]++;
+		else
+			priv->counters[16]++;
+	}
+	t2 = read_sysreg(CNTVCT_EL0);
+	priv->counters[17] = t2 - t1;
+	priv->counters[18] = count;
+	priv->counters[19]++;
+}
+
+static void baikal_vdu_primary_plane_atomic_update(struct drm_plane *plane,
+					      struct drm_plane_state *old_state)
+{
+	struct drm_device *dev = plane->dev;
+	struct baikal_vdu_private *priv = dev->dev_private;
+	struct drm_plane_state *state = plane->state;
+	struct drm_framebuffer *fb = state->fb;
+	struct arm_smccc_res res;
+	uint32_t cntl;
+	uint32_t addr;
+	uint32_t end;
+	unsigned long flags;
+
+	if (!fb)
+		return;
+
+	addr = drm_fb_cma_get_gem_addr(fb, state, 0);
+	end = ((addr + fb->height * fb->pitches[0] - 1) & MRR_DEAR_MRR_MASK) | MRR_OUTSTND_RQ(4);
+	if (priv->panel)
+		addr |= 1;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	arm_smccc_smc(BAIKAL_SMC_VDU_UPDATE, addr, end, 0, 0, 0, 0, 0, &res);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (res.a0 == -EBUSY) {
+		priv->counters[15]++;
+		priv->fb_addr = addr;
+		priv->fb_end = end;
+		smp_wmb();
+		schedule_delayed_work(&priv->update_work, usecs_to_jiffies(250));
+	} else
+		priv->counters[16]++;
+
+	cntl = readl(priv->regs + CR1);
+	cntl &= ~CR1_BPP_MASK;
+
+	/* Note that the the hardware's format reader takes 'r' from
+	 * the low bit, while DRM formats list channels from high bit
+	 * to low bit as you read left to right.
+	 */
+	switch (fb->format->format) {
+	case DRM_FORMAT_BGR888:
+		cntl |= CR1_BPP24 | CR1_FBP | CR1_BGR;
+		break;
+	case DRM_FORMAT_RGB888:
+		cntl |= CR1_BPP24 | CR1_FBP;
+		break;
+	case DRM_FORMAT_ABGR8888:
+	case DRM_FORMAT_XBGR8888:
+		cntl |= CR1_BPP24 | CR1_BGR;
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XRGB8888:
+		cntl |= CR1_BPP24;
+		break;
+	case DRM_FORMAT_BGR565:
+		cntl |= CR1_BPP16_565 | CR1_BGR;
+		break;
+	case DRM_FORMAT_RGB565:
+		cntl |= CR1_BPP16_565;
+		break;
+	case DRM_FORMAT_ABGR1555:
+	case DRM_FORMAT_XBGR1555:
+		cntl |= CR1_BPP16_555 | CR1_BGR;
+		break;
+	case DRM_FORMAT_ARGB1555:
+	case DRM_FORMAT_XRGB1555:
+		cntl |= CR1_BPP16_555;
+		break;
+	default:
+		WARN_ONCE(true, "Unknown FB format 0x%08x, set XRGB8888 instead\n",
+				fb->format->format);
+		cntl |= CR1_BPP24;
+		break;
+	}
+
+	writel(cntl, priv->regs + CR1);
+}
+
+static const struct drm_plane_helper_funcs baikal_vdu_primary_plane_helper_funcs = {
+	.atomic_update = baikal_vdu_primary_plane_atomic_update,
+	.prepare_fb = drm_gem_fb_prepare_fb,
+};
+
+static const struct drm_plane_funcs baikal_vdu_primary_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.reset = drm_atomic_helper_plane_reset,
+	.destroy = drm_plane_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+int baikal_vdu_primary_plane_init(struct drm_device *drm)
+{
+	struct baikal_vdu_private *priv = drm->dev_private;
+	struct drm_plane *plane = &priv->primary;
+	static const u32 formats[] = {
+		DRM_FORMAT_BGR888,
+		DRM_FORMAT_RGB888,
+		DRM_FORMAT_ABGR8888,
+		DRM_FORMAT_XBGR8888,
+		DRM_FORMAT_ARGB8888,
+		DRM_FORMAT_XRGB8888,
+		DRM_FORMAT_BGR565,
+		DRM_FORMAT_RGB565,
+		DRM_FORMAT_ABGR1555,
+		DRM_FORMAT_XBGR1555,
+		DRM_FORMAT_ARGB1555,
+		DRM_FORMAT_XRGB1555,
+	};
+	int ret;
+
+	ret = drm_universal_plane_init(drm, plane, 0,
+				       &baikal_vdu_primary_plane_funcs,
+				       formats,
+				       ARRAY_SIZE(formats),
+				       NULL,
+				       DRM_PLANE_TYPE_PRIMARY,
+				       NULL);
+	if (ret)
+		return ret;
+
+	drm_plane_helper_add(plane, &baikal_vdu_primary_plane_helper_funcs);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/baikal/baikal_vdu_regs.h b/drivers/gpu/drm/baikal/baikal_vdu_regs.h
new file mode 100644
index 000000000..c28dbf090
--- /dev/null
+++ b/drivers/gpu/drm/baikal/baikal_vdu_regs.h
@@ -0,0 +1,148 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019-2021 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ *   David A Rusling
+ *   Copyright (C) 2001 ARM Limited
+ */
+
+#ifndef __BAIKAL_VDU_REGS_H__
+#define __BAIKAL_VDU_REGS_H__
+
+#define CR1         0x000
+#define HTR         0x008
+#define VTR1        0x00C
+#define VTR2        0x010
+#define PCTR        0x014
+#define ISR         0x018
+#define IMR         0x01C
+#define IVR         0x020
+#define ISCR        0x024
+#define DBAR        0x028
+#define DCAR        0x02C
+#define DEAR        0x030
+#define PWMFR       0x034
+#define PWMDCR      0x038
+#define HVTER       0x044
+#define HPPLOR      0x048
+#define GPIOR       0x1F8
+#define OWER        0x600
+#define OWXSER0     0x604
+#define OWYSER0     0x608
+#define OWDBAR0     0x60C
+#define OWDCAR0     0x610
+#define OWDEAR0     0x614
+#define OWXSER1     0x618
+#define OWYSER1     0x61C
+#define OWDBAR1     0x620
+#define OWDCAR1     0x624
+#define OWDEAR1     0x628
+#define MRR         0xFFC
+
+#define INTR_BAU    BIT(7)
+#define INTR_VCT    BIT(6)
+#define INTR_MBE    BIT(5)
+#define INTR_FER    BIT(4)
+
+#define CR1_FBP             BIT(19)
+#define CR1_FDW_MASK        GENMASK(17, 16)
+#define CR1_FDW_4_WORDS     (0 << 16)
+#define CR1_FDW_8_WORDS     (1 << 16)
+#define CR1_FDW_16_WORDS    (2 << 16)
+#define CR1_OPS_MASK        GENMASK(14, 12)
+#define CR1_OPS_LCD18       (0 << 13)
+#define CR1_OPS_LCD24       (1 << 13)
+#define CR1_OPS_565         (0 << 12)
+#define CR1_OPS_555         (1 << 12)
+#define CR1_VSP             BIT(11)
+#define CR1_HSP             BIT(10)
+#define CR1_DEP             BIT(8)
+#define CR1_BGR             BIT(5)
+#define CR1_BPP_MASK        GENMASK(4, 2)
+#define CR1_BPP1            (0 << 2)
+#define CR1_BPP2            (1 << 2)
+#define CR1_BPP4            (2 << 2)
+#define CR1_BPP8            (3 << 2)
+#define CR1_BPP16           (4 << 2)
+#define CR1_BPP18           (5 << 2)
+#define CR1_BPP24           (6 << 2)
+#define CR1_LCE             BIT(0)
+
+#define CR1_BPP16_555 ((CR1_BPP16) | (CR1_OPS_555))
+#define CR1_BPP16_565 ((CR1_BPP16) | (CR1_OPS_565))
+
+#define VTR1_VBP_MASK       GENMASK(23, 16)
+#define VTR1_VBP(x)         ((x) << 16)
+#define VTR1_VBP_LSB_WIDTH  8
+#define VTR1_VFP_MASK       GENMASK(15, 8)
+#define VTR1_VFP(x)         ((x) << 8)
+#define VTR1_VFP_LSB_WIDTH  8
+#define VTR1_VSW_MASK       GENMASK(7, 0)
+#define VTR1_VSW(x)         ((x) << 0)
+#define VTR1_VSW_LSB_WIDTH  8
+
+#define VTR2_LPP_MASK       GENMASK(11, 0)
+
+#define HTR_HSW_MASK        GENMASK(31, 24)
+#define HTR_HSW(x)          ((x) << 24)
+#define HTR_HSW_LSB_WIDTH   8
+#define HTR_HBP_MASK        GENMASK(23, 16)
+#define HTR_HBP(x)          ((x) << 16)
+#define HTR_HBP_LSB_WIDTH   8
+#define HTR_PPL_MASK        GENMASK(15, 8)
+#define HTR_PPL(x)          ((x) << 8)
+#define HTR_HFP_MASK        GENMASK(7, 0)
+#define HTR_HFP(x)          ((x) << 0)
+#define HTR_HFP_LSB_WIDTH   8
+
+#define PCTR_PCI2           BIT(11)
+#define PCTR_PCR            BIT(10)
+#define PCTR_PCI            BIT(9)
+#define PCTR_PCB            BIT(8)
+#define PCTR_PCD_MASK       GENMASK(7, 0)
+#define PCTR_MAX_PCD        128
+
+#define ISCR_VSC_OFF        0x0
+#define ISCR_VSC_VSW        0x4
+#define ISCR_VSC_VBP        0x5
+#define ISCR_VSC_VACTIVE    0x6
+#define ISCR_VSC_VFP        0x7
+
+#define PWMFR_PWMPCR        BIT(24)
+#define PWMFR_PWMFCI        BIT(23)
+#define PWMFR_PWMFCE        BIT(22)
+#define PWMFR_PWMFCD_MASK   GENMASK(21, 0)
+#define PWMFR_PWMFCD(x)     ((x) << 0)
+
+#define HVTER_VSWE_MASK     GENMASK(25, 24)
+#define HVTER_VSWE(x)       ((x) << 24)
+#define HVTER_HSWE_MASK     GENMASK(17, 16)
+#define HVTER_HSWE(x)       ((x) << 16)
+#define HVTER_VBPE_MASK     GENMASK(13, 12)
+#define HVTER_VBPE(x)       ((x) << 12)
+#define HVTER_VFPE_MASK     GENMASK(9, 8)
+#define HVTER_VFPE(x)       ((x) << 8)
+#define HVTER_HBPE_MASK     GENMASK(5, 4)
+#define HVTER_HBPE(x)       ((x) << 4)
+#define HVTER_HFPE_MASK     GENMASK(1, 0)
+#define HVTER_HFPE(x)       ((x) << 0)
+
+#define HPPLOR_HPOE         BIT(31)
+#define HPPLOR_HPPLO_MASK   GENMASK(11, 0)
+#define HPPLOR_HPPLO(x)     ((x) << 0)
+
+#define GPIOR_UHD_MASK      GENMASK(23, 16)
+#define GPIOR_UHD_SNGL_PORT (0 << 18)
+#define GPIOR_UHD_DUAL_PORT (1 << 18)
+#define GPIOR_UHD_QUAD_PORT (2 << 18)
+#define GPIOR_UHD_ENB       BIT(17)
+
+#define MRR_DEAR_MRR_MASK   GENMASK(31, 3)
+#define MRR_OUTSTND_RQ_MASK GENMASK(2, 0)
+#define MRR_OUTSTND_RQ(x)   ((x >> 1) << 0)
+
+#endif /* __BAIKAL_VDU_REGS_H__ */
diff --git a/drivers/gpu/drm/bridge/synopsys/Kconfig b/drivers/gpu/drm/bridge/synopsys/Kconfig
index 21a1be3ce..06814ba3f 100644
--- a/drivers/gpu/drm/bridge/synopsys/Kconfig
+++ b/drivers/gpu/drm/bridge/synopsys/Kconfig
@@ -39,3 +39,20 @@ config DRM_DW_MIPI_DSI
 	select DRM_KMS_HELPER
 	select DRM_MIPI_DSI
 	select DRM_PANEL_BRIDGE
+
+config DRM_BAIKAL_HDMI
+	tristate "Baikal-M HDMI transmitter"
+	select DRM_DW_HDMI
+	help
+	  Choose this if you want to use HDMI on Baikal-M.
+
+config DRM_BAIKAL_HDMI_AHB_AUDIO
+	tristate "Baikal-M HDMI Audio interface"
+	depends on DRM_BAIKAL_HDMI && SND
+	select SND_PCM
+	select SND_PCM_ELD
+	select SND_PCM_IEC958
+	help
+	  Support the AHB Audio interface which is part of the
+	  Baikal-M HDMI Tx block.
+
diff --git a/drivers/gpu/drm/bridge/synopsys/Makefile b/drivers/gpu/drm/bridge/synopsys/Makefile
index 91d746ad5..64e6637d1 100644
--- a/drivers/gpu/drm/bridge/synopsys/Makefile
+++ b/drivers/gpu/drm/bridge/synopsys/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_DRM_DW_HDMI) += dw-hdmi.o
 obj-$(CONFIG_DRM_DW_HDMI_AHB_AUDIO) += dw-hdmi-ahb-audio.o
+obj-$(CONFIG_DRM_BAIKAL_HDMI_AHB_AUDIO) += baikal-hdmi-ahb-audio.o
 obj-$(CONFIG_DRM_DW_HDMI_I2S_AUDIO) += dw-hdmi-i2s-audio.o
 obj-$(CONFIG_DRM_DW_HDMI_CEC) += dw-hdmi-cec.o
 
diff --git a/drivers/gpu/drm/bridge/synopsys/baikal-hdmi-ahb-audio.c b/drivers/gpu/drm/bridge/synopsys/baikal-hdmi-ahb-audio.c
new file mode 100644
index 000000000..631f63123
--- /dev/null
+++ b/drivers/gpu/drm/bridge/synopsys/baikal-hdmi-ahb-audio.c
@@ -0,0 +1,686 @@
+/*
+ * Baikal Electronics BE-M1000 DesignWare HDMI AHB audio driver
+ *
+ * Copyright (C) 2020 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * DesignWare HDMI audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Written and tested against the Designware HDMI Tx found in iMX6.
+ */
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <drm/bridge/dw_hdmi.h>
+#include <drm/drm_edid.h>
+
+#include <sound/asoundef.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_drm_eld.h>
+#include <sound/pcm_iec958.h>
+
+#include "dw-hdmi-audio.h"
+
+#define DRIVER_NAME "dw-hdmi-ahb-audio"
+
+#define BAIKAL_HDMI_REG_SHIFT  2
+
+/* Provide some bits rather than bit offsets */
+enum {
+	HDMI_AHB_DMA_CONF0_SW_FIFO_RST = BIT(7),
+	HDMI_AHB_DMA_CONF0_EN_HLOCK = BIT(3),
+	HDMI_AHB_DMA_START_START = BIT(0),
+	HDMI_AHB_DMA_STOP_STOP = BIT(0),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_OVERRUN = BIT(6),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = BIT(5),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = BIT(4),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = BIT(3),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = BIT(2),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = BIT(1),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = BIT(0),
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL =
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_OVERRUN |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL |
+		HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY,
+	HDMI_IH_AHBDMAAUD_STAT0_OVERRUN = BIT(6),
+	HDMI_IH_AHBDMAAUD_STAT0_ERROR = BIT(5),
+	HDMI_IH_AHBDMAAUD_STAT0_LOST = BIT(4),
+	HDMI_IH_AHBDMAAUD_STAT0_RETRY = BIT(3),
+	HDMI_IH_AHBDMAAUD_STAT0_DONE = BIT(2),
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = BIT(1),
+	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = BIT(0),
+	HDMI_IH_AHBDMAAUD_STAT0_ALL =
+		HDMI_IH_AHBDMAAUD_STAT0_OVERRUN |
+		HDMI_IH_AHBDMAAUD_STAT0_ERROR |
+		HDMI_IH_AHBDMAAUD_STAT0_LOST |
+		HDMI_IH_AHBDMAAUD_STAT0_RETRY |
+		HDMI_IH_AHBDMAAUD_STAT0_DONE |
+		HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL |
+		HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY,
+	HDMI_AHB_DMA_CONF0_INCR16 = 2 << 1,
+	HDMI_AHB_DMA_CONF0_INCR8 = 1 << 1,
+	HDMI_AHB_DMA_CONF0_INCR4 = 0,
+	HDMI_AHB_DMA_CONF0_BURST_MODE = BIT(0),
+	HDMI_AHB_DMA_MASK_DONE = BIT(7),
+
+	HDMI_REVISION_ID = 0x0001,
+	HDMI_IH_AHBDMAAUD_STAT0 = 0x0109,
+	HDMI_IH_MUTE_AHBDMAAUD_STAT0 = 0x0189,
+	HDMI_FC_AUDICONF2 = 0x1027,
+	HDMI_FC_AUDSCONF = 0x1063,
+	HDMI_FC_AUDSCONF_LAYOUT1 = 1 << 0,
+	HDMI_FC_AUDSCONF_LAYOUT0 = 0 << 0,
+	HDMI_AHB_DMA_CONF0 = 0x3600,
+	HDMI_AHB_DMA_START = 0x3601,
+	HDMI_AHB_DMA_STOP = 0x3602,
+	HDMI_AHB_DMA_THRSLD = 0x3603,
+	HDMI_AHB_DMA_STRADDR0 = 0x3604,
+	HDMI_AHB_DMA_STPADDR0 = 0x3608,
+	HDMI_AHB_DMA_MASK = 0x3614,
+	HDMI_AHB_DMA_POL = 0x3615,
+	HDMI_AHB_DMA_CONF1 = 0x3616,
+	HDMI_AHB_DMA_BUFFPOL = 0x361a,
+};
+
+struct dw_hdmi_channel_conf {
+	u8 conf1;
+	u8 ca;
+};
+
+/*
+ * The default mapping of ALSA channels to HDMI channels and speaker
+ * allocation bits.  Note that we can't do channel remapping here -
+ * channels must be in the same order.
+ *
+ * Mappings for alsa-lib pcm/surround*.conf files:
+ *
+ *		Front	Sur4.0	Sur4.1	Sur5.0	Sur5.1	Sur7.1
+ * Channels	2	4	6	6	6	8
+ *
+ * Our mapping from ALSA channel to CEA686D speaker name and HDMI channel:
+ *
+ *				Number of ALSA channels
+ * ALSA Channel	2	3	4	5	6	7	8
+ * 0		FL:0	=	=	=	=	=	=
+ * 1		FR:1	=	=	=	=	=	=
+ * 2			FC:3	RL:4	LFE:2	=	=	=
+ * 3				RR:5	RL:4	FC:3	=	=
+ * 4					RR:5	RL:4	=	=
+ * 5						RR:5	=	=
+ * 6							RC:6	=
+ * 7							RLC/FRC	RLC/FRC
+ */
+static struct dw_hdmi_channel_conf default_hdmi_channel_config[7] = {
+	{ 0x03, 0x00 },	/* FL,FR */
+	{ 0x0b, 0x02 },	/* FL,FR,FC */
+	{ 0x33, 0x08 },	/* FL,FR,RL,RR */
+	{ 0x37, 0x09 },	/* FL,FR,LFE,RL,RR */
+	{ 0x3f, 0x0b },	/* FL,FR,LFE,FC,RL,RR */
+	{ 0x7f, 0x0f },	/* FL,FR,LFE,FC,RL,RR,RC */
+	{ 0xff, 0x13 },	/* FL,FR,LFE,FC,RL,RR,[FR]RC,[FR]LC */
+};
+
+struct snd_dw_hdmi {
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	spinlock_t lock;
+	struct dw_hdmi_audio_data data;
+	struct snd_pcm_substream *substream;
+	void (*reformat)(struct snd_dw_hdmi *, size_t, size_t);
+	void *buf_src;
+	void *buf_dst;
+	dma_addr_t buf_addr;
+	unsigned buf_offset;
+	unsigned buf_period;
+	unsigned buf_size;
+	unsigned channels;
+	u8 revision;
+	u8 iec_offset;
+	u8 cs[192][8];
+};
+
+static inline void baikal_hdmi_writeb(u8 val, void __iomem *base, uint offset)
+{
+	writeb(val, base + (offset << BAIKAL_HDMI_REG_SHIFT));
+}
+
+static inline void baikal_hdmi_writeb_relaxed(u8 val, void __iomem *base, uint offset)
+{
+	writeb_relaxed(val, base + (offset << BAIKAL_HDMI_REG_SHIFT));
+}
+
+static inline u8 baikal_hdmi_readb_relaxed(void __iomem *base, uint offset)
+{
+	return readb_relaxed(base + (offset << BAIKAL_HDMI_REG_SHIFT));
+}
+
+static void baikal_hdmi_writel(u32 val, void __iomem *base, uint offset)
+{
+	writeb_relaxed(val, base + (offset << BAIKAL_HDMI_REG_SHIFT));
+	writeb_relaxed(val >> 8, base + ((offset + 1) << BAIKAL_HDMI_REG_SHIFT));
+	writeb_relaxed(val >> 16, base + ((offset + 2) << BAIKAL_HDMI_REG_SHIFT));
+	writeb_relaxed(val >> 24, base + ((offset + 3) << BAIKAL_HDMI_REG_SHIFT));
+}
+
+/*
+ * Convert to hardware format: The userspace buffer contains IEC958 samples,
+ * with the PCUV bits in bits 31..28 and audio samples in bits 27..4.  We
+ * need these to be in bits 27..24, with the IEC B bit in bit 28, and audio
+ * samples in 23..0.
+ *
+ * Default preamble in bits 3..0: 8 = block start, 4 = even 2 = odd
+ *
+ * Ideally, we could do with having the data properly formatted in userspace.
+ */
+static void dw_hdmi_reformat_iec958(struct snd_dw_hdmi *dw,
+	size_t offset, size_t bytes)
+{
+	u32 *src = dw->buf_src + offset;
+	u32 *dst = dw->buf_dst + offset;
+	u32 *end = dw->buf_src + offset + bytes;
+
+	do {
+		u32 b, sample = *src++;
+
+		b = (sample & 8) << (28 - 3);
+
+		sample >>= 4;
+
+		*dst++ = sample | b;
+	} while (src < end);
+}
+
+static u32 parity(u32 sample)
+{
+	sample ^= sample >> 16;
+	sample ^= sample >> 8;
+	sample ^= sample >> 4;
+	sample ^= sample >> 2;
+	sample ^= sample >> 1;
+	return (sample & 1) << 27;
+}
+
+static void dw_hdmi_reformat_s24(struct snd_dw_hdmi *dw,
+	size_t offset, size_t bytes)
+{
+	u32 *src = dw->buf_src + offset;
+	u32 *dst = dw->buf_dst + offset;
+	u32 *end = dw->buf_src + offset + bytes;
+
+	do {
+		unsigned i;
+		u8 *cs;
+
+		cs = dw->cs[dw->iec_offset++];
+		if (dw->iec_offset >= 192)
+			dw->iec_offset = 0;
+
+		i = dw->channels;
+		do {
+			u32 sample = *src++;
+
+			sample &= ~0xff000000;
+			sample |= *cs++ << 24;
+			sample |= parity(sample & ~0xf8000000);
+
+			*dst++ = sample;
+		} while (--i);
+	} while (src < end);
+}
+
+static void dw_hdmi_create_cs(struct snd_dw_hdmi *dw,
+	struct snd_pcm_runtime *runtime)
+{
+	u8 cs[4];
+	unsigned ch, i, j;
+
+	snd_pcm_create_iec958_consumer(runtime, cs, sizeof(cs));
+
+	memset(dw->cs, 0, sizeof(dw->cs));
+
+	for (ch = 0; ch < 8; ch++) {
+		cs[2] &= ~IEC958_AES2_CON_CHANNEL;
+		cs[2] |= (ch + 1) << 4;
+
+		for (i = 0; i < ARRAY_SIZE(cs); i++) {
+			unsigned c = cs[i];
+
+			for (j = 0; j < 8; j++, c >>= 1)
+				dw->cs[i * 8 + j][ch] = (c & 1) << 2;
+		}
+	}
+	dw->cs[0][0] |= BIT(4);
+}
+
+static void dw_hdmi_start_dma(struct snd_dw_hdmi *dw)
+{
+	void __iomem *base = dw->data.base;
+	unsigned offset = dw->buf_offset;
+	unsigned period = dw->buf_period;
+	u32 start, stop;
+
+	dw->reformat(dw, offset, period);
+
+	/* Clear all irqs before enabling irqs and starting DMA */
+	baikal_hdmi_writeb_relaxed(HDMI_IH_AHBDMAAUD_STAT0_ALL,
+		       base, HDMI_IH_AHBDMAAUD_STAT0);
+
+	start = dw->buf_addr + offset;
+	stop = start + period - 1;
+
+	/* Setup the hardware start/stop addresses */
+	baikal_hdmi_writel(start, base, HDMI_AHB_DMA_STRADDR0);
+	baikal_hdmi_writel(stop, base, HDMI_AHB_DMA_STPADDR0);
+
+	baikal_hdmi_writeb_relaxed((u8)~HDMI_AHB_DMA_MASK_DONE, base, HDMI_AHB_DMA_MASK);
+	baikal_hdmi_writeb(HDMI_AHB_DMA_START_START, base, HDMI_AHB_DMA_START);
+
+	offset += period;
+	if (offset >= dw->buf_size)
+		offset = 0;
+	dw->buf_offset = offset;
+}
+
+static void dw_hdmi_stop_dma(struct snd_dw_hdmi *dw)
+{
+	/* Disable interrupts before disabling DMA */
+	baikal_hdmi_writeb_relaxed(~0, dw->data.base, HDMI_AHB_DMA_MASK);
+	baikal_hdmi_writeb_relaxed(HDMI_AHB_DMA_STOP_STOP, dw->data.base, HDMI_AHB_DMA_STOP);
+}
+
+static irqreturn_t snd_dw_hdmi_irq(int irq, void *data)
+{
+	struct snd_dw_hdmi *dw = data;
+	struct snd_pcm_substream *substream;
+	unsigned stat;
+
+	stat = baikal_hdmi_readb_relaxed(dw->data.base, HDMI_IH_AHBDMAAUD_STAT0);
+	if (!stat)
+		return IRQ_NONE;
+
+	baikal_hdmi_writeb_relaxed(stat, dw->data.base, HDMI_IH_AHBDMAAUD_STAT0);
+
+	substream = dw->substream;
+	if (stat & HDMI_IH_AHBDMAAUD_STAT0_DONE && substream) {
+		snd_pcm_period_elapsed(substream);
+
+		spin_lock(&dw->lock);
+		if (dw->substream)
+			dw_hdmi_start_dma(dw);
+		spin_unlock(&dw->lock);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct snd_pcm_hardware dw_hdmi_hw = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID,
+	.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |
+		   SNDRV_PCM_FMTBIT_S24_LE,
+	.rates = SNDRV_PCM_RATE_32000 |
+		 SNDRV_PCM_RATE_44100 |
+		 SNDRV_PCM_RATE_48000 |
+		 SNDRV_PCM_RATE_88200 |
+		 SNDRV_PCM_RATE_96000 |
+		 SNDRV_PCM_RATE_176400 |
+		 SNDRV_PCM_RATE_192000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.buffer_bytes_max = 1024 * 1024,
+	.period_bytes_min = 256,
+	.period_bytes_max = 8192,	/* ERR004323: must limit to 8k */
+	.periods_min = 2,
+	.periods_max = 16,
+	.fifo_size = 0,
+};
+
+static int dw_hdmi_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dw_hdmi *dw = substream->private_data;
+	void __iomem *base = dw->data.base;
+	int ret;
+
+	runtime->hw = dw_hdmi_hw;
+
+	ret = snd_pcm_hw_constraint_eld(runtime, dw->data.eld);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_pcm_limit_hw_rates(runtime);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	/* Limit the buffer size to the size of the preallocated buffer */
+	ret = snd_pcm_hw_constraint_minmax(runtime,
+					   SNDRV_PCM_HW_PARAM_BUFFER_SIZE,
+					   0, substream->dma_buffer.bytes);
+	if (ret < 0)
+		return ret;
+
+	/* Clear FIFO */
+	baikal_hdmi_writeb_relaxed(HDMI_AHB_DMA_CONF0_SW_FIFO_RST,
+		       base, HDMI_AHB_DMA_CONF0);
+
+	/* Configure interrupt polarities */
+	baikal_hdmi_writeb_relaxed(~0, base, HDMI_AHB_DMA_POL);
+	baikal_hdmi_writeb_relaxed(~0, base, HDMI_AHB_DMA_BUFFPOL);
+
+	/* Keep interrupts masked, and clear any pending */
+	baikal_hdmi_writeb_relaxed(~0, base, HDMI_AHB_DMA_MASK);
+	baikal_hdmi_writeb_relaxed(~0, base, HDMI_IH_AHBDMAAUD_STAT0);
+
+	ret = request_irq(dw->data.irq, snd_dw_hdmi_irq, IRQF_SHARED,
+			  "dw-hdmi-audio", dw);
+	if (ret)
+		return ret;
+
+	/* Un-mute done interrupt */
+	baikal_hdmi_writeb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL &
+		       ~HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE,
+		       base, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+
+	return 0;
+}
+
+static int dw_hdmi_close(struct snd_pcm_substream *substream)
+{
+	struct snd_dw_hdmi *dw = substream->private_data;
+
+	/* Mute all interrupts */
+	baikal_hdmi_writeb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,
+		       dw->data.base, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+
+	free_irq(dw->data.irq, dw);
+
+	return 0;
+}
+
+static int dw_hdmi_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_vmalloc_buffer(substream);
+}
+
+static int dw_hdmi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	/* Allocate the PCM runtime buffer, which is exposed to userspace. */
+	return snd_pcm_lib_alloc_vmalloc_buffer(substream,
+						params_buffer_bytes(params));
+}
+
+static int dw_hdmi_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dw_hdmi *dw = substream->private_data;
+	u8 threshold, conf0, conf1, layout, ca;
+
+	/* Setup as per 3.0.5 FSL 4.1.0 BSP */
+	switch (dw->revision) {
+	case 0x0a:
+		conf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |
+			HDMI_AHB_DMA_CONF0_INCR4;
+		if (runtime->channels == 2)
+			threshold = 126;
+		else
+			threshold = 124;
+		break;
+	case 0x1a:
+		conf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |
+			HDMI_AHB_DMA_CONF0_INCR8;
+		threshold = 128;
+		break;
+	case 0x2a: /* this revision is used in Baikal-M SoC */
+		conf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |
+			HDMI_AHB_DMA_CONF0_INCR16;
+		threshold = 128;
+		break;
+	default:
+		/* NOTREACHED */
+		return -EINVAL;
+	}
+
+	dw_hdmi_set_sample_rate(dw->data.hdmi, runtime->rate);
+
+	/* Minimum number of bytes in the fifo. */
+	runtime->hw.fifo_size = threshold * 32;
+
+	conf0 |= HDMI_AHB_DMA_CONF0_EN_HLOCK;
+	conf1 = default_hdmi_channel_config[runtime->channels - 2].conf1;
+	ca = default_hdmi_channel_config[runtime->channels - 2].ca;
+
+	/*
+	 * For >2 channel PCM audio, we need to select layout 1
+	 * and set an appropriate channel map.
+	 */
+	if (runtime->channels > 2)
+		layout = HDMI_FC_AUDSCONF_LAYOUT1;
+	else
+		layout = HDMI_FC_AUDSCONF_LAYOUT0;
+
+	baikal_hdmi_writeb_relaxed(threshold, dw->data.base, HDMI_AHB_DMA_THRSLD);
+	baikal_hdmi_writeb_relaxed(conf0, dw->data.base, HDMI_AHB_DMA_CONF0);
+	baikal_hdmi_writeb_relaxed(conf1, dw->data.base, HDMI_AHB_DMA_CONF1);
+	baikal_hdmi_writeb_relaxed(layout, dw->data.base, HDMI_FC_AUDSCONF);
+	baikal_hdmi_writeb_relaxed(ca, dw->data.base, HDMI_FC_AUDICONF2);
+
+	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+		dw->reformat = dw_hdmi_reformat_iec958;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		dw_hdmi_create_cs(dw, runtime);
+		dw->reformat = dw_hdmi_reformat_s24;
+		break;
+	}
+	dw->iec_offset = 0;
+	dw->channels = runtime->channels;
+	dw->buf_src  = runtime->dma_area;
+	dw->buf_dst  = substream->dma_buffer.area;
+	dw->buf_addr = substream->dma_buffer.addr;
+	dw->buf_period = snd_pcm_lib_period_bytes(substream);
+	dw->buf_size = snd_pcm_lib_buffer_bytes(substream);
+
+	return 0;
+}
+
+static int dw_hdmi_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_dw_hdmi *dw = substream->private_data;
+	unsigned long flags;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		spin_lock_irqsave(&dw->lock, flags);
+		dw->buf_offset = 0;
+		dw->substream = substream;
+		dw_hdmi_start_dma(dw);
+		dw_hdmi_audio_enable(dw->data.hdmi);
+		spin_unlock_irqrestore(&dw->lock, flags);
+		substream->runtime->delay = substream->runtime->period_size;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		spin_lock_irqsave(&dw->lock, flags);
+		dw->substream = NULL;
+		dw_hdmi_stop_dma(dw);
+		dw_hdmi_audio_disable(dw->data.hdmi);
+		spin_unlock_irqrestore(&dw->lock, flags);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t dw_hdmi_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_dw_hdmi *dw = substream->private_data;
+
+	/*
+	 * We are unable to report the exact hardware position as
+	 * reading the 32-bit DMA position using 8-bit reads is racy.
+	 */
+	return bytes_to_frames(runtime, dw->buf_offset);
+}
+
+static struct snd_pcm_ops snd_dw_hdmi_ops = {
+	.open = dw_hdmi_open,
+	.close = dw_hdmi_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = dw_hdmi_hw_params,
+	.hw_free = dw_hdmi_hw_free,
+	.prepare = dw_hdmi_prepare,
+	.trigger = dw_hdmi_trigger,
+	.pointer = dw_hdmi_pointer,
+	.page = snd_pcm_lib_get_vmalloc_page,
+};
+
+static int snd_dw_hdmi_probe(struct platform_device *pdev)
+{
+	const struct dw_hdmi_audio_data *data = pdev->dev.platform_data;
+	struct device *dev = pdev->dev.parent;
+	struct snd_dw_hdmi *dw;
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	unsigned revision;
+	int ret;
+
+	baikal_hdmi_writeb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,
+		       data->base, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	revision = baikal_hdmi_readb_relaxed(data->base, HDMI_REVISION_ID);
+	if (revision != 0x0a && revision != 0x1a && revision != 0x2a) {
+		dev_err(dev, "dw-hdmi-audio: unknown revision 0x%02x\n",
+			revision);
+		return -ENXIO;
+	}
+
+	ret = snd_card_new(dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			      THIS_MODULE, sizeof(struct snd_dw_hdmi), &card);
+	if (ret < 0)
+		return ret;
+
+	strlcpy(card->driver, DRIVER_NAME, sizeof(card->driver));
+	strlcpy(card->shortname, "DW-HDMI", sizeof(card->shortname));
+	snprintf(card->longname, sizeof(card->longname),
+		 "%s rev 0x%02x, irq %d", card->shortname, revision,
+		 data->irq);
+
+	dw = card->private_data;
+	dw->card = card;
+	dw->data = *data;
+	dw->revision = revision;
+
+	spin_lock_init(&dw->lock);
+
+	ret = snd_pcm_new(card, "DW HDMI", 0, 1, 0, &pcm);
+	if (ret < 0)
+		goto err;
+
+	dw->pcm = pcm;
+	pcm->private_data = dw;
+	strlcpy(pcm->name, DRIVER_NAME, sizeof(pcm->name));
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_dw_hdmi_ops);
+
+	/*
+	 * To support 8-channel 96kHz audio reliably, we need 512k
+	 * to satisfy alsa with our restricted period (ERR004323).
+	 */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+			dev, 128 * 1024, 1024 * 1024);
+
+	ret = snd_card_register(card);
+	if (ret < 0)
+		goto err;
+
+	platform_set_drvdata(pdev, dw);
+
+	return 0;
+
+err:
+	snd_card_free(card);
+	return ret;
+}
+
+static int snd_dw_hdmi_remove(struct platform_device *pdev)
+{
+	struct snd_dw_hdmi *dw = platform_get_drvdata(pdev);
+
+	snd_card_free(dw->card);
+
+	return 0;
+}
+
+#if defined(CONFIG_PM_SLEEP) && defined(IS_NOT_BROKEN)
+/*
+ * This code is fine, but requires implementation in the dw_hdmi_trigger()
+ * method which is currently missing as I have no way to test this.
+ */
+static int snd_dw_hdmi_suspend(struct device *dev)
+{
+	struct snd_dw_hdmi *dw = dev_get_drvdata(dev);
+
+	snd_power_change_state(dw->card, SNDRV_CTL_POWER_D3cold);
+	snd_pcm_suspend_all(dw->pcm);
+
+	return 0;
+}
+
+static int snd_dw_hdmi_resume(struct device *dev)
+{
+	struct snd_dw_hdmi *dw = dev_get_drvdata(dev);
+
+	snd_power_change_state(dw->card, SNDRV_CTL_POWER_D0);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(snd_dw_hdmi_pm, snd_dw_hdmi_suspend,
+			 snd_dw_hdmi_resume);
+#define PM_OPS &snd_dw_hdmi_pm
+#else
+#define PM_OPS NULL
+#endif
+
+static struct platform_driver snd_dw_hdmi_driver = {
+	.probe	= snd_dw_hdmi_probe,
+	.remove	= snd_dw_hdmi_remove,
+	.driver	= {
+		.name = DRIVER_NAME,
+		.pm = PM_OPS,
+	},
+};
+
+module_platform_driver(snd_dw_hdmi_driver);
+
+MODULE_AUTHOR("Russell King <rmk+kernel@arm.linux.org.uk>");
+MODULE_DESCRIPTION("Synopsis Designware HDMI AHB ALSA interface");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c
index 2b7539701..0bf907eb3 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c
@@ -416,6 +416,11 @@ static int dw_hdmi_prepare(struct snd_pcm_substream *substream)
 			HDMI_AHB_DMA_CONF0_INCR8;
 		threshold = 128;
 		break;
+	case 0x2a: /* this revision is used in Baikal-M SoC */
+		conf0 = HDMI_AHB_DMA_CONF0_BURST_MODE |
+			HDMI_AHB_DMA_CONF0_INCR16;
+		threshold = 128;
+		break;
 	default:
 		/* NOTREACHED */
 		return -EINVAL;
@@ -527,7 +532,7 @@ static int snd_dw_hdmi_probe(struct platform_device *pdev)
 	writeb_relaxed(HDMI_IH_MUTE_AHBDMAAUD_STAT0_ALL,
 		       data->base + HDMI_IH_MUTE_AHBDMAAUD_STAT0);
 	revision = readb_relaxed(data->base + HDMI_REVISION_ID);
-	if (revision != 0x0a && revision != 0x1a) {
+	if (revision != 0x0a && revision != 0x1a && revision != 0x2a) {
 		dev_err(dev, "dw-hdmi-audio: unknown revision 0x%02x\n",
 			revision);
 		return -ENXIO;
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ext.h b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ext.h
new file mode 100644
index 000000000..6af006beb
--- /dev/null
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ext.h
@@ -0,0 +1,159 @@
+/*
+ * Additional header file used with
+ * DesignWare High-Definition Multimedia Interface (HDMI) driver
+ * for Baikal Electronics BE-M1000 SoC
+ *
+ * This file contains constants which are missing in 4.9.x dw-hdmi.h
+ * and dw-hdmi-audio.h files. These constants are needed for 
+ * Baikal Electronics' version of dw-hdmi driver as it is essentially
+ * a backported 4.13.x driver with some patches.
+ *
+ * Copyright (C) 2019 Baikal Electronics JSC
+ *
+ * Author: Pavel Parkhomenko <Pavel.Parkhomenko@baikalelectronics.ru>
+ *
+ * Parts of this file were based on sources as follows:
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __DW_HDMI_EXT_H__
+#define __DW_HDMI_EXT_H__
+
+enum {
+/* PRODUCT_ID0 field values */
+	HDMI_PRODUCT_ID0_HDMI_TX = 0xa0,
+
+/* PRODUCT_ID1 field values */
+	HDMI_PRODUCT_ID1_HDCP = 0xc0,
+	HDMI_PRODUCT_ID1_HDMI_RX = 0x02,
+	HDMI_PRODUCT_ID1_HDMI_TX = 0x01,
+
+/* CONFIG0_ID field values */
+	HDMI_CONFIG0_I2S = 0x10,
+
+/* CONFIG3_ID field values */
+	HDMI_CONFIG3_AHBAUDDMA = 0x02,
+	HDMI_CONFIG3_GPAUD = 0x01,
+
+/* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
+	HDMI_IH_I2CM_STAT0_DONE = 0x2,
+	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
+
+/* FC_DATAUTO0 field values */
+	HDMI_FC_DATAUTO0_VSD_MASK = 0x08,
+	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
+
+/* AUD_CONF0 field values */
+	HDMI_AUD_CONF0_SW_RESET = 0x80,
+	HDMI_AUD_CONF0_I2S_ALL_ENABLE = 0x2F,
+
+/* AUD_CONF1 field values */
+	HDMI_AUD_CONF1_MODE_I2S = 0x00,
+	HDMI_AUD_CONF1_MODE_RIGHT_J = 0x02,
+	HDMI_AUD_CONF1_MODE_LEFT_J = 0x04,
+	HDMI_AUD_CONF1_WIDTH_16 = 0x10,
+	HDMI_AUD_CONF1_WIDTH_24 = 0x18,
+
+/* HDMI_AUD_INPUTCLKFS field values */
+	HDMI_AUD_INPUTCLKFS_128FS = 0,
+	HDMI_AUD_INPUTCLKFS_256FS = 1,
+	HDMI_AUD_INPUTCLKFS_512FS = 2,
+	HDMI_AUD_INPUTCLKFS_64FS = 4,
+
+
+/* I2CM_OPERATION field values */
+	HDMI_I2CM_OPERATION_WRITE = 0x10,
+	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
+	HDMI_I2CM_OPERATION_READ = 0x1,
+
+/* I2CM_INT field values */
+	HDMI_I2CM_INT_DONE_POL = 0x8,
+	HDMI_I2CM_INT_DONE_MASK = 0x4,
+
+/* I2CM_CTLINT field values */
+	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
+	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
+	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
+	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
+};
+
+/*
+ * HDMI 3D TX PHY registers
+ */
+#define HDMI_3D_TX_PHY_PWRCTRL			0x00
+#define HDMI_3D_TX_PHY_SERDIVCTRL		0x01
+#define HDMI_3D_TX_PHY_SERCKCTRL		0x02
+#define HDMI_3D_TX_PHY_SERCKKILLCTRL		0x03
+#define HDMI_3D_TX_PHY_TXRESCTRL		0x04
+#define HDMI_3D_TX_PHY_CKCALCTRL		0x05
+#define HDMI_3D_TX_PHY_CPCE_CTRL		0x06
+#define HDMI_3D_TX_PHY_TXCLKMEASCTRL		0x07
+#define HDMI_3D_TX_PHY_TXMEASCTRL		0x08
+#define HDMI_3D_TX_PHY_CKSYMTXCTRL		0x09
+#define HDMI_3D_TX_PHY_CMPSEQCTRL		0x0a
+#define HDMI_3D_TX_PHY_CMPPWRCTRL		0x0b
+#define HDMI_3D_TX_PHY_CMPMODECTRL		0x0c
+#define HDMI_3D_TX_PHY_MEASCTRL			0x0d
+#define HDMI_3D_TX_PHY_VLEVCTRL			0x0e
+#define HDMI_3D_TX_PHY_D2ACTRL			0x0f
+#define HDMI_3D_TX_PHY_CURRCTRL			0x10
+#define HDMI_3D_TX_PHY_DRVANACTRL		0x11
+#define HDMI_3D_TX_PHY_PLLMEASCTRL		0x12
+#define HDMI_3D_TX_PHY_PLLPHBYCTRL		0x13
+#define HDMI_3D_TX_PHY_GRP_CTRL			0x14
+#define HDMI_3D_TX_PHY_GMPCTRL			0x15
+#define HDMI_3D_TX_PHY_MPLLMEASCTRL		0x16
+#define HDMI_3D_TX_PHY_MSM_CTRL			0x17
+#define HDMI_3D_TX_PHY_SCRPB_STATUS		0x18
+#define HDMI_3D_TX_PHY_TXTERM			0x19
+#define HDMI_3D_TX_PHY_PTRPT_ENBL		0x1a
+#define HDMI_3D_TX_PHY_PATTERNGEN		0x1b
+#define HDMI_3D_TX_PHY_SDCAP_MODE		0x1c
+#define HDMI_3D_TX_PHY_SCOPEMODE		0x1d
+#define HDMI_3D_TX_PHY_DIGTXMODE		0x1e
+#define HDMI_3D_TX_PHY_STR_STATUS		0x1f
+#define HDMI_3D_TX_PHY_SCOPECNT0		0x20
+#define HDMI_3D_TX_PHY_SCOPECNT1		0x21
+#define HDMI_3D_TX_PHY_SCOPECNT2		0x22
+#define HDMI_3D_TX_PHY_SCOPECNTCLK		0x23
+#define HDMI_3D_TX_PHY_SCOPESAMPLE		0x24
+#define HDMI_3D_TX_PHY_SCOPECNTMSB01		0x25
+#define HDMI_3D_TX_PHY_SCOPECNTMSB2CK		0x26
+
+/* HDMI_3D_TX_PHY_CKCALCTRL values */
+#define HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE		BIT(15)
+
+/* HDMI_3D_TX_PHY_MSM_CTRL values */
+#define HDMI_3D_TX_PHY_MSM_CTRL_MPLL_PH_SEL_CK		BIT(13)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_CLK_REF_MPLL	(0 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_OFF		(1 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_PCLK		(2 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK		(3 << 1)
+#define HDMI_3D_TX_PHY_MSM_CTRL_SCOPE_CK_SEL		BIT(0)
+
+/* HDMI_3D_TX_PHY_PTRPT_ENBL values */
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_OVERRIDE		BIT(15)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT2		BIT(8)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT1		BIT(7)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT0		BIT(6)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CK_REF_ENB		BIT(5)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_RCAL_ENB		BIT(4)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_CLK_ALIGN_ENB	BIT(3)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_READY		BIT(2)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_CKO_WORD_ENB		BIT(1)
+#define HDMI_3D_TX_PHY_PTRPT_ENBL_REFCLK_ENB		BIT(0)
+
+struct dw_hdmi_i2s_audio_data {
+	struct dw_hdmi *hdmi;
+
+	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
+	u8 (*read)(struct dw_hdmi *hdmi, int offset);
+};
+
+#endif /* __DW_HDMI_EXT_H__ */
diff --git a/drivers/gpu/drm/panfrost/panfrost_gpu.c b/drivers/gpu/drm/panfrost/panfrost_gpu.c
index 0d39a201c..72885a249 100644
--- a/drivers/gpu/drm/panfrost/panfrost_gpu.c
+++ b/drivers/gpu/drm/panfrost/panfrost_gpu.c
@@ -62,7 +62,7 @@ int panfrost_gpu_soft_reset(struct panfrost_device *pfdev)
 	gpu_write(pfdev, GPU_CMD, GPU_CMD_SOFT_RESET);
 
 	ret = readl_relaxed_poll_timeout(pfdev->iomem + GPU_INT_RAWSTAT,
-		val, val & GPU_IRQ_RESET_COMPLETED, 100, 10000);
+		val, val & GPU_IRQ_RESET_COMPLETED, 5, 10000);
 
 	if (ret) {
 		dev_err(pfdev->dev, "gpu soft reset timed out\n");
@@ -313,26 +313,34 @@ static void panfrost_gpu_init_features(struct panfrost_device *pfdev)
 void panfrost_gpu_power_on(struct panfrost_device *pfdev)
 {
 	int ret;
-	u32 val;
+	ktime_t timeout;
 
 	panfrost_gpu_init_quirks(pfdev);
 
 	/* Just turn on everything for now */
 	gpu_write(pfdev, L2_PWRON_LO, pfdev->features.l2_present);
-	ret = readl_relaxed_poll_timeout(pfdev->iomem + L2_READY_LO,
-		val, val == pfdev->features.l2_present, 100, 1000);
-
 	gpu_write(pfdev, STACK_PWRON_LO, pfdev->features.stack_present);
-	ret |= readl_relaxed_poll_timeout(pfdev->iomem + STACK_READY_LO,
-		val, val == pfdev->features.stack_present, 100, 1000);
-
 	gpu_write(pfdev, SHADER_PWRON_LO, pfdev->features.shader_present);
-	ret |= readl_relaxed_poll_timeout(pfdev->iomem + SHADER_READY_LO,
-		val, val == pfdev->features.shader_present, 100, 1000);
-
 	gpu_write(pfdev, TILER_PWRON_LO, pfdev->features.tiler_present);
-	ret |= readl_relaxed_poll_timeout(pfdev->iomem + TILER_READY_LO,
-		val, val == pfdev->features.tiler_present, 100, 1000);
+
+	timeout = ktime_add_us(ktime_get(), 1000);
+	ret = 0;
+	for (;;) {
+	if (gpu_read(pfdev, L2_READY_LO) ==
+			pfdev->features.l2_present &&
+		    gpu_read(pfdev, STACK_READY_LO) ==
+			pfdev->features.stack_present &&
+		    gpu_read(pfdev, SHADER_READY_LO) ==
+			pfdev->features.shader_present &&
+		    gpu_read(pfdev, TILER_READY_LO) ==
+			pfdev->features.tiler_present)
+			break;
+		if (ktime_compare(ktime_get(), timeout) > 0) {
+			ret = 1;
+			break;
+		}
+		usleep_range(3, 5);
+	}
 
 	if (ret)
 		dev_err(pfdev->dev, "error powering up gpu");
@@ -340,10 +348,11 @@ void panfrost_gpu_power_on(struct panfrost_device *pfdev)
 
 void panfrost_gpu_power_off(struct panfrost_device *pfdev)
 {
-	gpu_write(pfdev, TILER_PWROFF_LO, 0);
-	gpu_write(pfdev, SHADER_PWROFF_LO, 0);
-	gpu_write(pfdev, STACK_PWROFF_LO, 0);
-	gpu_write(pfdev, L2_PWROFF_LO, 0);
+	dev_dbg(pfdev->dev, "gpu_power_off...\n");
+	gpu_write(pfdev, TILER_PWROFF_LO, pfdev->features.tiler_present);
+	gpu_write(pfdev, SHADER_PWROFF_LO, pfdev->features.shader_present);
+	gpu_write(pfdev, STACK_PWROFF_LO, pfdev->features.stack_present);
+	gpu_write(pfdev, L2_PWROFF_LO, pfdev->features.l2_present);
 }
 
 int panfrost_gpu_init(struct panfrost_device *pfdev)
diff --git a/drivers/gpu/drm/panfrost/panfrost_job.c b/drivers/gpu/drm/panfrost/panfrost_job.c
index 9f770d454..ac3ba444c 100644
--- a/drivers/gpu/drm/panfrost/panfrost_job.c
+++ b/drivers/gpu/drm/panfrost/panfrost_job.c
@@ -133,6 +133,8 @@ static void panfrost_job_write_affinity(struct panfrost_device *pfdev,
 	 * multiple (2) coherent core groups
 	 */
 	affinity = pfdev->features.shader_present;
+	if (panfrost_model_eq(pfdev, 0x620) && js == 1)
+		affinity &= 0xf;
 
 	job_write(pfdev, JS_AFFINITY_NEXT_LO(js), affinity & 0xFFFFFFFF);
 	job_write(pfdev, JS_AFFINITY_NEXT_HI(js), affinity >> 32);
@@ -181,7 +183,7 @@ static void panfrost_job_hw_submit(struct panfrost_job *job, int js)
 		job_write(pfdev, JS_FLUSH_ID_NEXT(js), job->flush_id);
 
 	/* GO ! */
-	dev_dbg(pfdev->dev, "JS: Submitting atom %p to js[%d] with head=0x%llx",
+	dev_dbg(pfdev->dev, "JS: Submitting atom %px to js[%d] with head=0x%llx",
 				job, js, jc_head);
 
 	job_write(pfdev, JS_COMMAND_NEXT(js), JS_COMMAND_START);
@@ -389,7 +391,7 @@ static void panfrost_job_timedout(struct drm_sched_job *sched_job)
 	if (dma_fence_is_signaled(job->done_fence))
 		return;
 
-	dev_err(pfdev->dev, "gpu sched timeout, js=%d, config=0x%x, status=0x%x, head=0x%x, tail=0x%x, sched_job=%p",
+	dev_err(pfdev->dev, "gpu sched timeout, js=%d, config=0x%x, status=0x%x, head=0x%x, tail=0x%x, sched_job=%px",
 		js,
 		job_read(pfdev, JS_CONFIG(js)),
 		job_read(pfdev, JS_STATUS(js)),
@@ -403,7 +405,7 @@ static void panfrost_job_timedout(struct drm_sched_job *sched_job)
 	for (i = 0; i < NUM_JOB_SLOTS; i++) {
 		struct drm_gpu_scheduler *sched = &pfdev->js->queue[i].sched;
 
-		drm_sched_stop(sched, sched_job);
+		drm_sched_stop(sched, pfdev->jobs[i] ? &pfdev->jobs[i]->base : NULL);
 		if (js != i)
 			/* Ensure any timeouts on other slots have finished */
 			cancel_delayed_work_sync(&sched->work_tdr);
@@ -414,6 +416,7 @@ static void panfrost_job_timedout(struct drm_sched_job *sched_job)
 	spin_lock_irqsave(&pfdev->js->job_lock, flags);
 	for (i = 0; i < NUM_JOB_SLOTS; i++) {
 		if (pfdev->jobs[i]) {
+			panfrost_devfreq_record_transition(pfdev, js);
 			pm_runtime_put_noidle(pfdev->dev);
 			pfdev->jobs[i] = NULL;
 		}
@@ -422,7 +425,6 @@ static void panfrost_job_timedout(struct drm_sched_job *sched_job)
 
 	/* panfrost_core_dump(pfdev); */
 
-	panfrost_devfreq_record_transition(pfdev, js);
 	panfrost_device_reset(pfdev);
 
 	for (i = 0; i < NUM_JOB_SLOTS; i++)
diff --git a/drivers/gpu/drm/panfrost/panfrost_mmu.c b/drivers/gpu/drm/panfrost/panfrost_mmu.c
index 3dc9b30a6..f04dd9955 100644
--- a/drivers/gpu/drm/panfrost/panfrost_mmu.c
+++ b/drivers/gpu/drm/panfrost/panfrost_mmu.c
@@ -31,7 +31,7 @@ static int wait_ready(struct panfrost_device *pfdev, u32 as_nr)
 	/* Wait for the MMU status to indicate there is no active command, in
 	 * case one is pending. */
 	ret = readl_relaxed_poll_timeout_atomic(pfdev->iomem + AS_STATUS(as_nr),
-		val, !(val & AS_STATUS_AS_ACTIVE), 10, 1000);
+		val, !(val & AS_STATUS_AS_ACTIVE), 3, 1000);
 
 	if (ret)
 		dev_err(pfdev->dev, "AS_ACTIVE bit stuck\n");
@@ -64,13 +64,21 @@ static void lock_region(struct panfrost_device *pfdev, u32 as_nr,
 	 * results in the range (11 .. 42)
 	 */
 
-	size = round_up(size, PAGE_SIZE);
-
-	region_width = 10 + fls(size >> PAGE_SHIFT);
-	if ((size >> PAGE_SHIFT) != (1ul << (region_width - 11))) {
-		/* not pow2, so must go up to the next pow2 */
-		region_width += 1;
+	if (size & ~PAGE_MASK)
+		size = (size >> PAGE_SHIFT) + 1;
+	else
+		size = size >> PAGE_SHIFT;
+	region_width = 10;
+	if (size > 0x80000000) {
+		if (size & 0xffffffff)
+			size = (size >> 32) + 1;
+		else
+			size = size >> 32;
+		region_width += 32;
 	}
+	region_width += fls(size);
+	if (size != (1ul << ((region_width - 11) & 0x1f)))
+		region_width++;
 	region |= region_width;
 
 	/* Lock the region that needs to be updated */
@@ -115,7 +123,7 @@ static void panfrost_mmu_enable(struct panfrost_device *pfdev, struct panfrost_m
 	u64 transtab = cfg->arm_mali_lpae_cfg.transtab;
 	u64 memattr = cfg->arm_mali_lpae_cfg.memattr;
 
-	mmu_hw_do_operation_locked(pfdev, as_nr, 0, ~0UL, AS_COMMAND_FLUSH_MEM);
+	mmu_hw_do_operation_locked(pfdev, as_nr, 0, 1ULL << 48, AS_COMMAND_FLUSH_MEM);
 
 	mmu_write(pfdev, AS_TRANSTAB_LO(as_nr), transtab & 0xffffffffUL);
 	mmu_write(pfdev, AS_TRANSTAB_HI(as_nr), transtab >> 32);
@@ -123,6 +131,10 @@ static void panfrost_mmu_enable(struct panfrost_device *pfdev, struct panfrost_m
 	/* Need to revisit mem attrs.
 	 * NC is the default, Mali driver is inner WT.
 	 */
+	if (pfdev->features.id == 0x620) {
+		memattr &= ~0xf0f0f0ULL;
+		memattr |= 0x404040;
+	}
 	mmu_write(pfdev, AS_MEMATTR_LO(as_nr), memattr & 0xffffffffUL);
 	mmu_write(pfdev, AS_MEMATTR_HI(as_nr), memattr >> 32);
 
@@ -186,7 +198,7 @@ u32 panfrost_mmu_as_get(struct panfrost_device *pfdev, struct panfrost_mmu *mmu)
 	atomic_set(&mmu->as_count, 1);
 	list_add(&mmu->list, &pfdev->as_lru_list);
 
-	dev_dbg(pfdev->dev, "Assigned AS%d to mmu %p, alloc_mask=%lx", as, mmu, pfdev->as_alloc_mask);
+	dev_dbg(pfdev->dev, "Assigned AS%d to mmu %px, alloc_mask=%lx", as, mmu, pfdev->as_alloc_mask);
 
 	panfrost_mmu_enable(pfdev, mmu);
 
@@ -287,6 +299,8 @@ int panfrost_mmu_map(struct panfrost_gem_mapping *mapping)
 
 	if (bo->noexec)
 		prot |= IOMMU_NOEXEC;
+	if (bo->is_heap)
+		prot |= IOMMU_CACHE;
 
 	sgt = drm_gem_shmem_get_pages_sgt(obj);
 	if (WARN_ON(IS_ERR(sgt)))
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 13a6b4afb..ea748f1be 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -385,6 +385,15 @@ config SENSORS_ATXP1
 	  This driver can also be built as a module. If so, the module
 	  will be called atxp1.
 
+config SENSORS_PVT
+	tristate "Baikal PVT"
+	help
+	  If you say yes here you get support for Baikal PVT single
+	  input temperature sensor chips.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called pvt.
+
 config SENSORS_DS620
 	tristate "Dallas Semiconductor DS620"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 40c036ea4..7ba6f0208 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -160,6 +160,7 @@ obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
 obj-$(CONFIG_SENSORS_STTS751)	+= stts751.o
 obj-$(CONFIG_SENSORS_AMC6821)	+= amc6821.o
 obj-$(CONFIG_SENSORS_TC74)	+= tc74.o
+obj-$(CONFIG_SENSORS_PVT)	+= pvt.o
 obj-$(CONFIG_SENSORS_THMC50)	+= thmc50.o
 obj-$(CONFIG_SENSORS_TMP102)	+= tmp102.o
 obj-$(CONFIG_SENSORS_TMP103)	+= tmp103.o
diff --git a/drivers/hwmon/pvt.c b/drivers/hwmon/pvt.c
new file mode 100644
index 000000000..8258a2230
--- /dev/null
+++ b/drivers/hwmon/pvt.c
@@ -0,0 +1,638 @@
+/*
+ * An hwmon driver for BAIKAL-M PVT Sensors based on
+ *
+ * Analog Bits. PVT Sensor Datasheet. Version: 2014.07.23
+ *
+ *  Copyright (C) 2017 Baikal Electronics JSC
+ *  Author:
+ *      Maxim Kaurkin <maxim.kaurkin@baikalelectronics.ru>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/of.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+#include <linux/io.h>
+#include <linux/arm-smccc.h>
+
+#define DRV_NAME "pvt"
+#define DRV_VERSION "2.0.0"
+
+#define BAIKAL_SMC_PVT_ID	0x82000001
+#define PVT_READ	0
+#define PVT_WRITE	1
+
+/* PVT registers */
+#define BK_PVT_CTRL		0x00
+#define BK_PVT_DATA		0x04
+#define BK_PVT_TTHRES		0x08
+#define BK_PVT_VTHRES		0x0C
+#define BK_PVT_TTIMEOUT		0x1C
+#define BK_PVT_INTR_STAT	0x20
+#define BK_PVT_INTR_MASK	0x24
+#define BK_PVT_CLR_INTR		0x2C
+/* PVT VALID bit reads TIMEOUT */
+#define BK_PVT_VALID_TIMEOUT	10000
+
+/* PVT VALUES and MASKS */
+#define BK_PVT_CTRL_EN_BIT  0x1
+#define BK_PVT_CTRL_TMOD    0x0
+#define BK_PVT_CTRL_VMOD    0x2
+#define BK_PVT_CTRL_LVTMOD  0b0100
+#define BK_PVT_CTRL_HVTMOD  0b1000
+#define BK_PVT_CTRL_SVTMOD  0b1100
+
+#define BK_PVT_INTR_MASK_TONLY  0x7F9
+#define BK_PVT_INTR_MASK_TVONLY 0x7E1
+#define BK_PVT_INTR_MASK_ALL  0x7FF
+
+#define BK_PVT_DATA_MASK    0x3ff
+#define BK_PVT_DATA_VALID   (1 << 10)
+
+#define BK_PVT_THRES_HI    0xFFC00
+#define BK_PVT_THRES_LO    0x3FF
+
+#define BK_PVT_TTIMEOUT_SET 10000000
+
+#define BK_PVT_INTR_STAT_TTHRES_LO 0x02
+#define BK_PVT_INTR_STAT_TTHRES_HI 0x04
+#define BK_PVT_INTR_STAT_VTHRES_LO 0x08
+#define BK_PVT_INTR_STAT_VTHRES_HI 0x10
+
+/* TEMP limits */
+#define TEMP_PVT_MAX 125000
+#define TEMP_PVT_MIN -40000
+#define TEMP_PVT_WARN   67000
+#define TEMP_PVT_REBOOT 75000
+/* Voltage limits */
+#define VOLT_PVT_MAX 800
+#define VOLT_PVT_MIN 1000
+
+
+/* coef for transformtion to T,C (10^-3) times 10^6
+ * DATA = BK_PVT_DATA [0:9]
+ * T =  COEF4 * DATA ^ 4 + COEF3 * DATA ^ 3 + COEF2 * DATA ^ 2 +
+ *    + COEF1 * DATA ^ 1 + COEF0 */
+#define COEF4   (-16743 )        /* (-1.6743E-11f)  * 10^15 */
+#define COEF3   (81542  )        /* (8.1542E-08f)   * 10^12 */
+#define COEF2   (-182010)        /* (-1.8201E-04f)  * 10^9  */
+#define COEF1   (310200 )        /* (3.1020E-01f)   * 10^6  */
+#define COEF0   (-48380 )        /* (-4.8380E+01f)  * 10^3  */
+
+/* coef for transformation T,C (10^-3) to DATA
+ * DATA = DCOEF3 * T^3 + DCOEF2 * T ^ 2 + DCOEF1 * T + DCOEF 0 */
+
+#define DCOEF3  (2617)
+#define DCOEF2  (8654)
+#define DCOEF1  (3923)
+#define DCOEF0  (172 )
+
+/*  coef for transformatio to V, mV
+ *  DATA = 1865.8 *  VOLTAGE- 1157.2 =>
+ *  VOLTAGE = 620 + data * 10000 / 18658;
+*/
+#define COEF0_V 620
+#define COEF1_V 18658
+
+static uint32_t writel_pvt(uint32_t val, uint32_t pvt_id, uint32_t offset) {
+
+    struct arm_smccc_res res;
+
+    arm_smccc_smc(BAIKAL_SMC_PVT_ID, PVT_WRITE, pvt_id, offset,
+    val, 0, 0, 0, &res);
+    return res.a0;
+}
+
+static uint32_t readl_pvt(uint32_t pvt_id, uint32_t offset) {
+
+    struct arm_smccc_res res;
+
+    arm_smccc_smc(BAIKAL_SMC_PVT_ID, PVT_READ, pvt_id, offset,
+    0, 0, 0, 0, &res);
+    return res.a0;
+}
+
+struct pvt_hwmon {
+    int pvt_id;
+    int base;
+    int irq;
+    const struct mfd_cell *cell;
+    struct device *hwmon;
+    struct completion read_completion;
+    struct mutex lock;
+    int temp;
+    int volt;
+    int svt;
+    int hvt;
+    int lvt;
+    bool mon_mod;
+};
+
+static void switch_to_mon_mod(struct pvt_hwmon *hwmon) {
+    //OFF PVT
+    writel_pvt( 0, hwmon->pvt_id , BK_PVT_CTRL);
+    //Set timeout of inerupts
+    writel_pvt( BK_PVT_TTIMEOUT_SET, hwmon->pvt_id , BK_PVT_TTIMEOUT);
+    pr_debug("pvt switch_to_mon_mod and set BK_PVT_TTIMEOUT %d\n",readl_pvt(hwmon->pvt_id , BK_PVT_TTIMEOUT));
+    //Mask all interupts
+    writel_pvt( BK_PVT_INTR_MASK_TVONLY, hwmon->pvt_id , BK_PVT_INTR_MASK);
+    //Switch to last VOLT or Temprature mon_mod
+    writel_pvt( ((hwmon->mon_mod)<<1), hwmon->pvt_id , BK_PVT_CTRL);
+    pr_debug("pvt switch_to_mon_mod and set BK_PVT_CTRL %d\n",readl_pvt(hwmon->pvt_id , BK_PVT_CTRL));
+    //ON PVT
+    writel_pvt( (BK_PVT_CTRL_EN_BIT)| ((hwmon->mon_mod)<<1), hwmon->pvt_id , BK_PVT_CTRL);
+}
+
+static int read_valid_datareg( struct pvt_hwmon *hwmon)
+{
+    register int data, i = 0;
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_DATA);
+    data = 0;
+    while ( ! (data & (BK_PVT_DATA_VALID) )  ) {
+        data = readl_pvt(hwmon->pvt_id , BK_PVT_DATA);
+        if( ++i == BK_PVT_VALID_TIMEOUT )
+            return -EINVAL;
+    }
+
+    data &= ( BK_PVT_DATA_MASK);
+    switch_to_mon_mod(hwmon);
+    return data;
+}
+
+
+static void switch_pvt_mod(int pvt_id, long int mod)
+{
+    pr_debug("BK PVT now %x, but need %lx \n",readl_pvt(pvt_id , BK_PVT_CTRL), (unsigned long)mod);
+    writel_pvt( 0, pvt_id , BK_PVT_CTRL);
+    //Set timeout of PVT measurment
+    writel_pvt( 0, pvt_id , BK_PVT_TTIMEOUT);
+    //Mask all interupts
+    writel_pvt( BK_PVT_INTR_MASK_ALL, pvt_id , BK_PVT_INTR_MASK);
+    writel_pvt( mod, pvt_id , BK_PVT_CTRL);
+    writel_pvt( ((BK_PVT_CTRL_EN_BIT)|mod), pvt_id , BK_PVT_CTRL);
+    pr_debug("BK PVT MOD %x\n",readl_pvt(pvt_id , BK_PVT_CTRL));
+}
+
+static int data2temp(int data)
+{
+    int temp, temp4, temp3, temp2, temp1, temp0;
+    pr_debug("pvt %d and data %d \n",( BK_PVT_DATA_MASK), data);
+    /*Dont changer the order of multiplication !!! */
+    temp4 = (COEF4) * data / 1000 * data / 1000 * data / 1000 * data / 1000;
+    temp3 = (COEF3) * data / 1000 * data / 1000 * data / 1000;
+    temp2 = (COEF2) * data / 1000 * data / 1000;
+    temp1 = (COEF1) * data / 1000;
+    temp0 = (COEF0) ;
+    temp = temp0 + temp1 + temp2 + temp3 + temp4;
+    pr_debug("BK PVT temp  %d = %d + %d + %d + %d + %d \n",temp, temp4, temp3, temp2 ,temp1, temp0);
+    return temp;
+}
+
+static irqreturn_t pvt_hwmon_irq(int irq, void *data)
+{
+    long int val;
+    int tmp, temp;
+    struct pvt_hwmon *hwmon = data;
+    val = readl_pvt( hwmon->pvt_id , BK_PVT_INTR_STAT);
+    if (BK_PVT_INTR_STAT_TTHRES_LO & val)
+        printk(KERN_INFO "PVT WARNING Lo Temperature \n");
+    if (BK_PVT_INTR_STAT_TTHRES_HI & val) {
+        switch_pvt_mod(hwmon->pvt_id,BK_PVT_CTRL_TMOD);
+        tmp = read_valid_datareg(hwmon);
+        temp = data2temp(tmp);
+        printk(KERN_INFO "PVT WARNING Hi Temperature %d\n", temp);
+        if(temp > TEMP_PVT_REBOOT) {
+            printk(KERN_INFO "PVT TOO Hi Temperature (%d > %d), then pm_power_off!\n", temp, TEMP_PVT_REBOOT);
+            pm_power_off();
+        }
+    }
+    if (BK_PVT_INTR_STAT_VTHRES_LO & val)
+        printk(KERN_INFO "PVT WARNING Lo Voltage \n");
+    if (BK_PVT_INTR_STAT_VTHRES_HI & val)
+        printk(KERN_INFO "PVT WARNING Lo Voltage \n");
+    val = readl_pvt( hwmon->pvt_id , BK_PVT_CLR_INTR);
+    complete(&hwmon->read_completion);
+    return IRQ_HANDLED;
+}
+
+static ssize_t pvt_show_name(struct device *dev,
+    struct device_attribute *dev_attr, char *buf)
+{
+    return sprintf(buf, "pvt-baikal\n");
+}
+
+static ssize_t pvt_show_mon_mod(struct device *dev,
+    struct device_attribute *dev_attr, char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n",hwmon->mon_mod);
+}
+
+static ssize_t set_mon_mod(struct device *dev, struct device_attribute *devattr,
+             const char *buf, size_t count)
+{
+    int err;
+    long data;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    err = kstrtol(buf, 10, &data);
+    if (err)
+        return err;
+    mutex_lock(&hwmon->lock);
+    hwmon->mon_mod = data;
+    switch_to_mon_mod(hwmon);
+    mutex_unlock(&hwmon->lock);
+    return count;
+}
+
+/* sysfs attributes for hwmon */
+static ssize_t pvt_show_temp(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    int data, temp;
+    mutex_lock(&hwmon->lock);
+    switch_pvt_mod(hwmon->pvt_id,BK_PVT_CTRL_TMOD);
+    data = read_valid_datareg(hwmon);
+    temp = data2temp(data);
+    hwmon->temp = temp;
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", temp);
+}
+
+static int temp2data(int temp)
+{
+    int data3, data2, data1, data0, data;
+
+    if( temp > TEMP_PVT_MAX )
+        temp = TEMP_PVT_MAX;
+    if( temp < TEMP_PVT_MIN )
+        temp = TEMP_PVT_MIN;
+
+    /*Dont changer the order of multiplication !!! */
+    data3 = DCOEF3 * temp / 1000000 * temp / 1000000 * temp / 100000;
+    data2 = DCOEF2 * temp / 1000000 * temp / 1000000;
+    data1 = DCOEF1 * temp / 1000000;
+    data0 = DCOEF0;
+    data = data0 + data1 + data2 + data3;
+
+    pr_debug("pvt %d and data %d \n", (BK_PVT_DATA_MASK), data);
+
+    return data;
+}
+
+static int data2volt(int data)
+{
+    /* DATA = 1865.8 *  VOLTAGE- 1157.2 */
+    return (COEF0_V + ( data * 10000 ) / COEF1_V);
+}
+
+int volt2data(int volt)
+{
+    if( volt > VOLT_PVT_MAX )
+        volt = VOLT_PVT_MAX;
+    if( volt < VOLT_PVT_MIN )
+        volt = VOLT_PVT_MIN;
+    /* DATA = 1865.8 *  VOLTAGE- 1157.2 */
+    return (18658 * volt / 10000 - 1157 );
+}
+
+static ssize_t set_temp_min(struct device *dev, struct device_attribute *devattr,
+			 const char *buf, size_t count)
+{
+    unsigned int val, data;
+    long int temp;
+    int err;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    err = kstrtol(buf, 10, &temp);
+    if (err)
+        return err;
+    mutex_lock(&hwmon->lock);
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_TTHRES);
+    val = temp2data(temp);
+    data = (data & BK_PVT_THRES_HI) + (BK_PVT_THRES_LO & val);
+    writel_pvt( data, hwmon->pvt_id , BK_PVT_TTHRES);
+    mutex_unlock(&hwmon->lock);
+    return count;
+}
+
+static ssize_t set_temp_max(struct device *dev, struct device_attribute *devattr,
+             const char *buf, size_t count)
+{
+    unsigned int val, data;
+    long int temp;
+    int err;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    err = kstrtol(buf, 10, &temp);
+    if (err)
+        return err;
+    mutex_lock(&hwmon->lock);
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_TTHRES);
+    val = temp2data(temp);
+    data = ( (val<<10) & BK_PVT_THRES_HI) + (BK_PVT_THRES_LO & data);
+    writel_pvt( data, hwmon->pvt_id , BK_PVT_TTHRES);
+    mutex_unlock(&hwmon->lock);
+    return count;
+}
+
+static ssize_t set_volt_min(struct device *dev, struct device_attribute *devattr,
+             const char *buf, size_t count)
+{
+    unsigned int val, data;
+    long int volt;
+    int err;
+
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    err = kstrtol(buf, 10, &volt);
+    if (err)
+        return err;
+    mutex_lock(&hwmon->lock);
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_VTHRES);
+    val = volt2data(volt);
+    data = (data & BK_PVT_THRES_HI) + (BK_PVT_THRES_LO & val);
+    writel_pvt( data, hwmon->pvt_id , BK_PVT_VTHRES);
+    mutex_unlock(&hwmon->lock);
+    return count;
+}
+
+static ssize_t set_volt_max(struct device *dev, struct device_attribute *devattr,
+             const char *buf, size_t count)
+{
+    unsigned int val, data;
+    long int volt;
+    int err;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    err = kstrtol(buf, 10, &volt);
+    if (err)
+        return err;
+    mutex_lock(&hwmon->lock);
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_VTHRES);
+    val = volt2data(volt);
+    pr_debug("pvt set volt max %ld and val %x\n",volt,val);
+    data = ( (val<<10) & BK_PVT_THRES_HI) + (BK_PVT_THRES_LO & data);
+    writel_pvt( data, hwmon->pvt_id , BK_PVT_VTHRES);
+    mutex_unlock(&hwmon->lock);
+    return count;
+}
+
+static ssize_t pvt_show_temp_min(struct device *dev, struct device_attribute *devattr,
+             char *buf)
+{
+    unsigned int val, data;
+    int temp;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    mutex_lock(&hwmon->lock);
+    val = readl_pvt(hwmon->pvt_id , BK_PVT_TTHRES);
+    data = BK_PVT_THRES_LO & val;
+    temp = data2temp(data);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", temp);
+}
+
+static ssize_t pvt_show_temp_max(struct device *dev, struct device_attribute *devattr,
+             char *buf)
+{
+    unsigned int val, data;
+    int temp;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    mutex_lock(&hwmon->lock);
+    val = readl_pvt(hwmon->pvt_id , BK_PVT_TTHRES);
+    data = (BK_PVT_THRES_HI & val) >> 10;
+    temp = data2temp(data);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", temp);
+}
+
+static ssize_t pvt_show_volt_min(struct device *dev, struct device_attribute *devattr,
+             char *buf)
+{
+    unsigned int val, data;
+    int volt;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    mutex_lock(&hwmon->lock);
+    val = readl_pvt(hwmon->pvt_id , BK_PVT_VTHRES);
+    data = BK_PVT_THRES_LO & val;
+    volt = data2volt(data);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", volt);
+}
+
+
+static ssize_t pvt_show_volt_max(struct device *dev, struct device_attribute *devattr,
+             char *buf)
+{
+    unsigned int val, data;
+    int volt;
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    mutex_lock(&hwmon->lock);
+    val = readl_pvt(hwmon->pvt_id , BK_PVT_VTHRES);
+    data = (BK_PVT_THRES_HI & val) >> 10;
+    volt = data2volt(data);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", volt);
+}
+
+static ssize_t pvt_show_voltage(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    int data, volt;
+    mutex_lock(&hwmon->lock);
+    switch_pvt_mod(hwmon->pvt_id , BK_PVT_CTRL_VMOD);
+    data = read_valid_datareg(hwmon);
+    /* Don't change the order of multiplication!!! */
+    volt = data2volt(data);
+    hwmon->volt = volt;
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", volt);
+}
+
+static ssize_t lvt_show(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    int data;
+    mutex_lock(&hwmon->lock);
+    switch_pvt_mod(hwmon->pvt_id , BK_PVT_CTRL_LVTMOD);
+    data = read_valid_datareg(hwmon);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t hvt_show(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    int data;
+    mutex_lock(&hwmon->lock);
+    switch_pvt_mod(hwmon->pvt_id , BK_PVT_CTRL_HVTMOD);
+    data = read_valid_datareg(hwmon);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t svt_show(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct pvt_hwmon *hwmon = dev_get_drvdata(dev);
+    int data;
+    mutex_lock(&hwmon->lock);
+    switch_pvt_mod(hwmon->pvt_id , BK_PVT_CTRL_SVTMOD);
+    data = read_valid_datareg(hwmon);
+    mutex_unlock(&hwmon->lock);
+    return sprintf(buf, "%d\n", data);
+}
+
+
+static DEVICE_ATTR(name, S_IRUGO, pvt_show_name, NULL);
+static DEVICE_ATTR(temp1_input, S_IRUGO, pvt_show_temp, NULL);
+static DEVICE_ATTR(in1_input, S_IRUGO, pvt_show_voltage, NULL);
+static DEVICE_ATTR(lvt_input, S_IRUGO, lvt_show, NULL);
+static DEVICE_ATTR(hvt_input, S_IRUGO, hvt_show, NULL);
+static DEVICE_ATTR(svt_input, S_IRUGO, svt_show, NULL);
+static DEVICE_ATTR(temp1_min, S_IWUSR | S_IRUGO, pvt_show_temp_min, set_temp_min);
+static DEVICE_ATTR(temp1_max, S_IWUSR | S_IRUGO, pvt_show_temp_max, set_temp_max);
+static DEVICE_ATTR(in1_min, S_IWUSR | S_IRUGO, pvt_show_volt_min, set_volt_min);
+static DEVICE_ATTR(in1_max, S_IWUSR | S_IRUGO, pvt_show_volt_max, set_volt_max);
+static DEVICE_ATTR(mon_mod, S_IWUSR | S_IRUGO, pvt_show_mon_mod, set_mon_mod);
+
+static struct attribute *pvt_attrs[] = {
+    &dev_attr_name.attr,
+    &dev_attr_temp1_input.attr,
+    &dev_attr_temp1_min.attr,
+    &dev_attr_temp1_max.attr,
+    &dev_attr_in1_input.attr,
+    &dev_attr_in1_min.attr,
+    &dev_attr_in1_max.attr,
+    &dev_attr_lvt_input.attr,
+    &dev_attr_hvt_input.attr,
+    &dev_attr_svt_input.attr,
+    &dev_attr_mon_mod.attr,
+    NULL
+};
+
+static const struct attribute_group pvt_attr_group = {
+    .attrs = pvt_attrs,
+};
+
+
+static int pvt_probe(struct platform_device *pdev)
+{
+    int ret;
+    unsigned int val, data;
+    struct pvt_hwmon *hwmon;
+    struct resource *mem;
+
+    pr_debug("driver pvt_probe\n");
+    hwmon = devm_kzalloc(&pdev->dev, sizeof(*hwmon), GFP_KERNEL);
+    if (!hwmon)
+        return -ENOMEM;
+
+    mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    hwmon->base = (int)mem->start;//devm_ioremap_resource(&pdev->dev, mem);
+
+    /* Set PVT ID for secure monitor calls */
+    device_property_read_u32(&pdev->dev, "pvt_id", &(hwmon->pvt_id));
+
+    hwmon->cell = mfd_get_cell(pdev);
+    hwmon->irq = platform_get_irq(pdev, 0);
+
+    if (hwmon->irq < 0) {
+        dev_err(&pdev->dev, "Failed to get platform irq: %d\n",
+            hwmon->irq);
+        return hwmon->irq;
+    }
+
+    init_completion(&hwmon->read_completion);
+    mutex_init(&hwmon->lock);
+
+    //Mask all interupts except TTRES_HILO
+    writel_pvt(BK_PVT_INTR_MASK_TVONLY, hwmon->pvt_id , BK_PVT_INTR_MASK);
+    pr_debug("pvt_probe BK_PVT_INTR_MASK %x\n", readl_pvt(hwmon->pvt_id , BK_PVT_INTR_MASK));
+
+    //Set timeout of PVT measurment
+    writel_pvt(BK_PVT_TTIMEOUT_SET, hwmon->pvt_id , BK_PVT_TTIMEOUT);
+    pr_debug("pvt_probe BK_PVT_TTIMEOUT %d\n",readl_pvt(hwmon->pvt_id , BK_PVT_TTIMEOUT));
+
+
+    platform_set_drvdata(pdev, hwmon);
+    ret = devm_request_irq(&pdev->dev, hwmon->irq, pvt_hwmon_irq, 0,
+                   pdev->name, hwmon);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to request irq: %d\n", ret);
+        return ret;
+    }
+
+    ret = sysfs_create_group(&pdev->dev.kobj, &pvt_attr_group);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create sysfs group: %d\n", ret);
+        return ret;
+    }
+
+    hwmon->hwmon = hwmon_device_register_with_info(&pdev->dev, pdev->name,
+						   hwmon, NULL, NULL);
+    if (IS_ERR(hwmon->hwmon)) {
+        ret = PTR_ERR(hwmon->hwmon);
+        goto err_remove_file;
+    }
+    //Set WARN temperature
+    mutex_lock(&hwmon->lock);
+    data = readl_pvt(hwmon->pvt_id , BK_PVT_TTHRES);
+    val = temp2data(TEMP_PVT_WARN);
+    data = ( (val<<10) & BK_PVT_THRES_HI) + (BK_PVT_THRES_LO & data);
+    writel_pvt( data, hwmon->pvt_id , BK_PVT_TTHRES);
+    mutex_unlock(&hwmon->lock);
+    //Set Monitoring mod for temperature
+    hwmon->mon_mod = 0;
+    switch_to_mon_mod(hwmon);
+    pr_debug("pvt_probe hwmon_device_register %d\n",ret);
+    return 0;
+
+err_remove_file:
+    sysfs_remove_group(&pdev->dev.kobj, &pvt_attr_group);
+    return ret;
+}
+
+static int pvt_remove(struct platform_device *pdev)
+{
+    struct pvt_hwmon *hwmon = platform_get_drvdata(pdev);
+    hwmon_device_unregister(hwmon->hwmon);
+    sysfs_remove_group(&pdev->dev.kobj, &pvt_attr_group);
+    return 0;
+}
+
+static const struct of_device_id pvt_dt_match[] = {
+    { .compatible = "baikal,pvt" },
+    { },
+};
+
+static struct platform_driver pvt_hwmon_driver = {
+    .probe	  = pvt_probe,
+    .remove	  = pvt_remove,
+    .driver = {
+        .name = "pvt-hwmon",
+        .of_match_table = of_match_ptr(pvt_dt_match),
+    },
+};
+
+module_platform_driver(pvt_hwmon_driver);
+
+MODULE_DESCRIPTION("PVT BAIKAL driver");
+MODULE_AUTHOR("Maxim Kaurkin <maxim.kaurkin@baikalelectronics.ru>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pvt-hwmon");
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 2d08a8719..92805572b 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -437,6 +437,9 @@ config I2C_AXXIA
 	  255 bytes in length. Any attempt to to a larger transfer will return
 	  an error.
 
+config I2C_BAIKAL_SMBUS
+	tristate "Baikal-M SoC SMBus interface"
+
 config I2C_BCM2835
 	tristate "Broadcom BCM2835 I2C controller"
 	depends on ARCH_BCM2835 || ARCH_BRCMSTB
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 3ab8aebc3..f926b21e1 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -42,6 +42,7 @@ ifeq ($(CONFIG_I2C_AT91_SLAVE_EXPERIMENTAL),y)
 endif
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_AXXIA)		+= i2c-axxia.o
+obj-$(CONFIG_I2C_BAIKAL_SMBUS)	+= i2c-baikal-smbus.o
 obj-$(CONFIG_I2C_BCM2835)	+= i2c-bcm2835.o
 obj-$(CONFIG_I2C_BCM_IPROC)	+= i2c-bcm-iproc.o
 obj-$(CONFIG_I2C_CADENCE)	+= i2c-cadence.o
diff --git a/drivers/i2c/busses/i2c-baikal-smbus.c b/drivers/i2c/busses/i2c-baikal-smbus.c
new file mode 100644
index 000000000..3de14f40a
--- /dev/null
+++ b/drivers/i2c/busses/i2c-baikal-smbus.c
@@ -0,0 +1,487 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SMBus adapter driver for Baikal SoC
+ *
+ * Copyright (C) 2019-2021 Baikal Electronics, JSC
+ * Authors: Georgy Vlasov <georgy.vlasov@baikalelectronics.ru>
+ *	    Mikhail Ivanov <michail.ivanov@baikalelectronics.ru>
+ */
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+/* Register definitions */
+#define BE_SMBUS_CR1		0x00
+#define BE_CR1_IRT		BIT(0)
+#define BE_CR1_TRS		BIT(1)
+#define BE_CR1_IEB		BIT(3)
+
+#define BE_SMBUS_CR2		0x04
+#define BE_CR2_FTE		BIT(1)
+
+#define BE_SMBUS_FBCR1		0x08
+#define BE_SMBUS_FIFO		0x0c
+#define BE_SMBUS_SCD1		0x10
+
+#define BE_SMBUS_SCD2		0x14
+#define BE_SCD2_MASK		0x03
+#define BE_SCD2_SHT		BIT(7)
+
+#define BE_SMBUS_ADR1		0x18
+
+#define BE_SMBUS_ISR1		0x20
+#define BE_ISR1_MASK		0x7f
+#define BE_ISR1_FER		BIT(2)
+#define BE_ISR1_RNK		BIT(3)
+#define BE_ISR1_ALD		BIT(4)
+#define BE_ISR1_TCS		BIT(6)
+
+#define BE_SMBUS_IMR1		0x24
+#define BE_SMBUS_FBCR2		0x2c
+#define BE_SMBUS_IMR2		0x48
+
+#define BE_SMBUS_FIFO_SIZE	16
+
+struct be_smbus_dev {
+	struct device		*dev;
+	void __iomem		*base;
+	struct clk		*smbus_clk;
+	struct i2c_adapter	adapter;
+	u32			bus_clk_rate;
+	u64			smbus_clk_rate;
+};
+
+static int be_smbus_init(struct be_smbus_dev *besmb)
+{
+	u32 divider = (besmb->smbus_clk_rate == 0 ?
+		clk_get_rate(besmb->smbus_clk) :
+		besmb->smbus_clk_rate) / besmb->bus_clk_rate - 1;
+
+	writel(BE_CR1_IRT, besmb->base + BE_SMBUS_CR1);
+	writel(0, besmb->base + BE_SMBUS_CR1);
+	writel(0, besmb->base + BE_SMBUS_CR2);
+	writel(0, besmb->base + BE_SMBUS_FBCR2);
+	writel(0, besmb->base + BE_SMBUS_IMR1);
+	writel(0, besmb->base + BE_SMBUS_IMR2);
+	writel(divider & 0xff, besmb->base + BE_SMBUS_SCD1);
+	writel(BE_SCD2_SHT | ((divider >> 8) & BE_SCD2_MASK),
+		besmb->base + BE_SMBUS_SCD2);
+
+	return 0;
+}
+
+static int be_smbus_xfer(struct i2c_adapter *adap, u16 addr,
+			unsigned short flags, char read_write,
+			u8 command, int size, union i2c_smbus_data *data)
+{
+	struct be_smbus_dev *const besmb = adap->dev.driver_data;
+	int ret = -EINVAL;
+
+	switch (size) {
+	case I2C_SMBUS_BYTE:
+		writel(BE_CR1_IRT, besmb->base + BE_SMBUS_CR1);
+		writel(0, besmb->base + BE_SMBUS_CR1);
+		writel(addr, besmb->base + BE_SMBUS_ADR1);
+		writel(1, besmb->base + BE_SMBUS_FBCR1);
+
+		if (read_write == I2C_SMBUS_WRITE) {
+			writel(BE_CR1_TRS | BE_CR1_IEB,
+				besmb->base + BE_SMBUS_CR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+		} else {
+			writel(BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+		}
+
+		writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+		writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+		while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+			!(readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+		if (readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_ALD | BE_ISR1_RNK)) {
+			ret = -ENXIO;
+			goto exit;
+		}
+
+		if (read_write == I2C_SMBUS_READ) {
+			data->byte = readl(besmb->base + BE_SMBUS_FIFO);
+
+			if (readl(besmb->base + BE_SMBUS_ISR1) & BE_ISR1_FER) {
+				ret = -EMSGSIZE;
+				goto exit;
+			}
+		}
+
+		ret = 0;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		writel(BE_CR1_IRT, besmb->base + BE_SMBUS_CR1);
+		writel(0, besmb->base + BE_SMBUS_CR1);
+		writel(addr, besmb->base + BE_SMBUS_ADR1);
+		writel(BE_CR1_TRS | BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+
+		if (read_write == I2C_SMBUS_WRITE) {
+			writel(2, besmb->base + BE_SMBUS_FBCR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+			writel(data->byte, besmb->base + BE_SMBUS_FIFO);
+		} else {
+			writel(1, besmb->base + BE_SMBUS_FBCR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+		}
+
+		writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+		writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+		while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+			!(readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+		if (readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_ALD | BE_ISR1_RNK)) {
+			ret = -ENXIO;
+			goto exit;
+		}
+
+		if (read_write == I2C_SMBUS_READ) {
+			writel(BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+			writel(1, besmb->base + BE_SMBUS_FBCR1);
+			writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+			writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+			while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+				!(readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+			if (readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_ALD | BE_ISR1_RNK)) {
+				ret = -ENXIO;
+				goto exit;
+			}
+
+			data->byte = readl(besmb->base + BE_SMBUS_FIFO);
+			if (readl(besmb->base + BE_SMBUS_ISR1) & BE_ISR1_FER) {
+				ret = -EMSGSIZE;
+				goto exit;
+			}
+		}
+
+		ret = 0;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		writel(BE_CR1_IRT, besmb->base + BE_SMBUS_CR1);
+		writel(0, besmb->base + BE_SMBUS_CR1);
+		writel(addr, besmb->base + BE_SMBUS_ADR1);
+		writel(BE_CR1_TRS | BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+
+		if (read_write == I2C_SMBUS_WRITE) {
+			writel(3, besmb->base + BE_SMBUS_FBCR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+			writel((data->word >> 0) & 0xff,
+				besmb->base + BE_SMBUS_FIFO);
+			writel((data->word >> 8) & 0xff,
+				besmb->base + BE_SMBUS_FIFO);
+		} else {
+			writel(1, besmb->base + BE_SMBUS_FBCR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+		}
+
+		writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+		writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+		while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+			!(readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+		if (readl(besmb->base + BE_SMBUS_ISR1) &
+				(BE_ISR1_ALD | BE_ISR1_RNK)) {
+			ret = -ENXIO;
+			goto exit;
+		}
+
+		if (read_write == I2C_SMBUS_READ) {
+			writel(BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+			writel(2, besmb->base + BE_SMBUS_FBCR1);
+			writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+			writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+			while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+				!(readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+			if (readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_ALD| BE_ISR1_RNK)) {
+				ret = -ENXIO;
+				goto exit;
+			}
+
+			data->word  = readl(besmb->base + BE_SMBUS_FIFO);
+			data->word |= readl(besmb->base + BE_SMBUS_FIFO) << 8;
+			if (readl(besmb->base + BE_SMBUS_ISR1) & BE_ISR1_FER) {
+				ret = -EMSGSIZE;
+				goto exit;
+			}
+		}
+
+		ret = 0;
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		writel(BE_CR1_IRT, besmb->base + BE_SMBUS_CR1);
+		writel(0, besmb->base + BE_SMBUS_CR1);
+		writel(addr, besmb->base + BE_SMBUS_ADR1);
+		writel(BE_CR1_TRS | BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+
+		if (read_write == I2C_SMBUS_WRITE) {
+			unsigned txedsize = 0;
+
+			while (txedsize < data->block[0] + 1) {
+				unsigned xblocknum;
+				unsigned xfersize;
+
+				xfersize = data->block[0] + 1 - txedsize;
+				if (xfersize > BE_SMBUS_FIFO_SIZE) {
+					xfersize = BE_SMBUS_FIFO_SIZE;
+				}
+
+				writel(xfersize, besmb->base + BE_SMBUS_FBCR1);
+				if (!txedsize) {
+					/*
+					 * The first xfer should start with
+					 * command byte
+					 */
+					writel(command,
+						besmb->base + BE_SMBUS_FIFO);
+					xblocknum = 1;
+					++txedsize;
+				} else {
+					xblocknum = 0;
+				}
+
+				while (xblocknum < xfersize) {
+					writel(data->block[txedsize++],
+						besmb->base + BE_SMBUS_FIFO);
+					++xblocknum;
+				}
+
+				writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+				writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+				while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+					!(readl(besmb->base + BE_SMBUS_ISR1) &
+						(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+				if (readl(besmb->base + BE_SMBUS_ISR1) &
+						(BE_ISR1_ALD | BE_ISR1_RNK)) {
+					ret = -ENXIO;
+					goto exit;
+				}
+			}
+		} else {
+			unsigned rxedsize = 0;
+
+			writel(1, besmb->base + BE_SMBUS_FBCR1);
+			writel(command, besmb->base + BE_SMBUS_FIFO);
+			writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+			writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+			while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+				!(readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+			if (readl(besmb->base + BE_SMBUS_ISR1) &
+					(BE_ISR1_ALD | BE_ISR1_RNK)) {
+				ret = -ENXIO;
+				goto exit;
+			}
+
+			writel(BE_CR1_IEB, besmb->base + BE_SMBUS_CR1);
+
+			while (rxedsize < I2C_SMBUS_BLOCK_MAX) {
+				unsigned i;
+
+				writel(BE_SMBUS_FIFO_SIZE, besmb->base + BE_SMBUS_FBCR1);
+				writel(BE_ISR1_MASK, besmb->base + BE_SMBUS_ISR1);
+				writel(BE_CR2_FTE, besmb->base + BE_SMBUS_CR2);
+
+				while ((readl(besmb->base + BE_SMBUS_CR2) & BE_CR2_FTE) &&
+					!(readl(besmb->base + BE_SMBUS_ISR1) &
+						(BE_ISR1_TCS | BE_ISR1_ALD | BE_ISR1_RNK)));
+
+				if (readl(besmb->base + BE_SMBUS_ISR1) &
+						(BE_ISR1_ALD | BE_ISR1_RNK)) {
+					ret = -ENXIO;
+					goto exit;
+				}
+
+				for (i = 0; i < BE_SMBUS_FIFO_SIZE; ++i) {
+					data->block[1 + rxedsize++] =
+						readl(besmb->base + BE_SMBUS_FIFO);
+
+					if (readl(besmb->base + BE_SMBUS_ISR1) &
+							BE_ISR1_FER) {
+						ret = -EMSGSIZE;
+						goto exit;
+					}
+				}
+			}
+
+			data->block[0] = rxedsize;
+		}
+
+		ret = 0;
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+exit:
+	writel(0, besmb->base + BE_SMBUS_CR1);
+	return ret;
+}
+
+static u32 be_functionality(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_DATA;
+}
+
+static const struct i2c_algorithm be_smbus_algorithm = {
+	.smbus_xfer	= be_smbus_xfer,
+	.functionality	= be_functionality,
+};
+
+static irqreturn_t be_smbus_isr(int irq, void *_dev)
+{
+	return IRQ_HANDLED;
+}
+
+static int be_smbus_probe(struct platform_device *pdev)
+{
+	struct be_smbus_dev *besmb;
+	void __iomem *base;
+	int irq;
+	int ret;
+
+	besmb = devm_kzalloc(&pdev->dev, sizeof(*besmb), GFP_KERNEL);
+	if (besmb == NULL) {
+		return -ENOMEM;
+	}
+
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(base)) {
+		return PTR_ERR(base);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "missing interrupt resource\n");
+		return irq;
+	}
+
+	if (dev_of_node(&pdev->dev)) {
+		besmb->smbus_clk = devm_clk_get(&pdev->dev, NULL);
+		if (IS_ERR(besmb->smbus_clk)) {
+			dev_err(&pdev->dev, "missing clock\n");
+			return PTR_ERR(besmb->smbus_clk);
+		}
+
+		ret = clk_prepare_enable(besmb->smbus_clk);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable clock\n");
+			return ret;
+		}
+
+		besmb->smbus_clk_rate = 0;
+#ifdef CONFIG_ACPI
+	} else if (to_acpi_device_node(pdev->dev.fwnode) &&
+			acpi_evaluate_integer (to_acpi_device_node(pdev->dev.fwnode)->handle,
+				"CLK", NULL, &besmb->smbus_clk_rate)) {
+		dev_err(&pdev->dev, "missing clock-frequency value\n");
+		return -EINVAL;
+#endif
+	}
+
+	besmb->base = base;
+	besmb->dev = &pdev->dev;
+
+	device_property_read_u32(&pdev->dev, "clock-frequency", &besmb->bus_clk_rate);
+	if (!besmb->bus_clk_rate) {
+		besmb->bus_clk_rate = 100000; /* default clock rate */
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, be_smbus_isr, 0, pdev->name, besmb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to claim IRQ%d\n", irq);
+		return ret;
+	}
+
+	i2c_set_adapdata(&besmb->adapter, besmb);
+	strlcpy(besmb->adapter.name, pdev->name, sizeof(besmb->adapter.name));
+	besmb->adapter.owner = THIS_MODULE;
+	besmb->adapter.algo = &be_smbus_algorithm;
+	besmb->adapter.dev.parent = &pdev->dev;
+	if (dev_of_node(&pdev->dev)) {
+		besmb->adapter.dev.of_node = pdev->dev.of_node;
+	} else {
+		besmb->adapter.dev.fwnode = pdev->dev.fwnode;
+	}
+
+	platform_set_drvdata(pdev, besmb);
+
+	ret = be_smbus_init(besmb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to init SMBus\n");
+		goto err_clk;
+	}
+
+	ret = i2c_add_adapter(&besmb->adapter);
+	if (ret) {
+		goto err_clk;
+	}
+
+	return 0;
+
+err_clk:
+	if (dev_of_node(&pdev->dev)) {
+		clk_disable_unprepare(besmb->smbus_clk);
+	}
+
+	return ret;
+}
+
+static int be_smbus_remove(struct platform_device *pdev)
+{
+	struct be_smbus_dev *besmb = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(besmb->smbus_clk);
+	i2c_del_adapter(&besmb->adapter);
+
+	return 0;
+}
+
+static const struct of_device_id be_smbus_match[] = {
+	{ .compatible = "be,smbus" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, be_smbus_match);
+
+static struct platform_driver be_smbus_driver = {
+	.driver = {
+		.name = "baikal-smbus",
+		.of_match_table = be_smbus_match
+	},
+	.probe  = be_smbus_probe,
+	.remove = be_smbus_remove
+};
+
+module_platform_driver(be_smbus_driver);
+
+MODULE_AUTHOR("Georgy Vlasov <georgy.vlasov@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal-M SMBus adapter driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c55b63750..4fa08a441 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -466,6 +466,23 @@ config PVPANIC
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config TP_BMC
+	tristate "T-platforms Baikal-T(1)/M BMC"
+	depends on I2C && SYSFS
+	depends on OF
+	select PINCTRL
+	select GENERIC_PINCONF
+	select SERIO
+	help
+	  Say Y here if you want to build a driver for T-platforms BMC devices
+	  embedded into the boards with Baikal-T(1)/M processors. The device main
+	  purpose is the CPU kick-starting as well as some additional side-way
+	  functionality like power on/off buttons state tracing and full device
+	  powering off.
+
+	  If you choose to build module, its name will be tp-bt-bmc. If unsure,
+	  say N here.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c1860d35d..09c78743e 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -57,3 +57,4 @@ obj-y				+= cardreader/
 obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_TP_BMC)		+= tp_bmc.o
diff --git a/drivers/misc/tp_bmc.c b/drivers/misc/tp_bmc.c
new file mode 100644
index 000000000..0b320d3ff
--- /dev/null
+++ b/drivers/misc/tp_bmc.c
@@ -0,0 +1,747 @@
+#include <linux/i2c.h>
+#include <linux/bcd.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/input.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/pm.h>
+#include <linux/rtc.h>
+#include <linux/serio.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+
+enum I2C_REGS {
+	R_ID1 = 0,
+	R_ID2,
+	R_ID3,
+	R_ID4,
+	R_SOFTOFF_RQ,
+	R_PWROFF_RQ,
+	R_PWRBTN_STATE,
+	R_VERSION1,
+	R_VERSION2,
+	R_BOOTREASON,
+	R_BOOTREASON_ARG,
+	R_SCRATCH1,
+	R_SCRATCH2,
+	R_SCRATCH3,
+	R_SCRATCH4,
+	R_CAP,
+	R_GPIODIR0,
+	R_GPIODIR1,
+	R_GPIODIR2,
+	R_COUNT
+};
+
+#define BMC_ID1_VAL 0x49
+#define BMC_ID2_VAL 0x54
+#define BMC_ID3_VAL 0x58
+#define BMC_ID4_VAL0 0x32
+#define BMC_ID4_VAL1 0x2
+
+#define BMC_VERSION1	0
+#define BMC_VERSION2	2
+#define BMC_VERSION2_3	3
+
+#define BMC_CAP_PWRBTN		0x1
+#define BMC_CAP_TOUCHPAD	0x2
+#define BMC_CAP_RTC		0x4
+#define BMC_CAP_FRU		0x8
+#define BMC_CAP_GPIODIR		0x10
+
+#define BMC_SERIO_BUFSIZE	7
+
+#define POLL_JIFFIES 100
+
+struct bmc_poll_data {
+	struct i2c_client *c;
+};
+
+static struct i2c_client *bmc_i2c;
+static struct i2c_client *rtc_i2c;
+static struct i2c_driver mitx2_bmc_i2c_driver;
+static struct input_dev *button_dev;
+static struct bmc_poll_data poll_data;
+static struct task_struct *polling_task;
+#ifdef CONFIG_SERIO
+static struct i2c_client *serio_i2c;
+static struct task_struct *touchpad_task;
+#endif
+static u8 bmc_proto_version[3];
+static u8 bmc_bootreason[2];
+static u8 bmc_scratch[4];
+static int bmc_cap;
+static const char input_name[] = "BMC input dev";
+static u8 prev_ret;
+
+/* BMC RTC */
+static int
+bmc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	uint8_t rtc_buf[8];
+	struct i2c_msg msg;
+	int t;
+	int rc;
+
+	msg.addr = client->addr;
+	msg.flags = I2C_M_RD;
+	msg.len = 8;
+	msg.buf = rtc_buf;
+	rc = i2c_transfer(client->adapter, &msg, 1);
+	if (rc != 1) {
+		dev_err(dev, "rtc_read_time: i2c_transfer error %d\n", rc);
+		return rc;
+	}
+
+	tm->tm_sec = bcd2bin(rtc_buf[0] & 0x7f);
+	tm->tm_min = bcd2bin(rtc_buf[1] & 0x7f);
+	tm->tm_hour = bcd2bin(rtc_buf[2] & 0x3f);
+	if (rtc_buf[3] & (1 << 6)) /* PM */
+		tm->tm_hour += 12;
+	tm->tm_mday  = bcd2bin(rtc_buf[4] & 0x3f);
+	tm->tm_mon = bcd2bin(rtc_buf[5] & 0x1f);
+	t = rtc_buf[5] >> 5;
+	tm->tm_wday = (t == 7) ? 0 : t;
+	tm->tm_year = bcd2bin(rtc_buf[6]) + 100; /* year since 1900 */
+	tm->tm_yday = rtc_year_days(tm->tm_mday, tm->tm_mon, tm->tm_year);
+	tm->tm_isdst = 0;
+
+	return rtc_valid_tm(tm);
+}
+
+static int
+bmc_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	uint8_t rtc_buf[8];
+	struct i2c_msg msg;
+	int rc;
+	uint8_t seconds, minutes, hours, wday, mday, month, years;
+
+	seconds = bin2bcd(tm->tm_sec);
+	minutes = bin2bcd(tm->tm_min);
+	hours = bin2bcd(tm->tm_hour);
+	wday = tm->tm_wday ? tm->tm_wday : 0x7;
+	mday = bin2bcd(tm->tm_mday);
+	month = bin2bcd(tm->tm_mon);
+	years = bin2bcd(tm->tm_year % 100);
+
+	/* Need sanity check??? */
+	rtc_buf[0] = seconds;
+	rtc_buf[1] = minutes;
+	rtc_buf[2] = hours;
+	rtc_buf[3] = 0;
+	rtc_buf[4] = mday;
+	rtc_buf[5] = month | (wday << 5);
+	rtc_buf[6] = years;
+	rtc_buf[7] = 0;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 8;
+	msg.buf = rtc_buf;
+	dev_dbg(dev, "rtc_set_time: %08x-%08x\n", *(uint32_t *)&rtc_buf[0],
+		*(uint32_t *)&rtc_buf[4]);
+	rc = i2c_transfer(client->adapter, &msg, 1);
+	if (rc != 1)
+		dev_err(dev, "i2c write: %d\n", rc);
+
+	return (rc == 1) ? 0 : -EIO;
+}
+
+static const struct rtc_class_ops
+bmc_rtc_ops = {
+	.read_time = bmc_rtc_read_time,
+	.set_time = bmc_rtc_set_time,
+};
+
+#ifdef CONFIG_SERIO
+/* BMC serio (PS/2 touchpad) interface */
+
+static int bmc_serio_write(struct serio *id, unsigned char val)
+{
+	struct i2c_client *client = id->port_data;
+	uint8_t buf[4];
+	struct i2c_msg msg;
+	int rc;
+
+	buf[0] = val;
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 1;
+	msg.buf = buf;
+	dev_dbg(&client->dev, "bmc_serio_write: %02x\n", val);
+	rc = i2c_transfer(client->adapter, &msg, 1);
+	if (rc != 1)
+		dev_err(&client->dev, "i2c write: %d\n", rc);
+
+	return (rc == 1) ? 0 : -EIO;
+}
+
+/* returns: -1 on error, +1 if more data available, 0 otherwise */
+static int bmc_serio_read(struct i2c_client *client)
+{
+	struct serio *serio = dev_get_drvdata(&client->dev);
+	int i, rc, cnt;
+	uint8_t buf[BMC_SERIO_BUFSIZE];
+	struct i2c_msg msg;
+
+	msg.addr = client->addr;
+	msg.flags = I2C_M_RD;
+	msg.len = BMC_SERIO_BUFSIZE;
+	msg.buf = buf;
+	rc = i2c_transfer(client->adapter, &msg, 1);
+	if (rc != 1) {
+		dev_err(&client->dev, "bmc_serio_read: i2c_transfer error %d\n", rc);
+		return -1;
+	}
+
+	cnt = buf[0];
+	rc = 0;
+	if (cnt > BMC_SERIO_BUFSIZE - 1) {
+		cnt = BMC_SERIO_BUFSIZE - 1;
+		rc = 1;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		serio_interrupt(serio, buf[i + 1], 0);
+	}
+
+	return 0;
+}
+
+int
+touchpad_poll_fn(void *data) {
+	int ret;
+
+	while (1) {
+		if (kthread_should_stop())
+			break;
+		while ((ret = bmc_serio_read(serio_i2c)) > 0)
+			;
+		if (ret < 0) {
+			msleep_interruptible(10000);
+		}
+		msleep_interruptible(10);
+	}
+	return 0;
+}
+#endif /* CONFIG_SERIO */
+
+#ifdef CONFIG_PINCTRL
+static uint8_t bmc_pincf_state [3];
+#define BMC_NPINS	(sizeof(bmc_pincf_state) * 8)
+
+static struct pinctrl_pin_desc bmc_pin_desc[BMC_NPINS] = {
+	PINCTRL_PIN(0, "P0"),
+	PINCTRL_PIN(1, "P1"),
+	PINCTRL_PIN(2, "P2"),
+	PINCTRL_PIN(3, "P3"),
+	PINCTRL_PIN(4, "P4"),
+	PINCTRL_PIN(5, "P5"),
+	PINCTRL_PIN(6, "P6"),
+	PINCTRL_PIN(7, "P7"),
+	PINCTRL_PIN(8, "P8"),
+	PINCTRL_PIN(9, "P9"),
+	PINCTRL_PIN(10, "P10"),
+	PINCTRL_PIN(11, "P11"),
+	PINCTRL_PIN(12, "P12"),
+	PINCTRL_PIN(13, "P13"),
+	PINCTRL_PIN(14, "P14"),
+	PINCTRL_PIN(15, "P15"),
+	PINCTRL_PIN(16, "P16"),
+	PINCTRL_PIN(17, "P17"),
+	PINCTRL_PIN(18, "P18"),
+	PINCTRL_PIN(19, "P19"),
+	PINCTRL_PIN(20, "P20"),
+	PINCTRL_PIN(21, "P21"),
+	PINCTRL_PIN(22, "P22"),
+	PINCTRL_PIN(23, "P23"),
+};
+
+#define PCTRL_DEV	"bmc_pinctrl"
+
+static int bmc_pin_config_get(struct pinctrl_dev *pctldev,
+			      unsigned pin,
+			      unsigned long *config)
+{
+	int idx, bit;
+
+	if (pin > BMC_NPINS)
+		return -EINVAL;
+
+	idx = pin >> 3;
+	bit = pin & 7;
+
+	*config = !!(bmc_pincf_state[idx] & (1 << bit));
+	return 0;
+}
+
+static int bmc_pin_config_set(struct pinctrl_dev *pctldev,
+			      unsigned pin,
+			      unsigned long *config,
+			      unsigned nc)
+{
+	int idx, bit;
+	enum pin_config_param param;
+	int arg;
+
+	if (pin > BMC_NPINS)
+		return -EINVAL;
+
+	idx = pin >> 3;
+	bit = pin & 7;
+
+	param = pinconf_to_config_param (*config);
+	arg = pinconf_to_config_argument (*config);
+	if (param != PIN_CONFIG_OUTPUT)
+		return -EINVAL;
+
+	if (arg)
+		bmc_pincf_state[idx] |= (1 << bit);
+	else
+		bmc_pincf_state[idx] &= ~(1 << bit);
+dev_dbg(&bmc_i2c->dev, "bmc_pin_config_set: pin %u, dir %lu\n", pin, *config);
+
+	return i2c_smbus_write_byte_data(bmc_i2c, R_GPIODIR0 + idx, bmc_pincf_state[idx]);
+}
+
+void pinconf_generic_dump_config(struct pinctrl_dev *pctldev,
+				 struct seq_file *s, unsigned long config);
+
+void pinctrl_utils_free_map(struct pinctrl_dev *pctldev,
+			    struct pinctrl_map *map, unsigned num_maps);
+
+static const struct pinconf_ops bmc_confops = {
+	.pin_config_get = bmc_pin_config_get,
+	.pin_config_set = bmc_pin_config_set,
+	.pin_config_config_dbg_show = pinconf_generic_dump_config,
+};
+
+static int bmc_groups_count(struct pinctrl_dev *pctldev)
+{
+	return 0;
+}
+
+static const char *bmc_group_name(struct pinctrl_dev *pctldev,
+				   unsigned selector)
+{
+	return NULL;
+}
+
+static const struct pinctrl_ops bmc_ctrl_ops = {
+	.get_groups_count = bmc_groups_count,
+	.get_group_name = bmc_group_name,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+static struct pinctrl_desc bmc_pincrtl_desc = {
+	.name = PCTRL_DEV,
+	.pins = bmc_pin_desc,
+	.pctlops = &bmc_ctrl_ops,
+	.npins = BMC_NPINS,
+	.confops = &bmc_confops,
+};
+
+static struct pinctrl_dev *bmc_pinctrl_dev;
+
+static int bmc_pinctrl_register(struct device *dev)
+{
+	struct pinctrl_dev *pctrl_dev;
+	struct platform_device *pbdev;
+
+	pbdev = platform_device_alloc(PCTRL_DEV, -1);
+	pbdev->dev.parent = dev;
+	pbdev->dev.of_node = of_find_node_by_name(dev->of_node, "bmc_pinctrl");
+	platform_device_add(pbdev);
+	pctrl_dev = devm_pinctrl_register(&pbdev->dev, &bmc_pincrtl_desc, NULL);
+	if (IS_ERR(pctrl_dev)) {
+		dev_err(&pbdev->dev, "Can't register pinctrl (%ld)\n", PTR_ERR(pctrl_dev));
+		return PTR_ERR(pctrl_dev);
+	} else {
+		dev_info(&pbdev->dev, "BMC pinctrl registered\n");
+		bmc_pinctrl_dev = pctrl_dev;
+	}
+	/* reset all pins to default state */
+	i2c_smbus_write_byte_data(to_i2c_client(dev), R_GPIODIR0, 0);
+	i2c_smbus_write_byte_data(to_i2c_client(dev), R_GPIODIR1, 0);
+	i2c_smbus_write_byte_data(to_i2c_client(dev), R_GPIODIR2, 0);
+	return 0;
+}
+
+static void bmc_pinctrl_unregister(void)
+{
+	if (bmc_pinctrl_dev)
+		devm_pinctrl_unregister(&bmc_i2c->dev, bmc_pinctrl_dev);
+}
+
+#endif
+
+void
+bmc_pwroff_rq(void) {
+	int ret = 0;
+
+	dev_info(&bmc_i2c->dev, "Write reg R_PWROFF_RQ\n");
+	ret = i2c_smbus_write_byte_data(bmc_i2c, R_PWROFF_RQ, 0x01);
+	dev_info(&bmc_i2c->dev, "ret: %i\n", ret);
+}
+
+int
+pwroff_rq_poll_fn(void *data) {
+	int ret;
+
+	while (1) {
+		if (kthread_should_stop())
+			break;
+		dev_dbg(&poll_data.c->dev, "Polling\n");
+		ret = i2c_smbus_read_byte_data(poll_data.c, R_SOFTOFF_RQ);
+		dev_dbg(&poll_data.c->dev, "Polling returned: %i\n", ret);
+		if (prev_ret != ret) {
+			dev_info(&poll_data.c->dev, "key change [%i]\n", ret);
+			if (ret < 0) {
+				dev_err(&poll_data.c->dev,
+					"Could not read register %x\n",
+					R_SOFTOFF_RQ);
+				return -EIO;
+			} else if (ret != 0) {
+				dev_info(&poll_data.c->dev,
+					 "PWROFF \"irq\" detected [%i]\n", ret);
+				input_event(button_dev, EV_KEY, KEY_POWER, 1);
+			} else {
+				input_event(button_dev, EV_KEY, KEY_POWER, 0);
+			}
+			input_sync(button_dev);
+		}
+		prev_ret = ret;
+
+		msleep_interruptible(100);
+	}
+	do_exit(1);
+	return 0;
+}
+
+static int
+mitx2_bmc_validate(struct i2c_client *client) {
+	int ret = 0;
+	int i = 0;
+	static const u8 regs[] = {R_ID1, R_ID2, R_ID3};
+	static const u8 vals[] = {BMC_ID1_VAL, BMC_ID2_VAL, BMC_ID3_VAL};
+
+	bmc_proto_version[0] = 0;
+	bmc_proto_version[1] = 0;
+	bmc_proto_version[2] = 0;
+
+	for (i = 0; i < ARRAY_SIZE(regs); i++) {
+		ret = i2c_smbus_read_byte_data(client, regs[i]);
+		if (ret < 0) {
+			dev_err(&client->dev, "Could not read register %x\n",
+				regs[i]);
+			return -EIO;
+		}
+		if (ret != vals[i]) {
+			dev_err(&client->dev,
+				"Bad value [0x%02x] in register 0x%02x, should be [0x%02x]\n",
+				 ret, regs[i], vals[i]);
+
+			return -ENODEV;
+		}
+	}
+	ret = i2c_smbus_read_byte_data(client, R_ID4);
+	if (ret < 0) {
+		dev_err(&client->dev, "Could not read register %x\n", R_ID4);
+		return -EIO;
+	}
+	if (ret == BMC_ID4_VAL0) {
+		bmc_proto_version[0] = 0;
+	} else if (ret == BMC_ID4_VAL1) {
+		bmc_proto_version[0] = 2;
+		ret = i2c_smbus_read_byte_data(client, R_VERSION1);
+		if (ret < 0) {
+			dev_err(&client->dev, "Could not read register %x\n",
+				R_VERSION1);
+			return -EIO;
+		}
+		bmc_proto_version[1] = ret;
+		ret = i2c_smbus_read_byte_data(client, R_VERSION2);
+		if (ret < 0) {
+			dev_err(&client->dev, "Could not read register %x\n",
+				R_VERSION2);
+			return -EIO;
+		}
+		bmc_proto_version[2] = ret;
+		ret = i2c_smbus_read_byte_data(client, R_BOOTREASON);
+		if (ret < 0) {
+			dev_err(&client->dev, "Could not read register %x\n",
+				R_BOOTREASON);
+			return -EIO;
+		}
+		bmc_bootreason[0] = ret;
+		dev_info(&client->dev, "BMC bootreason[0]->%i\n", ret);
+		ret = i2c_smbus_read_byte_data(client, R_BOOTREASON_ARG);
+		if (ret < 0) {
+			dev_err(&client->dev, "Could not read register %x\n",
+				R_BOOTREASON_ARG);
+			return -EIO;
+		}
+		bmc_bootreason[1] = ret;
+		dev_info(&client->dev, "BMC bootreason[1]->%i\n", ret);
+		for (i = R_SCRATCH1; i <= R_SCRATCH4; i++) {
+			ret = i2c_smbus_read_byte_data(client, i);
+			if (ret < 0) {
+				dev_err(&client->dev,
+					"Could not read register %x\n", i);
+				return -EIO;
+			}
+			bmc_scratch[i - R_SCRATCH1] = ret;
+		}
+		if (bmc_proto_version[2] >= BMC_VERSION2_3) {
+			ret = i2c_smbus_read_byte_data(client, R_CAP);
+			if (ret >= 0)
+				bmc_cap = ret;
+			dev_info(&client->dev,
+				 "BMC extended capabilities %x\n", bmc_cap);
+		} else {
+			bmc_cap = BMC_CAP_PWRBTN;
+		}
+	} else {
+		dev_err(&client->dev, "Bad value [0x%02x] in register 0x%02x\n",
+			ret, R_ID4);
+		return -ENODEV;
+	}
+	dev_info(&client->dev, "BMC seems to be valid\n");
+	return 0;
+}
+
+static int
+bmc_create_client_devices(struct device *bmc_dev)
+{
+	int ret = 0;
+	struct rtc_device *rtc_dev;
+	struct i2c_client *client = to_i2c_client(bmc_dev);
+	int client_addr = client->addr + 1;
+
+	if (bmc_cap & BMC_CAP_TOUCHPAD) {
+#ifdef CONFIG_SERIO
+		struct serio *serio;
+		serio_i2c = i2c_new_ancillary_device(client,
+						     "bmc_serio", client_addr);
+		if (IS_ERR(serio_i2c)) {
+			dev_err(&client->dev, "Can't get serio secondary\n");
+			serio_i2c = NULL;
+			ret = -ENOMEM;
+			goto fail;
+		}
+		serio = devm_kzalloc(&serio_i2c->dev, sizeof(struct serio), GFP_KERNEL);
+		if (!serio) {
+			dev_err(&serio_i2c->dev, "Can't allocate serio\n");
+			ret = -ENOMEM;
+			i2c_unregister_device(serio_i2c);
+			serio_i2c = NULL;
+			goto skip_tp;
+		}
+		serio->write = bmc_serio_write;
+		serio->port_data = serio_i2c;
+		serio->id.type = SERIO_PS_PSTHRU;
+		serio_register_port(serio);
+		dev_set_drvdata(&serio_i2c->dev, serio);
+		touchpad_task = kthread_run(touchpad_poll_fn, NULL, "BMC serio poll task");
+
+skip_tp:
+#endif
+		client_addr++;
+	}
+
+	if (bmc_cap & BMC_CAP_RTC) {
+		rtc_i2c = i2c_new_ancillary_device(client,
+						   "bmc_rtc", client_addr);
+		if (IS_ERR(rtc_i2c)) {
+			dev_err(&client->dev, "Can't get RTC secondary\n");
+			rtc_i2c = NULL;
+			ret = -ENOMEM;
+			goto fail;
+		}
+
+		rtc_dev = devm_rtc_device_register(&rtc_i2c->dev, "bmc_rtc",
+						   &bmc_rtc_ops, THIS_MODULE);
+		if (IS_ERR(rtc_dev)) {
+			ret = PTR_ERR(rtc_dev);
+			dev_err(&client->dev, "Failed to register RTC device: %d\n",
+				ret);
+			i2c_unregister_device(rtc_i2c);
+			rtc_i2c = NULL;
+		}
+fail:
+		client_addr++;
+	}
+
+#ifdef CONFIG_PINCTRL
+	if (bmc_cap & BMC_CAP_GPIODIR || 1 /*vvv*/)
+		bmc_pinctrl_register(bmc_dev);
+#endif
+
+	return ret;
+}
+
+static int
+mitx2_bmc_i2c_probe(struct i2c_client *client,
+		    const struct i2c_device_id *id)
+{
+	int err = 0;
+	int i = 0;
+
+	dev_info(&client->dev, "mitx2 bmc probe\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	for (i = 0; i < 10; i++) {
+		err = mitx2_bmc_validate(client);
+		if (!err)
+			break;
+		msleep_interruptible(20);
+	}
+	if (err)
+		return err;
+
+	if (bmc_cap & BMC_CAP_PWRBTN) {
+		button_dev = input_allocate_device();
+		if (!button_dev) {
+			dev_err(&client->dev, "Not enough memory\n");
+			return -ENOMEM;
+		}
+
+		button_dev->id.bustype = BUS_I2C;
+		button_dev->dev.parent = &client->dev;
+		button_dev->name = input_name;
+		button_dev->phys = "bmc-input0";
+		button_dev->evbit[0] = BIT_MASK(EV_KEY);
+		button_dev->keybit[BIT_WORD(KEY_POWER)] = BIT_MASK(KEY_POWER);
+
+		err = input_register_device(button_dev);
+		if (err) {
+			dev_err(&client->dev, "Failed to register device\n");
+			input_free_device(button_dev);
+			return err;
+		}
+
+		dev_info(&client->dev, "Starting polling thread\n");
+		poll_data.c = client;
+		polling_task = kthread_run(pwroff_rq_poll_fn, NULL, "BMC poll task");
+	}
+
+	if (bmc_cap || 1 /*vvv*/)
+		err = bmc_create_client_devices(&client->dev);
+
+	bmc_i2c = client;
+	/* register as poweroff handler */
+	pm_power_off = bmc_pwroff_rq;
+
+	return 0;
+}
+
+static int
+mitx2_bmc_i2c_remove(struct i2c_client *client)
+{
+#ifdef CONFIG_SERIO
+	struct serio *serio;
+#endif
+
+	if (button_dev) {
+		kthread_stop(polling_task);
+		input_unregister_device(button_dev);
+	}
+#ifdef CONFIG_SERIO
+	if (serio_i2c) {
+		kthread_stop(touchpad_task);
+		serio = dev_get_drvdata(&serio_i2c->dev);
+		serio_unregister_port(serio);
+		i2c_unregister_device(serio_i2c);
+	}
+#endif
+	if (rtc_i2c)
+		i2c_unregister_device(rtc_i2c);
+#ifdef CONFIG_PINCTRL
+	bmc_pinctrl_unregister();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id mitx2_bmc_of_match[] = {
+	{ .compatible = "tp,mitx2-bmc" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, mitx2_bmc_of_match);
+#endif
+
+static const struct i2c_device_id mitx2_bmc_i2c_id[] = {
+	{ "mitx2_bmc", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mitx2_bmc_i2c_id);
+
+static ssize_t
+version_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%i.%i.%i\n", bmc_proto_version[0],
+			bmc_proto_version[1], bmc_proto_version[2]);
+}
+
+static struct kobj_attribute version_attribute =
+	__ATTR(version, 0664, version_show, NULL);
+
+static ssize_t
+bootreason_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%i\n", (bmc_bootreason[0] |
+			(bmc_bootreason[1] << 8)));
+}
+
+static struct kobj_attribute bootreason_attribute =
+	__ATTR(bootreason, 0664, bootreason_show, NULL);
+
+static ssize_t
+scratch_show(struct kobject *kobj,
+	     struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%i\n", (bmc_scratch[0] | (bmc_scratch[1] << 8) |
+			(bmc_scratch[2] << 16) | (bmc_scratch[3] << 24)));
+}
+
+static struct kobj_attribute scratch_attribute =
+	__ATTR(scratch, 0664, scratch_show, NULL);
+
+static struct attribute *bmc_attrs[] = {
+	&version_attribute.attr,
+	&bootreason_attribute.attr,
+	&scratch_attribute.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(bmc);
+
+static struct i2c_driver mitx2_bmc_i2c_driver = {
+	.driver		= {
+		.name	= "mitx2-bmc",
+		.of_match_table = of_match_ptr(mitx2_bmc_of_match),
+		.groups = bmc_groups,
+	},
+	.probe		= mitx2_bmc_i2c_probe,
+	.remove	  = mitx2_bmc_i2c_remove,
+	.id_table	= mitx2_bmc_i2c_id,
+};
+module_i2c_driver(mitx2_bmc_i2c_driver);
+
+MODULE_AUTHOR("Konstantin Kirik");
+MODULE_DESCRIPTION("mITX2 BMC driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("serial:bmc");
diff --git a/drivers/mmc/host/sdhci-of-dwcmshc.c b/drivers/mmc/host/sdhci-of-dwcmshc.c
index 6793fb8fe..496fb9dc6 100644
--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
+++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
@@ -19,6 +19,8 @@
 #define BOUNDARY_OK(addr, len) \
 	((addr | (SZ_128M - 1)) == ((addr + len - 1) | (SZ_128M - 1)))
 
+#define MSHC_INPUT_DIVIDER 2  /* mshc_tx_x2 to mshc_tx divider */
+
 struct dwcmshc_priv {
 	struct clk	*bus_clk;
 };
@@ -46,11 +48,50 @@ static void dwcmshc_adma_write_desc(struct sdhci_host *host, void **desc,
 	sdhci_adma_write_desc(host, desc, addr, len, cmd);
 }
 
+static unsigned int dwcmshc_get_max_clock (struct sdhci_host *host)
+{
+	/*
+	// todo: fix min\max clk rate
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	return clk_round_rate(pltfm_host->clk, ULONG_MAX);
+	*/
+	struct mmc_host *mmc = host->mmc;
+	struct device *dev = mmc_dev(mmc);
+	unsigned int ret;
+	if (device_property_read_u32(dev, "max-clock", &ret) < 0) {
+		ret = 1*1000*1000;
+	}
+	return ret;
+}
+
+static unsigned int dwcmshc_get_min_clock (struct sdhci_host *host)
+{
+	/*
+	// todo: fix min\max clk rate
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	return clk_round_rate(pltfm_host->clk, ULONG_MIN);
+	*/
+	return 150*1000;   /* tx2 = (pll=1200MHz)/(div=250*16) = 300/2 = 150KHz */
+}
+
+static void dwcmshc_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	if (clock == 0) {
+		return;
+	}
+	pltfm_host = sdhci_priv(host);
+	clk_set_rate(pltfm_host->clk, clock * MSHC_INPUT_DIVIDER);
+	host->mmc->actual_clock = clk_get_rate(pltfm_host->clk) / MSHC_INPUT_DIVIDER;
+	sdhci_enable_clk(host, 0);
+}
+
 static const struct sdhci_ops sdhci_dwcmshc_ops = {
-	.set_clock		= sdhci_set_clock,
+	.set_clock		= dwcmshc_set_clock,
 	.set_bus_width		= sdhci_set_bus_width,
 	.set_uhs_signaling	= sdhci_set_uhs_signaling,
-	.get_max_clock		= sdhci_pltfm_clk_get_max_clock,
+	.get_max_clock		= dwcmshc_get_max_clock,
+	.get_min_clock		= dwcmshc_get_min_clock,
 	.reset			= sdhci_reset,
 	.adma_write_desc	= dwcmshc_adma_write_desc,
 };
@@ -58,7 +99,9 @@ static const struct sdhci_ops sdhci_dwcmshc_ops = {
 static const struct sdhci_pltfm_data sdhci_dwcmshc_pdata = {
 	.ops = &sdhci_dwcmshc_ops,
 	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
-	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+		SDHCI_QUIRK2_BROKEN_64_BIT_DMA_MASK |
+		SDHCI_QUIRK2_NO_1_8_V,
 };
 
 static int dwcmshc_probe(struct platform_device *pdev)
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index a1aeb2e10..0223db132 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1017,6 +1017,24 @@ static void sdhci_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)
 		__sdhci_set_timeout(host, cmd);
 }
 
+/* Set the DMA boundary value and block size */
+static inline void sdhci_set_block_info(struct sdhci_host *host, struct mmc_data *data)
+{
+	/* Set the DMA boundary value and block size */
+	sdhci_writew(host, SDHCI_MAKE_BLKSZ(host->sdma_boundary, data->blksz), SDHCI_BLOCK_SIZE);
+	/*
+	 * For Version 4.10 onwards, if v4 mode is enabled, 32-bit Block Count
+	 * can be supported, in that case 16-bit block count register must be 0.
+	 */
+	if (host->version >= SDHCI_SPEC_410 && host->v4_mode && (host->quirks2 & SDHCI_QUIRK2_USE_32BIT_BLK_CNT)) {
+		if (sdhci_readw(host, SDHCI_BLOCK_COUNT))
+			sdhci_writew(host, 0, SDHCI_BLOCK_COUNT);
+		sdhci_writew(host, data->blocks, SDHCI_32BIT_BLK_CNT);
+	} else {
+		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
+	}
+}
+
 static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 {
 	struct mmc_data *data = cmd->data;
@@ -1125,22 +1143,7 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 
 	sdhci_set_transfer_irqs(host);
 
-	/* Set the DMA boundary value and block size */
-	sdhci_writew(host, SDHCI_MAKE_BLKSZ(host->sdma_boundary, data->blksz),
-		     SDHCI_BLOCK_SIZE);
-
-	/*
-	 * For Version 4.10 onwards, if v4 mode is enabled, 32-bit Block Count
-	 * can be supported, in that case 16-bit block count register must be 0.
-	 */
-	if (host->version >= SDHCI_SPEC_410 && host->v4_mode &&
-	    (host->quirks2 & SDHCI_QUIRK2_USE_32BIT_BLK_CNT)) {
-		if (sdhci_readw(host, SDHCI_BLOCK_COUNT))
-			sdhci_writew(host, 0, SDHCI_BLOCK_COUNT);
-		sdhci_writew(host, data->blocks, SDHCI_32BIT_BLK_CNT);
-	} else {
-		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
-	}
+	sdhci_set_block_info(host, data);
 }
 
 static inline bool sdhci_auto_cmd12(struct sdhci_host *host,
@@ -1202,7 +1205,7 @@ static void sdhci_set_transfer_mode(struct sdhci_host *host,
 			if (cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200)
 				sdhci_writew(host, 0x0, SDHCI_TRANSFER_MODE);
 		} else {
-		/* clear Auto CMD settings for no data CMDs */
+			/* clear Auto CMD settings for no data CMDs */
 			mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);
 			sdhci_writew(host, mode & ~(SDHCI_TRNS_AUTO_CMD12 |
 				SDHCI_TRNS_AUTO_CMD23), SDHCI_TRANSFER_MODE);
@@ -2829,9 +2832,12 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask, u32 *intmask_p)
 		 */
 		if (host->pending_reset)
 			return;
+		/*
+		// todo: fix false positives interrupts on mitx board.
 		pr_err("%s: Got command interrupt 0x%08x even though no command operation was in progress.\n",
 		       mmc_hostname(host->mmc), (unsigned)intmask);
 		sdhci_dumpregs(host);
+		*/
 		return;
 	}
 
@@ -3572,7 +3578,8 @@ static int sdhci_set_dma_mask(struct sdhci_host *host)
 		host->flags &= ~SDHCI_USE_64_BIT_DMA;
 
 	/* Try 64-bit mask if hardware is capable  of it */
-	if (host->flags & SDHCI_USE_64_BIT_DMA) {
+	if (!(host->quirks2 & SDHCI_QUIRK2_BROKEN_64_BIT_DMA_MASK) &&
+	     (host->flags & SDHCI_USE_64_BIT_DMA)) {
 		ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
 		if (ret) {
 			pr_warn("%s: Failed to set 64-bit DMA mask.\n",
@@ -3816,15 +3823,13 @@ int sdhci_setup_host(struct sdhci_host *host)
 		dma_addr_t dma;
 		void *buf;
 
-		if (host->flags & SDHCI_USE_64_BIT_DMA) {
-			host->adma_table_sz = host->adma_table_cnt *
-					      SDHCI_ADMA2_64_DESC_SZ(host);
-			host->desc_sz = SDHCI_ADMA2_64_DESC_SZ(host);
-		} else {
-			host->adma_table_sz = host->adma_table_cnt *
-					      SDHCI_ADMA2_32_DESC_SZ;
-			host->desc_sz = SDHCI_ADMA2_32_DESC_SZ;
-		}
+		if (!(host->flags & SDHCI_USE_64_BIT_DMA))
+			host->alloc_desc_sz = SDHCI_ADMA2_32_DESC_SZ;
+		else if (!host->alloc_desc_sz)
+			host->alloc_desc_sz = SDHCI_ADMA2_64_DESC_SZ(host);
+
+		host->desc_sz = host->alloc_desc_sz;
+		host->adma_table_sz = host->adma_table_cnt * host->desc_sz;
 
 		host->align_buffer_sz = SDHCI_MAX_SEGS * SDHCI_ADMA2_ALIGN;
 		/*
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 76e692886..b23b9e3df 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -222,6 +222,7 @@
 #define  SDHCI_SUPPORT_SDR50	0x00000001
 #define  SDHCI_SUPPORT_SDR104	0x00000002
 #define  SDHCI_SUPPORT_DDR50	0x00000004
+#define  SDHCI_SUPPORT_UHS2	0x00000008
 #define  SDHCI_DRIVER_TYPE_A	0x00000010
 #define  SDHCI_DRIVER_TYPE_C	0x00000020
 #define  SDHCI_DRIVER_TYPE_D	0x00000040
@@ -233,6 +234,7 @@
 #define  SDHCI_CLOCK_MUL_MASK	0x00FF0000
 #define  SDHCI_CLOCK_MUL_SHIFT	16
 #define  SDHCI_CAN_DO_ADMA3	0x08000000
+#define  SDHCI_SUPPORT_VDD2_18	0x10000000
 #define  SDHCI_SUPPORT_HS400	0x80000000 /* Non-standard */
 
 #define SDHCI_CAPABILITIES_1	0x44
@@ -288,6 +290,12 @@
 #define   SDHCI_SPEC_410	4
 #define   SDHCI_SPEC_420	5
 
+
+#define SDHCI_EMMC_CONTROL	0x52C
+#define  SDHCI_EMMC_TYPE_MMC	(1 << 0)  /* 0-sd,     1-mmc     */
+#define  SDHCI_EMMC_CRC_DISABLE	(1 << 1)  /* 0-enable, 1-disable */
+#define  SDHCI_EMMC_DONT_RESET	(1 << 2)  /* 0-reset,  1-dont    */
+
 /*
  * End of controller registers.
  */
@@ -484,9 +492,11 @@ struct sdhci_host {
  * block count.
  */
 #define SDHCI_QUIRK2_USE_32BIT_BLK_CNT			(1<<18)
+#define SDHCI_QUIRK2_BROKEN_64_BIT_DMA_MASK		(1<<19)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
+	phys_addr_t mapbase;	/* physical address base */
 	char *bounce_buffer;	/* For packing SDMA reads/writes */
 	dma_addr_t bounce_addr;
 	unsigned int bounce_buffer_size;
@@ -535,6 +545,7 @@ struct sdhci_host {
 	bool pending_reset;	/* Cmd/data reset is pending */
 	bool irq_wake_enabled;	/* IRQ wakeup is enabled */
 	bool v4_mode;		/* Host Version 4 Enable */
+	bool use_external_dma;	/* Host selects to use external DMA */
 
 	struct mmc_request *mrqs_done[SDHCI_MAX_MRQS];	/* Requests done */
 	struct mmc_command *cmd;	/* Current command */
@@ -557,6 +568,7 @@ struct sdhci_host {
 	dma_addr_t align_addr;	/* Mapped bounce buffer */
 
 	unsigned int desc_sz;	/* ADMA descriptor size */
+	unsigned int alloc_desc_sz;	/* ADMA descr. max size host supports */
 
 	struct workqueue_struct *complete_wq;	/* Request completion wq */
 	struct work_struct	complete_work;	/* Request completion work */
diff --git a/drivers/net/ethernet/amd/Kconfig b/drivers/net/ethernet/amd/Kconfig
index 9f965cdff..a406ce174 100644
--- a/drivers/net/ethernet/amd/Kconfig
+++ b/drivers/net/ethernet/amd/Kconfig
@@ -202,4 +202,11 @@ config AMD_XGBE_HAVE_ECC
 	bool
 	default n
 
+config BAIKAL_XGBE
+	bool "Baikal XGBE support"
+	default n
+	depends on AMD_XGBE
+	---help---
+	  Say Y to enable Baikal XGBE support
+
 endif # NET_VENDOR_AMD
diff --git a/drivers/net/ethernet/amd/xgbe/Makefile b/drivers/net/ethernet/amd/xgbe/Makefile
index 620785ffb..24e21b66d 100644
--- a/drivers/net/ethernet/amd/xgbe/Makefile
+++ b/drivers/net/ethernet/amd/xgbe/Makefile
@@ -7,6 +7,7 @@ amd-xgbe-objs := xgbe-main.o xgbe-drv.o xgbe-dev.o \
 		 xgbe-i2c.o xgbe-phy-v1.o xgbe-phy-v2.o \
 		 xgbe-platform.o
 
+amd-xgbe-$(CONFIG_BAIKAL_XGBE) += baikal-mdio.o
 amd-xgbe-$(CONFIG_PCI) += xgbe-pci.o
 amd-xgbe-$(CONFIG_AMD_XGBE_DCB) += xgbe-dcb.o
 amd-xgbe-$(CONFIG_DEBUG_FS) += xgbe-debugfs.o
diff --git a/drivers/net/ethernet/amd/xgbe/baikal-mdio.c b/drivers/net/ethernet/amd/xgbe/baikal-mdio.c
new file mode 100644
index 000000000..e671e2474
--- /dev/null
+++ b/drivers/net/ethernet/amd/xgbe/baikal-mdio.c
@@ -0,0 +1,635 @@
+/*
+ *
+ * This file is available to you under your choice of the following two
+ * licenses:
+ *
+ * License 1: GPLv2
+ *
+ * Copyright (c) 2014 Advanced Micro Devices, Inc.
+ *
+ * This file is free software; you may copy, redistribute and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * License 2: Modified BSD
+ *
+ * Copyright (c) 2014 Advanced Micro Devices, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Advanced Micro Devices, Inc. nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/mdio.h>
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/of_mdio.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+#include <linux/clk.h>
+
+#include "xgbe.h"
+#include "xgbe-common.h"
+
+#ifndef VR_XS_PMA_MII_Gen5_MPLL_CTRL
+#define VR_XS_PMA_MII_Gen5_MPLL_CTRL                    0x807A
+#endif
+#define VR_XS_PMA_MII_Gen5_MPLL_CTRL_REF_CLK_SEL_bit    (1 << 13)
+#define VR_XS_PCS_DIG_CTRL1                             0x8000
+#define VR_XS_PCS_DIG_CTRL1_VR_RST_Bit                  MDIO_CTRL1_RESET
+#define SR_XC_or_PCS_MMD_Control1                       MDIO_CTRL1
+#define SR_XC_or_PCS_MMD_Control1_RST_Bit               MDIO_CTRL1_RESET
+#define DWC_GLBL_PLL_MONITOR                            0x8010
+#define SDS_PCS_CLOCK_READY_mask                        0x1C
+#define SDS_PCS_CLOCK_READY_bit                         0x10
+#define VR_XS_PMA_MII_ENT_GEN5_GEN_CTL                  0x809C
+#define VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LANE_MODE_KX4    (4 << 0)
+#define VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LANE_MODE_MASK   0x0007
+#define VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LINK_WIDTH_4     (2 << 8)
+#define VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LINK_WIDTH_MASK  0x0700
+#define VR_XS_OR_PCS_MMD_DIGITAL_CTL1_VR_RST            (1 << 15)
+
+#define DELAY_COUNT     50
+
+static int be_xgbe_an_restart_kr_training(struct xgbe_prv_data *pdata)
+{
+	int reg = 0;
+
+	DBGPR("%s\n", __FUNCTION__);
+
+	/* Restart training */
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, 0x0096, 3);
+	msleep(500);
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, 0x0096, 1);
+	
+	/* The worse case when training continue till 500ms */
+	msleep(500);
+
+	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, 0x0097);
+	/* Check training failure */
+	if (reg & (1 << 3))
+		return -1;
+
+	/* Success */
+	return 0;
+}
+
+static int be_xgbe_an_enable_kr_training(struct xgbe_prv_data *pdata)
+{
+	DBGPR("%s\n", __FUNCTION__);
+	
+	/* Enable training */
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, 0x0096, 2);
+	
+	return 0;
+}
+
+static int be_xgbe_phy_pcs_power_cycle(struct xgbe_prv_data *pdata)
+{
+	int ret;
+	DBGPR("%s\n", __FUNCTION__);
+
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);
+
+	ret |= MDIO_CTRL1_LPOWER;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+
+	usleep_range(75, 100);
+
+	ret &= ~MDIO_CTRL1_LPOWER;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+
+	return 0;
+}
+
+static int be_xgbe_phy_xgmii_mode_kx4(struct xgbe_prv_data *pdata)
+{
+	int  ret, count;
+
+	DBGPR_MDIO("%s\n", __FUNCTION__);
+
+	/* Write 2'b01 to Bits[1:0] of SR PCS Control2 to set the xpcx_kr_0
+	 * output to 0.
+	 */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);
+
+	ret &= ~MDIO_PCS_CTRL2_TYPE;
+	ret |= MDIO_PCS_CTRL2_10GBX;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL2, ret);
+
+	/* Set Bit 13 SR PMA MMD Control1 Register (for back plane) to 1. */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_CTRL1);
+
+	ret |= 0x2000;
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_CTRL1, ret);
+
+	/* Set LANE_MODE TO KX4 (4). */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_ENT_GEN5_GEN_CTL);
+
+	ret &= ~VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LANE_MODE_MASK;
+	ret |= VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LANE_MODE_KX4;
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_ENT_GEN5_GEN_CTL, ret);
+
+	/* Set LANE_WIDTH (2) 4 lanes per link. */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_ENT_GEN5_GEN_CTL);
+
+	ret &= ~VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LINK_WIDTH_MASK;
+	ret |= VR_XS_PMA_MII_ENT_GEN5_GEN_CTL_LINK_WIDTH_4;
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_ENT_GEN5_GEN_CTL, ret);
+
+	/* Initiate Software Reset. */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+
+	ret |= VR_XS_OR_PCS_MMD_DIGITAL_CTL1_VR_RST;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1, ret);
+
+	/* Wait until reset done. */
+	count = DELAY_COUNT;
+	do {
+		msleep(20);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+	} while (!!(ret & VR_XS_OR_PCS_MMD_DIGITAL_CTL1_VR_RST) && --count);
+
+	if (ret & VR_XS_OR_PCS_MMD_DIGITAL_CTL1_VR_RST)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int be_xgbe_phy_xgmii_mode_kr(struct xgbe_prv_data *pdata)
+{
+	int ret;
+	DBGPR("%s\n", __FUNCTION__);
+	
+	/* Enable KR training */
+	ret = be_xgbe_an_enable_kr_training(pdata);
+	if (ret < 0)
+		return ret;
+
+	/* Set PCS to KR/10G speed */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL2);
+
+	ret &= ~MDIO_PCS_CTRL2_TYPE;
+	ret |= MDIO_PCS_CTRL2_10GBR;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL2, ret);
+
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);
+
+	ret &= ~MDIO_CTRL1_SPEEDSEL;
+	ret |= MDIO_CTRL1_SPEED10G;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+
+	ret = be_xgbe_phy_pcs_power_cycle(pdata);
+	if (ret < 0)
+    		return ret;
+
+	return 0;
+}
+
+static int be_xgbe_phy_xgmii_mode(struct xgbe_prv_data *pdata)
+{
+    struct device *dev = pdata->dev;
+    char mode[32];
+    const char *pm = mode;
+
+    if(!of_property_read_string(dev->of_node, "be,pcs-mode", &pm)) {
+        if(strcasecmp(pm, "KX4") == 0){
+            DBGPR("xgbe: mode KX4 = 0x%X function: %s\n", mode, __FUNCTION__);
+            return be_xgbe_phy_xgmii_mode_kx4(pdata);
+        }
+    }
+
+    DBGPR("xgbe: mode KR = 0x%X function: %s\n", mode, __FUNCTION__);
+
+    return be_xgbe_phy_xgmii_mode_kr(pdata);
+}
+
+static int __maybe_unused be_xgbe_phy_soft_reset(struct xgbe_prv_data *pdata)
+{
+	int count, ret;
+	DBGPR("%s\n", __FUNCTION__);
+
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);
+
+	ret |= MDIO_CTRL1_RESET;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, ret);
+
+	count = DELAY_COUNT;
+	do {
+		msleep(20);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);
+		if (ret < 0)
+			return ret;
+	} while ((ret & MDIO_CTRL1_RESET) && --count);
+
+	if (ret & MDIO_CTRL1_RESET)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int be_xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)
+{
+	int reg;
+
+	DBGPR("%s\n", __FUNCTION__);
+
+	pdata->link_check = jiffies;
+	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1);
+	
+	/* Disable auto negotiation in any case! */
+	reg &= ~MDIO_AN_CTRL1_ENABLE;
+	pdata->phy.autoneg = AUTONEG_DISABLE;
+
+	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_CTRL1, reg);
+
+	return 0;
+}
+
+static int ext_phy_probe(struct device *pdev, struct phy_device **phy_dev)
+{
+        struct device_node *xmit_node;
+        struct phy_device *phydev;
+        struct device *dev = pdev;
+        int ret;
+
+        /* Retrieve the xmit-handle */
+        xmit_node = of_parse_phandle(dev->of_node, "ext-phy-handle", 0);
+        if (!xmit_node)
+                return -ENODEV;
+
+        phydev = of_phy_find_device(xmit_node);
+        if (!phydev)
+                return -ENODEV;
+
+        ret = phy_init_hw(phydev);
+        if (ret < 0)
+                return ret;
+
+        if ((phydev->speed != SPEED_10000) && (phydev->duplex != DUPLEX_FULL))
+        	return -ENODEV;
+
+        *phy_dev = phydev;
+
+        return 0;
+}
+
+int be_xgbe_phy_config_init(struct xgbe_prv_data *pdata)
+{
+	int ret = 0;
+    	int count = DELAY_COUNT;
+	DBGPR("%s\n", __FUNCTION__);
+
+        if(ext_phy_probe(&pdata->platdev->dev, &pdata->phydev)) {
+                pr_info("XGMAC: can't probe external PHY\n");
+                return 1;
+        }
+
+        pr_info("XGMAC: probe external PHY with success\n");
+
+	/* Initialize supported features */
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Backplane_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+			pdata->phydev->supported, 1);
+	linkmode_copy(pdata->phydev->advertising, pdata->phydev->supported);
+
+	pdata->phy.pause_autoneg = 0;
+	pdata->phy.tx_pause = 0;
+	pdata->phy.rx_pause = 0;
+	
+        /* Switch XGMAC PHY PLL to use external ref clock from pad */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_Gen5_MPLL_CTRL);
+	ret &= ~(VR_XS_PMA_MII_Gen5_MPLL_CTRL_REF_CLK_SEL_bit);
+	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, VR_XS_PMA_MII_Gen5_MPLL_CTRL, ret);
+	wmb();
+
+	/* Make vendor specific soft reset */
+	ret = XMDIO_READ(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+	ret |= VR_XS_PCS_DIG_CTRL1_VR_RST_Bit;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1, ret);
+	wmb();
+
+	/* Wait reset finish */
+	count = DELAY_COUNT;
+	do {
+		usleep_range(500, 600);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, VR_XS_PCS_DIG_CTRL1);
+	} while(((ret & VR_XS_PCS_DIG_CTRL1_VR_RST_Bit) != 0) && count--);
+
+
+	DBGPR("%s %x\n", __FUNCTION__, ret);
+	/*
+	 * Wait for the RST (bit 15) of the SR XS or PCS MMD Control1 Register is 0.
+	 * This bit is self-cleared when Bits[4:2] in VR XS or PCS MMD Digital
+	 * Status Register are equal to 3b100, that is, Tx/Rx clocks are stable
+	 * and in Power_Good state.
+	 */
+	count = DELAY_COUNT;
+	do {
+		usleep_range(500, 600);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, SR_XC_or_PCS_MMD_Control1);
+	} while(((ret & SR_XC_or_PCS_MMD_Control1_RST_Bit) != 0) && count--);
+
+	/*
+	 * This bit is self-cleared when Bits[4:2] in VR XS or PCS MMD Digital
+	 * Status Register are equal to 3b100, that is, Tx/Rx clocks are stable
+	 * and in Power_Good state.
+	 */
+	count = DELAY_COUNT;
+	do {
+		usleep_range(500, 600);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, DWC_GLBL_PLL_MONITOR);
+	} while(((ret & SDS_PCS_CLOCK_READY_mask) != SDS_PCS_CLOCK_READY_bit) && count-- );
+
+	/* Turn off and clear interrupts */
+	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, 0);
+	wmb();
+
+	be_xgbe_phy_config_aneg(pdata);
+
+	ret = be_xgbe_phy_xgmii_mode(pdata);
+    
+	count = DELAY_COUNT;
+	do
+	{
+		msleep(10);
+		ret = XMDIO_READ(pdata, MDIO_MMD_PCS, 0x0001);
+	} while(((ret & 0x0004) != 0x0004) && count--);
+
+	return 0;
+}
+
+static int be_xgbe_phy_aneg_done(struct xgbe_prv_data *pdata)
+{
+	int reg;
+	DBGPR("%s\n", __FUNCTION__);
+
+	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1);
+
+	return (reg & MDIO_AN_STAT1_COMPLETE) ? 1 : 0;
+}
+
+static int be_xgbe_phy_update_link(struct xgbe_prv_data *pdata)
+{
+	int new_state = 0;
+	int ret = 0;
+	struct phy_device *phydev;
+
+	if(!pdata || !pdata->phydev)
+	    return 1;
+
+	phydev = pdata->phydev;
+	ret = phy_read_mmd(phydev, MDIO_MMD_PHYXS, 0x1001);
+
+	if (pdata->phy.link) {
+		/* Flow control support */
+		pdata->pause_autoneg = pdata->phy.pause_autoneg;
+
+		if (pdata->tx_pause != pdata->phy.tx_pause) {
+			new_state = 1;
+			pdata->hw_if.config_tx_flow_control(pdata);
+			pdata->tx_pause = pdata->phy.tx_pause;
+		}
+
+		if (pdata->rx_pause != pdata->phy.rx_pause) {
+			new_state = 1;
+			pdata->hw_if.config_rx_flow_control(pdata);
+			pdata->rx_pause = pdata->phy.rx_pause;
+		}
+
+		/* Speed support */
+		if (pdata->phy_speed != pdata->phy.speed) {
+			new_state = 1;
+			pdata->phy_speed = pdata->phy.speed;
+		}
+
+		if (pdata->phy_link != pdata->phy.link) {
+			new_state = 1;
+			pdata->phy_link = pdata->phy.link;
+		}
+	} else if (pdata->phy_link) {
+		new_state = 1;
+		pdata->phy_link = 0;
+		pdata->phy_speed = SPEED_UNKNOWN;
+	}
+
+	return 0;
+}
+
+static void be_xgbe_phy_read_status(struct xgbe_prv_data *pdata)
+{
+	int reg, link_aneg;
+	
+	if (!pdata->phydev)
+		return;
+
+	pdata->phy.link = 1;
+
+	if (test_bit(XGBE_LINK_ERR, &pdata->dev_state)) {
+		netif_carrier_off(pdata->netdev);
+
+		pdata->phy.link = 0;
+		goto update_link;
+	}
+
+	link_aneg = (pdata->phy.autoneg == AUTONEG_ENABLE);
+
+	if (pdata->phydev) {
+		pdata->phydev->drv->read_status(pdata->phydev);
+		/* Pop out old values */
+		pdata->phydev->drv->read_status(pdata->phydev);
+		if (!pdata->phydev->link){
+			pdata->phydev->link = 0;
+			pdata->phy.link &= pdata->phydev->link;
+		}
+	}
+	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);
+	pdata->phy.link &= (reg & MDIO_STAT1_LSTATUS) ? 1 : 0;
+
+	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_STAT1);
+	pdata->phy.link &= (reg & MDIO_STAT1_LSTATUS) ? 1 : 0;
+
+	if (pdata->phy.link) {
+		if (link_aneg && !be_xgbe_phy_aneg_done(pdata)) {
+			return;
+		}
+
+		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state))
+			clear_bit(XGBE_LINK_INIT, &pdata->dev_state);
+
+		netif_carrier_on(pdata->netdev);
+	} else {
+		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state)) 
+			if (link_aneg)
+				return;
+
+		netif_carrier_off(pdata->netdev);
+
+		/* If KX4 mode is enabled training doesn't affect behavior */
+		be_xgbe_an_restart_kr_training(pdata);
+		/* Pop out old values */
+		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);
+		XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_STAT1);
+	}
+
+update_link:
+	be_xgbe_phy_update_link(pdata);
+}
+
+static void be_xgbe_phy_stop(struct xgbe_prv_data *pdata)
+{
+	netif_dbg(pdata, link, pdata->netdev, "stopping PHY\n");
+
+	/* Disable auto-negotiation interrupts */
+	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+
+	pdata->phy.link = 0;
+	netif_carrier_off(pdata->netdev);
+
+	be_xgbe_phy_update_link(pdata);
+}
+
+/**
+ * be_xgbe_phy_start() - dummy
+ */
+int be_xgbe_phy_start(struct xgbe_prv_data *pdata)
+{
+        return 0;
+}
+
+/**
+ * be_xgbe_phy_exit() - dummy
+ */
+void be_xgbe_phy_exit(struct xgbe_prv_data *pdata)
+{
+	return;
+}
+
+/**
+ * be_an_isr() - dummy
+ */
+irqreturn_t be_an_isr(struct xgbe_prv_data *pdata)
+{
+	return IRQ_HANDLED;
+}
+
+void xgbe_init_function_ptrs_phy_baikal(struct xgbe_phy_if *phy_if)
+{
+	phy_if->phy_init        = be_xgbe_phy_config_init;
+	phy_if->phy_exit	= be_xgbe_phy_exit;
+	phy_if->phy_reset       = be_xgbe_phy_soft_reset;
+	phy_if->phy_stop        = be_xgbe_phy_stop;
+	phy_if->phy_status      = be_xgbe_phy_read_status;
+	phy_if->phy_config_aneg = be_xgbe_phy_config_aneg;
+	phy_if->phy_start	= be_xgbe_phy_start;
+	phy_if->an_isr		= be_an_isr;
+}
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-desc.c b/drivers/net/ethernet/amd/xgbe/xgbe-desc.c
index 230726d7b..ebd1985c3 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-desc.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-desc.c
@@ -366,8 +366,13 @@ static int xgbe_map_rx_buffer(struct xgbe_prv_data *pdata,
 	}
 
 	if (!ring->rx_buf_pa.pages) {
+#ifdef CONFIG_BAIKAL_XGBE
+		ret = xgbe_alloc_pages(pdata, &ring->rx_buf_pa,
+				       0, ring->node);
+#else
 		ret = xgbe_alloc_pages(pdata, &ring->rx_buf_pa,
 				       PAGE_ALLOC_COSTLY_ORDER, ring->node);
+#endif
 		if (ret)
 			return ret;
 	}
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index d5fd49dd2..adf3ee7fc 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@ -689,7 +689,9 @@ static void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)
 			 *          per channel interrupts in edge triggered
 			 *          mode)
 			 */
+#ifndef CONFIG_BAIKAL_XGBE
 			if (!pdata->per_channel_irq || pdata->channel_irq_mode)
+#endif
 				XGMAC_SET_BITS(channel->curr_ier,
 					       DMA_CH_IER, TIE, 1);
 		}
@@ -701,7 +703,9 @@ static void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)
 			 *          mode)
 			 */
 			XGMAC_SET_BITS(channel->curr_ier, DMA_CH_IER, RBUE, 1);
+#ifndef CONFIG_BAIKAL_XGBE
 			if (!pdata->per_channel_irq || pdata->channel_irq_mode)
+#endif
 				XGMAC_SET_BITS(channel->curr_ier,
 					       DMA_CH_IER, RIE, 1);
 		}
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index da8c2c4ac..5db39f17b 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@ -216,8 +216,15 @@ static int xgbe_alloc_channels(struct xgbe_prv_data *pdata)
 		channel->node = node;
 		cpumask_set_cpu(cpu, &channel->affinity_mask);
 
+#ifndef CONFIG_BAIKAL_XGBE
 		if (pdata->per_channel_irq)
 			channel->dma_irq = pdata->channel_irq[i];
+#else
+		if (pdata->per_channel_irq) {
+			channel->tx_dma_irq = pdata->channel_tx_irq[i];
+			channel->rx_dma_irq = pdata->channel_rx_irq[i];
+		}
+#endif
 
 		if (i < pdata->tx_ring_count) {
 			ring = xgbe_alloc_node(sizeof(*ring), node);
@@ -244,10 +251,22 @@ static int xgbe_alloc_channels(struct xgbe_prv_data *pdata)
 		netif_dbg(pdata, drv, pdata->netdev,
 			  "%s: cpu=%u, node=%d\n", channel->name, cpu, node);
 
+#ifndef CONFIG_BAIKAL_XGBE
 		netif_dbg(pdata, drv, pdata->netdev,
 			  "%s: dma_regs=%p, dma_irq=%d, tx=%p, rx=%p\n",
 			  channel->name, channel->dma_regs, channel->dma_irq,
 			  channel->tx_ring, channel->rx_ring);
+#else
+		netif_dbg(pdata, drv, pdata->netdev,
+			  "%s: dma_regs=%p, tx_dma_irq=%d, tx=%p, rx=%p\n",
+			  channel->name, channel->dma_regs, channel->tx_dma_irq,
+			  channel->tx_ring, channel->rx_ring);
+
+		netif_dbg(pdata, drv, pdata->netdev,
+			  "%s: dma_regs=%p, rx_dma_irq=%d, tx=%p, rx=%p\n",
+			  channel->name, channel->dma_regs, channel->rx_dma_irq,
+			  channel->tx_ring, channel->rx_ring);
+#endif
 	}
 
 	pdata->channel_count = count;
@@ -623,10 +642,16 @@ static irqreturn_t xgbe_dma_isr(int irq, void *data)
 	 */
 	if (napi_schedule_prep(&channel->napi)) {
 		/* Disable Tx and Rx interrupts */
+#ifndef CONFIG_BAIKAL_XGBE
 		if (pdata->channel_irq_mode)
 			xgbe_disable_rx_tx_int(pdata, channel);
 		else
 			disable_irq_nosync(channel->dma_irq);
+#else
+		xgbe_disable_rx_tx_int(pdata, channel);
+		disable_irq_nosync(channel->tx_dma_irq);
+		disable_irq_nosync(channel->rx_dma_irq);
+#endif
 
 		/* Turn on polling */
 		__napi_schedule_irqoff(&channel->napi);
@@ -654,10 +679,17 @@ static void xgbe_tx_timer(struct timer_list *t)
 	if (napi_schedule_prep(napi)) {
 		/* Disable Tx and Rx interrupts */
 		if (pdata->per_channel_irq)
+#ifndef CONFIG_BAIKAL_XGBE
 			if (pdata->channel_irq_mode)
 				xgbe_disable_rx_tx_int(pdata, channel);
 			else
 				disable_irq_nosync(channel->dma_irq);
+#else
+		{
+				disable_irq_nosync(channel->tx_dma_irq);
+				disable_irq_nosync(channel->rx_dma_irq);
+		}
+#endif
 		else
 			xgbe_disable_rx_tx_ints(pdata);
 
@@ -1090,6 +1122,7 @@ static int xgbe_request_irqs(struct xgbe_prv_data *pdata)
 	if (!pdata->per_channel_irq)
 		return 0;
 
+#ifndef CONFIG_BAIKAL_XGBE
 	for (i = 0; i < pdata->channel_count; i++) {
 		channel = pdata->channel[i];
 		snprintf(channel->dma_irq_name,
@@ -1110,6 +1143,61 @@ static int xgbe_request_irqs(struct xgbe_prv_data *pdata)
 				      &channel->affinity_mask);
 	}
 
+	err_dma_irq:
+		/* Using an unsigned int, 'i' will go to UINT_MAX and exit */
+		for (i--; i < pdata->channel_count; i--) {
+			channel = pdata->channel[i];
+
+			irq_set_affinity_hint(channel->dma_irq, NULL);
+			devm_free_irq(pdata->dev, channel->dma_irq, channel);
+		}
+
+		if (pdata->vdata->ecc_support && (pdata->dev_irq != pdata->ecc_irq))
+			devm_free_irq(pdata->dev, pdata->ecc_irq, pdata);
+
+	err_dev_irq:
+		devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
+
+		return ret;
+#else
+	for (i = 0; i < pdata->channel_count; i++) {
+		channel = pdata->channel[i];
+		/* Tx */
+		snprintf(channel->tx_dma_irq_name,
+			 sizeof(channel->tx_dma_irq_name) - 1,
+			 "%s-Tx-%u", netdev_name(netdev),
+			 channel->queue_index);
+
+		ret = devm_request_irq(pdata->dev, channel->tx_dma_irq,
+				       xgbe_dma_isr, 0,
+				       channel->tx_dma_irq_name, channel);
+		if (ret) {
+			netdev_alert(netdev, "error requesting irq %d\n",
+				     channel->tx_dma_irq);
+			goto err_dma_irq;
+		}
+
+		irq_set_affinity_hint(channel->tx_dma_irq,
+						      &channel->affinity_mask);
+
+		/* Rx */
+		snprintf(channel->rx_dma_irq_name,
+			 sizeof(channel->rx_dma_irq_name) - 1,
+			 "%s-Rx-%u", netdev_name(netdev),
+			 channel->queue_index);
+
+		ret = devm_request_irq(pdata->dev, channel->rx_dma_irq,
+				       xgbe_dma_isr, 0,
+				       channel->rx_dma_irq_name, channel);
+		if (ret) {
+			netdev_alert(netdev, "error requesting irq %d\n",
+				     channel->rx_dma_irq);
+			goto err_dma_irq;
+		}
+
+		irq_set_affinity_hint(channel->rx_dma_irq,
+						      &channel->affinity_mask);
+	}
 	return 0;
 
 err_dma_irq:
@@ -1117,8 +1205,10 @@ static int xgbe_request_irqs(struct xgbe_prv_data *pdata)
 	for (i--; i < pdata->channel_count; i--) {
 		channel = pdata->channel[i];
 
-		irq_set_affinity_hint(channel->dma_irq, NULL);
-		devm_free_irq(pdata->dev, channel->dma_irq, channel);
+		devm_free_irq(pdata->dev, channel->tx_dma_irq, channel);
+		devm_free_irq(pdata->dev, channel->rx_dma_irq, channel);
+		irq_set_affinity_hint(channel->tx_dma_irq, NULL);
+		irq_set_affinity_hint(channel->rx_dma_irq, NULL);
 	}
 
 	if (pdata->vdata->ecc_support && (pdata->dev_irq != pdata->ecc_irq))
@@ -1128,6 +1218,7 @@ static int xgbe_request_irqs(struct xgbe_prv_data *pdata)
 	devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
 
 	return ret;
+#endif
 }
 
 static void xgbe_free_irqs(struct xgbe_prv_data *pdata)
@@ -1146,8 +1237,15 @@ static void xgbe_free_irqs(struct xgbe_prv_data *pdata)
 	for (i = 0; i < pdata->channel_count; i++) {
 		channel = pdata->channel[i];
 
+#ifndef CONFIG_BAIKAL_XGBE
 		irq_set_affinity_hint(channel->dma_irq, NULL);
 		devm_free_irq(pdata->dev, channel->dma_irq, channel);
+#else
+		irq_set_affinity_hint(channel->tx_dma_irq, NULL);
+		irq_set_affinity_hint(channel->rx_dma_irq, NULL);
+		devm_free_irq(pdata->dev, channel->tx_dma_irq, channel);
+		devm_free_irq(pdata->dev, channel->rx_dma_irq, channel);
+#endif
 	}
 }
 
@@ -1228,10 +1326,14 @@ static void xgbe_free_rx_data(struct xgbe_prv_data *pdata)
 
 static int xgbe_phy_reset(struct xgbe_prv_data *pdata)
 {
+#ifndef CONFIG_BAIKAL_XGBE
 	pdata->phy_link = -1;
 	pdata->phy_speed = SPEED_UNKNOWN;
 
 	return pdata->phy_if.phy_reset(pdata);
+#else
+	return 0;
+#endif
 }
 
 int xgbe_powerdown(struct net_device *netdev, unsigned int caller)
@@ -2234,7 +2336,12 @@ static void xgbe_poll_controller(struct net_device *netdev)
 	if (pdata->per_channel_irq) {
 		for (i = 0; i < pdata->channel_count; i++) {
 			channel = pdata->channel[i];
+#ifndef CONFIG_BAIKAL_XGBE
 			xgbe_dma_isr(channel->dma_irq, channel);
+#else
+			xgbe_dma_isr(channel->tx_dma_irq, channel);
+			xgbe_dma_isr(channel->rx_dma_irq, channel);
+#endif
 		}
 	} else {
 		disable_irq(pdata->dev_irq);
@@ -2889,10 +2996,16 @@ static int xgbe_one_poll(struct napi_struct *napi, int budget)
 	/* If we processed everything, we are done */
 	if ((processed < budget) && napi_complete_done(napi, processed)) {
 		/* Enable Tx and Rx interrupts */
+#ifndef CONFIG_BAIKAL_XGBE
 		if (pdata->channel_irq_mode)
 			xgbe_enable_rx_tx_int(pdata, channel);
 		else
 			enable_irq(channel->dma_irq);
+#else
+		xgbe_enable_rx_tx_int(pdata, channel);
+		enable_irq(channel->tx_dma_irq);
+		enable_irq(channel->rx_dma_irq);
+#endif
 	}
 
 	DBGPR("<--xgbe_one_poll: received = %d\n", processed);
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-main.c b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 7ce9c69e9..5192e4124 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@ -121,6 +121,9 @@
 #include <linux/etherdevice.h>
 #include <linux/io.h>
 #include <linux/notifier.h>
+#ifdef CONFIG_BAIKAL_XGBE
+#include <linux/clk.h>
+#endif
 
 #include "xgbe.h"
 #include "xgbe-common.h"
@@ -142,7 +145,11 @@ static void xgbe_default_config(struct xgbe_prv_data *pdata)
 	DBGPR("-->xgbe_default_config\n");
 
 	pdata->blen = DMA_SBMR_BLEN_64;
-	pdata->pbl = DMA_PBL_128;
+#ifdef CONFIG_BAIKAL_XGBE
+	pdata->pbl = DMA_PBL_16;
+#else
+	pdata->pbl = DMA_PBL_256;
+#endif
 	pdata->aal = 1;
 	pdata->rd_osr_limit = 8;
 	pdata->wr_osr_limit = 8;
@@ -330,6 +337,19 @@ int xgbe_config_netdev(struct xgbe_prv_data *pdata)
 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, TCP4TE, 1);
 	XGMAC_SET_BITS(pdata->rss_options, MAC_RSSCR, UDP4TE, 1);
 
+#ifdef CONFIG_BAIKAL_XGBE
+	ret = clk_prepare_enable(pdata->sysclk);
+	if (ret) {
+		netdev_alert(netdev, "gmac clk_prepare_enable failed\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pdata->ptpclk);
+	if (ret) {
+		netdev_alert(netdev, "dma clk_prepare_enable failed\n");
+		return ret;
+	}
+#endif
 	/* Call MDIO/PHY initialization routine */
 	pdata->debugfs_an_cdr_workaround = pdata->vdata->an_cdr_workaround;
 	ret = pdata->phy_if.phy_init(pdata);
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-platform.c b/drivers/net/ethernet/amd/xgbe/xgbe-platform.c
index 4ebd24101..f3d50ad35 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-platform.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-platform.c
@@ -370,6 +370,7 @@ static int xgbe_platform_probe(struct platform_device *pdev)
 	if (netif_msg_probe(pdata))
 		dev_dbg(dev, "xpcs_regs  = %p\n", pdata->xpcs_regs);
 
+#ifndef CONFIG_BAIKAL_XGBE
 	pdata->rxtx_regs = devm_platform_ioremap_resource(phy_pdev,
 							  phy_memnum++);
 	if (IS_ERR(pdata->rxtx_regs)) {
@@ -399,6 +400,7 @@ static int xgbe_platform_probe(struct platform_device *pdev)
 	}
 	if (netif_msg_probe(pdata))
 		dev_dbg(dev, "sir1_regs  = %p\n", pdata->sir1_regs);
+#endif
 
 	/* Retrieve the MAC address */
 	ret = device_property_read_u8_array(dev, XGBE_MAC_ADDR_PROPERTY,
@@ -425,7 +427,11 @@ static int xgbe_platform_probe(struct platform_device *pdev)
 	/* Check for per channel interrupt support */
 	if (device_property_present(dev, XGBE_DMA_IRQS_PROPERTY)) {
 		pdata->per_channel_irq = 1;
+#ifndef CONFIG_BAIKAL_XGBE
 		pdata->channel_irq_mode = XGBE_IRQ_MODE_EDGE;
+#else
+		pdata->channel_irq_mode = XGBE_IRQ_MODE_LEVEL;
+#endif
 	}
 
 	/* Obtain device settings unique to ACPI/OF */
@@ -467,8 +473,12 @@ static int xgbe_platform_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto err_io;
 	pdata->dev_irq = ret;
+#ifdef CONFIG_BAIKAL_XGBE
+	pdata->an_irq = pdata->dev_irq;
+#endif
 
 	/* Get the per channel DMA interrupts */
+#ifndef CONFIG_BAIKAL_XGBE
 	if (pdata->per_channel_irq) {
 		unsigned int i, max = ARRAY_SIZE(pdata->channel_irq);
 
@@ -484,12 +494,39 @@ static int xgbe_platform_probe(struct platform_device *pdev)
 
 		pdata->irq_count += max;
 	}
+#else
+	if (pdata->per_channel_irq) {
+		int i;	
+		unsigned int max = ARRAY_SIZE(pdata->channel_tx_irq);
+
+		/* Tx */
+		for (i = 0; i < pdata->tx_max_channel_count; ++i) {
+			ret = platform_get_irq(pdata->platdev, i + 1);
+			if (ret < 0)
+				goto err_io;
+			pdata->channel_tx_irq[i] = ret;	
+		}
+
+		/* Rx */
+		for (i = 0; i < pdata->rx_max_channel_count; ++i) {
+			ret = platform_get_irq(pdata->platdev, i + 9);
+			if (ret < 0)
+				goto err_io;
+			pdata->channel_rx_irq[i] = ret;	
+		}	
+
+		pdata->channel_irq_count = max;
+		pdata->irq_count += max;
+	}
+#endif
 
+#ifndef CONFIG_BAIKAL_XGBE
 	/* Get the auto-negotiation interrupt */
 	ret = platform_get_irq(phy_pdev, phy_irqnum++);
 	if (ret < 0)
 		goto err_io;
 	pdata->an_irq = ret;
+#endif
 
 	/* Configure the netdev resource */
 	ret = xgbe_config_netdev(pdata);
@@ -573,7 +610,11 @@ static int xgbe_platform_resume(struct device *dev)
 #endif /* CONFIG_PM_SLEEP */
 
 static const struct xgbe_version_data xgbe_v1 = {
+#ifdef CONFIG_BAIKAL_XGBE
+	.init_function_ptrs_phy_impl	= xgbe_init_function_ptrs_phy_baikal,
+#else
 	.init_function_ptrs_phy_impl	= xgbe_init_function_ptrs_phy_v1,
+#endif
 	.xpcs_access			= XGBE_XPCS_ACCESS_V1,
 	.tx_max_fifo_size		= 81920,
 	.rx_max_fifo_size		= 81920,
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe.h b/drivers/net/ethernet/amd/xgbe/xgbe.h
index 0c93a552b..277fdd63c 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@ -209,6 +209,9 @@
 #define XGBE_SPEEDSET_PROPERTY	"amd,speed-set"
 
 /* Device-tree clock names */
+#ifdef CONFIG_BAIKAL_XGBE
+#define XGBE_AXI_CLOCK          "axi"
+#endif
 #define XGBE_DMA_CLOCK		"dma_clk"
 #define XGBE_PTP_CLOCK		"ptp_clk"
 
@@ -503,8 +506,15 @@ struct xgbe_channel {
 	void __iomem *dma_regs;
 
 	/* Per channel interrupt irq number */
+#ifndef CONFIG_BAIKAL_XGBE
 	int dma_irq;
 	char dma_irq_name[IFNAMSIZ + 32];
+#else
+	int rx_dma_irq;
+	int tx_dma_irq;
+	char rx_dma_irq_name[IFNAMSIZ + 32];
+	char tx_dma_irq_name[IFNAMSIZ + 32];
+#endif
 
 	/* Netdev related settings */
 	struct napi_struct napi;
@@ -1030,6 +1040,11 @@ struct xgbe_prv_data {
 	struct platform_device *phy_platdev;
 	struct device *phy_dev;
 
+#ifdef CONFIG_BAIKAL_XGBE
+	/* phydevice - tranciever */
+	struct phy_device *phydev;
+#endif
+
 	/* Version related data */
 	struct xgbe_version_data *vdata;
 
@@ -1088,6 +1103,10 @@ struct xgbe_prv_data {
 	int ecc_irq;
 	int i2c_irq;
 	int channel_irq[XGBE_MAX_DMA_CHANNELS];
+#ifdef CONFIG_BAIKAL_XGBE
+	int channel_tx_irq[XGBE_MAX_DMA_CHANNELS];
+	int channel_rx_irq[XGBE_MAX_DMA_CHANNELS];
+#endif
 
 	unsigned int per_channel_irq;
 	unsigned int irq_count;
@@ -1327,6 +1346,10 @@ const struct ethtool_ops *xgbe_get_ethtool_ops(void);
 const struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void);
 #endif
 
+#ifdef CONFIG_BAIKAL_XGBE
+void xgbe_init_function_ptrs_phy_baikal(struct xgbe_phy_if *);
+#endif
+
 void xgbe_ptp_register(struct xgbe_prv_data *);
 void xgbe_ptp_unregister(struct xgbe_prv_data *);
 void xgbe_dump_tx_desc(struct xgbe_prv_data *, struct xgbe_ring *,
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 338e25a63..b7af9c386 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -65,6 +65,14 @@ config DWMAC_ANARION
 
 	  This selects the Anarion SoC glue layer support for the stmmac driver.
 
+config DWMAC_BAIKAL
+	tristate "Baikal Electronics DWMAC support"
+	depends on OF
+	help
+	  Support for Baikal Electronics DWMAC Ethernet.
+
+	  This selects the Baikal SoC glue layer support for the stmmac driver.
+
 config DWMAC_IPQ806X
 	tristate "QCA IPQ806x DWMAC support"
 	default ARCH_QCOM
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index c59926d96..1b7c8cbf1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -5,7 +5,7 @@ stmmac-objs:= stmmac_main.o stmmac_ethtool.o stmmac_mdio.o ring_mode.o	\
 	      dwmac100_core.o dwmac100_dma.o enh_desc.o norm_desc.o	\
 	      mmc_core.o stmmac_hwtstamp.o stmmac_ptp.o dwmac4_descs.o	\
 	      dwmac4_dma.o dwmac4_lib.o dwmac4_core.o dwmac5.o hwif.o \
-	      stmmac_tc.o dwxgmac2_core.o dwxgmac2_dma.o dwxgmac2_descs.o \
+	      stmmac_tc.o dwxgmac2_core.o dwxgmac2_dma.o dwxgmac2_descs.o stmmac_xsk.o\
 	      $(stmmac-y)
 
 stmmac-$(CONFIG_STMMAC_SELFTESTS) += stmmac_selftests.o
@@ -13,6 +13,7 @@ stmmac-$(CONFIG_STMMAC_SELFTESTS) += stmmac_selftests.o
 # Ordering matters. Generic driver must be last.
 obj-$(CONFIG_STMMAC_PLATFORM)	+= stmmac-platform.o
 obj-$(CONFIG_DWMAC_ANARION)	+= dwmac-anarion.o
+obj-$(CONFIG_DWMAC_BAIKAL)	+= dwmac-baikal.o
 obj-$(CONFIG_DWMAC_IPQ806X)	+= dwmac-ipq806x.o
 obj-$(CONFIG_DWMAC_LPC18XX)	+= dwmac-lpc18xx.o
 obj-$(CONFIG_DWMAC_MEDIATEK)	+= dwmac-mediatek.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c
new file mode 100644
index 000000000..b8d4bce36
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-baikal.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Baikal Electronics SoC DWMAC glue layer
+ *
+ * Copyright (C) 2015,2016,2021 Baikal Electronics JSC
+ * Authors: Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ *          Alexey Sheplyakov <asheplyakov@altlinux.org>
+ */
+
+#include <linux/clk.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "stmmac.h"
+#include "stmmac_platform.h"
+#include "common.h"
+#include "dwmac_dma.h"
+#include "dwmac1000_dma.h"
+
+#define MAC_GPIO	0x00e0		/* GPIO register */
+#define MAC_GPIO_GPO	(1 << 8)	/* Output port */
+
+struct baikal_dwmac {
+	struct device	*dev;
+	struct clk	*tx2_clk;
+};
+
+static int baikal_dwmac_dma_reset(void __iomem *ioaddr)
+{
+	int err;
+	u32 value;
+
+	/* DMA SW reset */
+	value = readl(ioaddr + DMA_BUS_MODE);
+	value |= DMA_BUS_MODE_SFT_RESET;
+	writel(value, ioaddr + DMA_BUS_MODE);
+
+	udelay(100);
+
+	/* Clear PHY reset */
+	value = readl(ioaddr + MAC_GPIO);
+	value |= MAC_GPIO_GPO;
+	writel(value, ioaddr + MAC_GPIO);
+	pr_info("PHY re-inited for Baikal DWMAC\n");
+
+	err = readl_poll_timeout(ioaddr + DMA_BUS_MODE, value,
+				 !(value & DMA_BUS_MODE_SFT_RESET),
+				 10000, 1000000);
+	if (err) {
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static const struct stmmac_dma_ops baikal_dwmac_dma_ops = {
+	.reset = baikal_dwmac_dma_reset,
+	.init = dwmac1000_dma_init,
+	.init_rx_chan = dwmac1000_dma_init_rx,
+	.init_tx_chan = dwmac1000_dma_init_tx,
+	.axi = dwmac1000_dma_axi,
+	.dump_regs = dwmac1000_dump_dma_regs,
+	.dma_rx_mode = dwmac1000_dma_operation_mode_rx,
+	.dma_tx_mode = dwmac1000_dma_operation_mode_tx,
+	.enable_dma_transmission = dwmac_enable_dma_transmission,
+	.enable_dma_irq = dwmac_enable_dma_irq,
+	.disable_dma_irq = dwmac_disable_dma_irq,
+	.start_tx = dwmac_dma_start_tx,
+	.stop_tx = dwmac_dma_stop_tx,
+	.start_rx = dwmac_dma_start_rx,
+	.stop_rx = dwmac_dma_stop_rx,
+	.dma_interrupt = dwmac_dma_interrupt,
+	.get_hw_feature = dwmac1000_get_hw_feature,
+	.rx_watchdog = dwmac1000_rx_watchdog
+};
+
+static struct mac_device_info *baikal_dwmac_setup(void *ppriv)
+{
+	struct mac_device_info *mac, *old_mac;
+	struct stmmac_priv *priv = ppriv;
+	int ret;
+	u32 value;
+
+	mac = devm_kzalloc(priv->device, sizeof(*mac), GFP_KERNEL);
+	if (!mac) {
+		return NULL;
+	}
+
+	/* Clear PHY reset */
+	value = readl(priv->ioaddr + MAC_GPIO);
+	value |= MAC_GPIO_GPO;
+	writel(value, priv->ioaddr + MAC_GPIO);
+
+	mac->dma = &baikal_dwmac_dma_ops;
+	old_mac = priv->hw;
+	priv->hw = mac;
+	ret = dwmac1000_setup(priv);
+	priv->hw = old_mac;
+	if (ret) {
+		dev_err(priv->device, "dwmac1000_setup: error %d", ret);
+		return NULL;
+	}
+
+	return mac;
+}
+
+static void baikal_dwmac_fix_mac_speed(void *priv, unsigned int speed)
+{
+	struct baikal_dwmac *dwmac = priv;
+	unsigned long tx2_clk_freq = 0;
+	dev_info(dwmac->dev, "fix_mac_speed new speed %u\n", speed);
+	switch (speed) {
+	case SPEED_1000:
+		tx2_clk_freq = 250000000;
+		break;
+	case SPEED_100:
+		tx2_clk_freq = 50000000;
+		break;
+	case SPEED_10:
+		tx2_clk_freq = 5000000;
+		break;
+	}
+
+	if (dwmac->tx2_clk != NULL && tx2_clk_freq) {
+		dev_info(dwmac->dev, "setting TX2 clock frequency to %lu\n", tx2_clk_freq);
+		clk_set_rate(dwmac->tx2_clk, tx2_clk_freq);
+	}
+}
+
+static int dwmac_baikal_probe(struct platform_device *pdev)
+{
+	struct plat_stmmacenet_data *plat_dat;
+	struct stmmac_resources stmmac_res;
+	struct baikal_dwmac *dwmac;
+	int ret;
+
+	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
+	if (ret) {
+		return ret;
+	}
+
+	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_warn(&pdev->dev, "no suitable DMA available\n");
+		return ret;
+	}
+
+	if (pdev->dev.of_node) {
+		plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+		if (IS_ERR(plat_dat)) {
+			dev_err(&pdev->dev, "dt configuration failed\n");
+			return PTR_ERR(plat_dat);
+		}
+	} else {
+		plat_dat = dev_get_platdata(&pdev->dev);
+		if (!plat_dat) {
+			dev_err(&pdev->dev, "no platform data provided\n");
+			return -EINVAL;
+		}
+
+		/* Set default value for multicast hash bins */
+		plat_dat->multicast_filter_bins = HASH_TABLE_SIZE;
+
+		/* Set default value for unicast filter entries */
+		plat_dat->unicast_filter_entries = 1;
+	}
+
+	dwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);
+	if (!dwmac) {
+		ret = -ENOMEM;
+		goto err_remove_config_dt;
+	}
+
+	dwmac->dev = &pdev->dev;
+	dwmac->tx2_clk = devm_clk_get(dwmac->dev, "tx2_clk");
+	if (IS_ERR(dwmac->tx2_clk)) {
+		dev_warn(&pdev->dev, "couldn't get TX2 clock\n");
+		dwmac->tx2_clk = NULL;
+	}
+
+	plat_dat->fix_mac_speed = baikal_dwmac_fix_mac_speed;
+	plat_dat->bsp_priv = dwmac;
+	plat_dat->has_gmac = 1;
+	plat_dat->enh_desc = 1;
+	plat_dat->tx_coe = 1;
+	plat_dat->rx_coe = 1;
+	/* TODO: set CSR correct clock in dts */
+	plat_dat->clk_csr = 3;
+	plat_dat->setup = baikal_dwmac_setup;
+
+	dev_info(&pdev->dev, "Baikal Electronics DWMAC glue driver\n");
+
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret) {
+		goto err_remove_config_dt;
+	}
+
+	return 0;
+
+err_remove_config_dt:
+	stmmac_remove_config_dt(pdev, plat_dat);
+
+	return ret;
+}
+
+static const struct of_device_id dwmac_baikal_match[] = {
+	{ .compatible = "be,dwmac" },
+	{ .compatible = "be,dwmac-3.710" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dwmac_baikal_match);
+
+static struct platform_driver dwmac_baikal_driver = {
+	.probe	= dwmac_baikal_probe,
+	.remove	= stmmac_pltfr_remove,
+	.driver	= {
+		.name = "baikal-dwmac",
+		.pm = &stmmac_pltfr_pm_ops,
+		.of_match_table = of_match_ptr(dwmac_baikal_match)
+	}
+};
+module_platform_driver(dwmac_baikal_driver);
+
+MODULE_DESCRIPTION("Baikal DWMAC glue driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index 1d0b64bd1..65e8cd640 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -565,3 +565,4 @@ int dwmac1000_setup(struct stmmac_priv *priv)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(dwmac1000_setup);
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
index 2bac49b49..d27d52925 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c
@@ -16,7 +16,7 @@
 #include "dwmac1000.h"
 #include "dwmac_dma.h"
 
-static void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
+void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
 {
 	u32 value = readl(ioaddr + DMA_AXI_BUS_MODE);
 	int i;
@@ -69,9 +69,10 @@ static void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)
 
 	writel(value, ioaddr + DMA_AXI_BUS_MODE);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_axi);
 
-static void dwmac1000_dma_init(void __iomem *ioaddr,
-			       struct stmmac_dma_cfg *dma_cfg, int atds)
+void dwmac1000_dma_init(void __iomem *ioaddr,
+		        struct stmmac_dma_cfg *dma_cfg, int atds)
 {
 	u32 value = readl(ioaddr + DMA_BUS_MODE);
 	int txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;
@@ -109,22 +110,25 @@ static void dwmac1000_dma_init(void __iomem *ioaddr,
 	/* Mask interrupts by writing to CSR7 */
 	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_init);
 
-static void dwmac1000_dma_init_rx(void __iomem *ioaddr,
-				  struct stmmac_dma_cfg *dma_cfg,
-				  dma_addr_t dma_rx_phy, u32 chan)
+void dwmac1000_dma_init_rx(void __iomem *ioaddr,
+			   struct stmmac_dma_cfg *dma_cfg,
+			   dma_addr_t dma_rx_phy, u32 chan)
 {
 	/* RX descriptor base address list must be written into DMA CSR3 */
 	writel(lower_32_bits(dma_rx_phy), ioaddr + DMA_RCV_BASE_ADDR);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_init_rx);
 
-static void dwmac1000_dma_init_tx(void __iomem *ioaddr,
-				  struct stmmac_dma_cfg *dma_cfg,
-				  dma_addr_t dma_tx_phy, u32 chan)
+void dwmac1000_dma_init_tx(void __iomem *ioaddr,
+			   struct stmmac_dma_cfg *dma_cfg,
+			   dma_addr_t dma_tx_phy, u32 chan)
 {
 	/* TX descriptor base address list must be written into DMA CSR4 */
 	writel(lower_32_bits(dma_tx_phy), ioaddr + DMA_TX_BASE_ADDR);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_init_tx);
 
 static u32 dwmac1000_configure_fc(u32 csr6, int rxfifosz)
 {
@@ -147,8 +151,8 @@ static u32 dwmac1000_configure_fc(u32 csr6, int rxfifosz)
 	return csr6;
 }
 
-static void dwmac1000_dma_operation_mode_rx(void __iomem *ioaddr, int mode,
-					    u32 channel, int fifosz, u8 qmode)
+void dwmac1000_dma_operation_mode_rx(void __iomem *ioaddr, int mode,
+				     u32 channel, int fifosz, u8 qmode)
 {
 	u32 csr6 = readl(ioaddr + DMA_CONTROL);
 
@@ -174,9 +178,10 @@ static void dwmac1000_dma_operation_mode_rx(void __iomem *ioaddr, int mode,
 
 	writel(csr6, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_operation_mode_rx);
 
-static void dwmac1000_dma_operation_mode_tx(void __iomem *ioaddr, int mode,
-					    u32 channel, int fifosz, u8 qmode)
+void dwmac1000_dma_operation_mode_tx(void __iomem *ioaddr, int mode,
+				     u32 channel, int fifosz, u8 qmode)
 {
 	u32 csr6 = readl(ioaddr + DMA_CONTROL);
 
@@ -207,8 +212,9 @@ static void dwmac1000_dma_operation_mode_tx(void __iomem *ioaddr, int mode,
 
 	writel(csr6, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dma_operation_mode_tx);
 
-static void dwmac1000_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space)
+void dwmac1000_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space)
 {
 	int i;
 
@@ -217,9 +223,10 @@ static void dwmac1000_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space)
 			reg_space[DMA_BUS_MODE / 4 + i] =
 				readl(ioaddr + DMA_BUS_MODE + i * 4);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_dump_dma_regs);
 
-static void dwmac1000_get_hw_feature(void __iomem *ioaddr,
-				     struct dma_features *dma_cap)
+void dwmac1000_get_hw_feature(void __iomem *ioaddr,
+			      struct dma_features *dma_cap)
 {
 	u32 hw_cap = readl(ioaddr + DMA_HW_FEATURE);
 
@@ -253,12 +260,14 @@ static void dwmac1000_get_hw_feature(void __iomem *ioaddr,
 	/* Alternate (enhanced) DESC mode */
 	dma_cap->enh_desc = (hw_cap & DMA_HW_FEAT_ENHDESSEL) >> 24;
 }
+EXPORT_SYMBOL_GPL(dwmac1000_get_hw_feature);
 
-static void dwmac1000_rx_watchdog(void __iomem *ioaddr, u32 riwt,
-				  u32 number_chan)
+void dwmac1000_rx_watchdog(void __iomem *ioaddr, u32 riwt,
+			   u32 number_chan)
 {
 	writel(riwt, ioaddr + DMA_RX_WATCHDOG);
 }
+EXPORT_SYMBOL_GPL(dwmac1000_rx_watchdog);
 
 const struct stmmac_dma_ops dwmac1000_dma_ops = {
 	.reset = dwmac_dma_reset,
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.h
new file mode 100644
index 000000000..b1e39a109
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef __DWMAC1000_DMA_H__
+#define __DWMAC1000_DMA_H__
+#include "dwmac1000.h"
+
+void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi);
+void dwmac1000_dma_init(void __iomem *ioaddr,
+		        struct stmmac_dma_cfg *dma_cfg, int atds);
+void dwmac1000_dma_init_rx(void __iomem *ioaddr,
+			   struct stmmac_dma_cfg *dma_cfg,
+			   dma_addr_t dma_rx_phy, u32 chan);
+void dwmac1000_dma_init_tx(void __iomem *ioaddr,
+			   struct stmmac_dma_cfg *dma_cfg,
+			   dma_addr_t dma_tx_phy, u32 chan);
+void dwmac1000_dma_operation_mode_rx(void __iomem *ioaddr, int mode,
+				     u32 channel, int fifosz, u8 qmode);
+void dwmac1000_dma_operation_mode_tx(void __iomem *ioaddr, int mode,
+				     u32 channel, int fifosz, u8 qmode);
+void dwmac1000_dump_dma_regs(void __iomem *ioaddr, u32 *reg_space);
+
+void dwmac1000_get_hw_feature(void __iomem *ioaddr,
+			      struct dma_features *dma_cap);
+
+void dwmac1000_rx_watchdog(void __iomem *ioaddr, u32 riwt, u32 number_chan);
+#endif /* __DWMAC1000_DMA_H__ */
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
index 1bc25aa86..bb1af371b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
@@ -36,16 +36,19 @@ void dwmac_enable_dma_transmission(void __iomem *ioaddr)
 {
 	writel(1, ioaddr + DMA_XMT_POLL_DEMAND);
 }
+EXPORT_SYMBOL_GPL(dwmac_enable_dma_transmission);
 
 void dwmac_enable_dma_irq(void __iomem *ioaddr, u32 chan)
 {
 	writel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);
 }
+EXPORT_SYMBOL_GPL(dwmac_enable_dma_irq);
 
 void dwmac_disable_dma_irq(void __iomem *ioaddr, u32 chan)
 {
 	writel(0, ioaddr + DMA_INTR_ENA);
 }
+EXPORT_SYMBOL_GPL(dwmac_disable_dma_irq);
 
 void dwmac_dma_start_tx(void __iomem *ioaddr, u32 chan)
 {
@@ -53,6 +56,7 @@ void dwmac_dma_start_tx(void __iomem *ioaddr, u32 chan)
 	value |= DMA_CONTROL_ST;
 	writel(value, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac_dma_start_tx);
 
 void dwmac_dma_stop_tx(void __iomem *ioaddr, u32 chan)
 {
@@ -60,6 +64,7 @@ void dwmac_dma_stop_tx(void __iomem *ioaddr, u32 chan)
 	value &= ~DMA_CONTROL_ST;
 	writel(value, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac_dma_stop_tx);
 
 void dwmac_dma_start_rx(void __iomem *ioaddr, u32 chan)
 {
@@ -67,6 +72,7 @@ void dwmac_dma_start_rx(void __iomem *ioaddr, u32 chan)
 	value |= DMA_CONTROL_SR;
 	writel(value, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac_dma_start_rx);
 
 void dwmac_dma_stop_rx(void __iomem *ioaddr, u32 chan)
 {
@@ -74,6 +80,7 @@ void dwmac_dma_stop_rx(void __iomem *ioaddr, u32 chan)
 	value &= ~DMA_CONTROL_SR;
 	writel(value, ioaddr + DMA_CONTROL);
 }
+EXPORT_SYMBOL_GPL(dwmac_dma_stop_rx);
 
 #ifdef DWMAC_DMA_DEBUG
 static void show_tx_process_state(unsigned int status)
@@ -215,6 +222,7 @@ int dwmac_dma_interrupt(void __iomem *ioaddr,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(dwmac_dma_interrupt);
 
 void dwmac_dma_flush_tx_fifo(void __iomem *ioaddr)
 {
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index d993fc7e8..f5dbfc405 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -12,6 +12,8 @@
 #define STMMAC_RESOURCE_NAME   "stmmaceth"
 #define DRV_MODULE_VERSION	"Jan_2016"
 
+#define STMMAC_TX_NEED_RESCHED	(-1)
+
 #include <linux/clk.h>
 #include <linux/if_vlan.h>
 #include <linux/stmmac.h>
@@ -37,6 +39,9 @@ struct stmmac_tx_info {
 	unsigned len;
 	bool last_segment;
 	bool is_jumbo;
+	u8 tx_source_type;
+	void *page_addr;
+	struct page *page;
 };
 
 /* Frequently used values are kept adjacent for cache effect */
@@ -56,6 +61,15 @@ struct stmmac_tx_queue {
 	u32 mss;
 };
 
+/* For XSK socket */
+struct stmmac_xsk_desc_map {
+	/* For Rx descriptors only */
+	dma_addr_t dma_addr;
+	void *cpu_addr;
+	u64 handle;
+	u32 page_offset;
+};
+
 struct stmmac_rx_buffer {
 	struct page *page;
 	struct page *sec_page;
@@ -82,6 +96,15 @@ struct stmmac_rx_queue {
 		unsigned int len;
 		unsigned int error;
 	} state;
+
+	/* AF_XDP support */
+	struct xdp_rxq_info xdp_rxq;
+	struct zero_copy_allocator zca;
+	/* Buffer info (extra data) is used for XSK */
+	struct stmmac_xsk_desc_map desc_map[DMA_RX_SIZE];
+	struct timer_list rx_init_timer;
+	struct timer_list rx_refill_timer;
+	bool rx_empty;
 };
 
 struct stmmac_channel {
@@ -220,6 +243,7 @@ struct stmmac_priv {
 
 	unsigned long state;
 	struct workqueue_struct *wq;
+	struct workqueue_struct *refill_wq;
 	struct work_struct service_task;
 
 	/* TC Handling */
@@ -234,6 +258,19 @@ struct stmmac_priv {
 
 	/* Receive Side Scaling */
 	struct stmmac_rss rss;
+
+	/* AF_XDP support */
+	struct bpf_prog *xdp_prog;
+	struct xdp_umem **xsk_umems;
+	struct zero_copy_allocator zca;
+	u16 num_xsk_umems_used;
+	u16 num_xsk_umems;
+
+	/* AF_XDP add to start_xmit() asynchronous way of transferring data so add
+	 * locking mechanism to stop competition. Rx lock mechanism is build in
+	 * Rx cleaning function.
+	 */
+	atomic_t tx_lock;
 };
 
 enum stmmac_state {
@@ -243,6 +280,15 @@ enum stmmac_state {
 	STMMAC_SERVICE_SCHED,
 };
 
+int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue);
+int stmmac_hw_restrict_setup(struct net_device *dev, bool init_ptp);
+int init_dma_desc_rings(struct net_device *dev, gfp_t flags);
+void init_dma_rx_desc_rings_xsk(struct net_device *dev);
+void stmmac_stop_all_dma(struct stmmac_priv *priv);
+void stmmac_start_all_dma(struct stmmac_priv *priv);
+void free_dma_rx_desc_resources(struct stmmac_priv *priv);
+int alloc_dma_rx_desc_resources(struct stmmac_priv *priv);
+
 int stmmac_mdio_unregister(struct net_device *ndev);
 int stmmac_mdio_register(struct net_device *ndev);
 int stmmac_mdio_reset(struct mii_bus *mii);
@@ -258,6 +304,7 @@ int stmmac_dvr_probe(struct device *device,
 		     struct stmmac_resources *res);
 void stmmac_disable_eee_mode(struct stmmac_priv *priv);
 bool stmmac_eee_init(struct stmmac_priv *priv);
+u32 stmmac_rx_dirty(struct stmmac_priv *priv, u32 queue);
 
 #if IS_ENABLED(CONFIG_STMMAC_SELFTESTS)
 void stmmac_selftest_run(struct net_device *dev,
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 8e7c60e02..f79efe949 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -44,6 +44,7 @@
 #include "dwmac1000.h"
 #include "dwxgmac2.h"
 #include "hwif.h"
+#include "stmmac_xsk.h"
 
 #define	STMMAC_ALIGN(x)		ALIGN(ALIGN(x, SMP_CACHE_BYTES), 16)
 #define	TSO_MAX_BUFF_SIZE	(SZ_16K - 1)
@@ -262,7 +263,7 @@ static void print_pkt(unsigned char *buf, int len)
 	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, buf, len);
 }
 
-static inline u32 stmmac_tx_avail(struct stmmac_priv *priv, u32 queue)
+inline u32 stmmac_tx_avail(struct stmmac_priv *priv, u32 queue)
 {
 	struct stmmac_tx_queue *tx_q = &priv->tx_queue[queue];
 	u32 avail;
@@ -280,7 +281,7 @@ static inline u32 stmmac_tx_avail(struct stmmac_priv *priv, u32 queue)
  * @priv: driver private structure
  * @queue: RX queue index
  */
-static inline u32 stmmac_rx_dirty(struct stmmac_priv *priv, u32 queue)
+u32 stmmac_rx_dirty(struct stmmac_priv *priv, u32 queue)
 {
 	struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
 	u32 dirty;
@@ -1257,6 +1258,47 @@ static void stmmac_free_tx_buffer(struct stmmac_priv *priv, u32 queue, int i)
 	}
 }
 
+/**
+ * init_dma_rx_desc_rings_xsk() - initialize allocated XSK descriptor rings
+ * @dev: associated net device
+ */
+void init_dma_rx_desc_rings_xsk(struct net_device *dev)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	u32 rx_count = priv->plat->rx_queues_to_use;
+	int bfsize = 0;
+	int queue;
+
+	bfsize = stmmac_set_16kib_bfsize(priv, dev->mtu);
+	if (bfsize < 0)
+		bfsize = 0;
+
+	if (bfsize < BUF_SIZE_16KiB)
+		bfsize = stmmac_set_bfsize(dev->mtu, priv->dma_buf_sz);
+
+	priv->dma_buf_sz = bfsize;
+
+	for (queue = 0; queue < rx_count; queue++) {
+		struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+
+		netif_dbg(priv, probe, priv->dev,
+			  "(%s) dma_rx_phy=0x%08x\n", __func__,
+			  (u32)rx_q->dma_rx_phy);
+
+		stmmac_clear_rx_descriptors(priv, queue);
+
+		/* Setup the chained descriptor addresses */
+		if (priv->mode == STMMAC_CHAIN_MODE) {
+			if (priv->extend_desc)
+				stmmac_mode_init(priv, rx_q->dma_erx,
+						 rx_q->dma_rx_phy, DMA_RX_SIZE, 1);
+			else
+				stmmac_mode_init(priv, rx_q->dma_rx,
+						 rx_q->dma_rx_phy, DMA_RX_SIZE, 0);
+		}
+	}
+}
+
 /**
  * init_dma_rx_desc_rings - init the RX descriptor rings
  * @dev: net device structure
@@ -1265,7 +1307,7 @@ static void stmmac_free_tx_buffer(struct stmmac_priv *priv, u32 queue, int i)
  * and allocates the socket buffers. It supports the chained and ring
  * modes.
  */
-static int init_dma_rx_desc_rings(struct net_device *dev, gfp_t flags)
+int init_dma_rx_desc_rings(struct net_device *dev, gfp_t flags)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 	u32 rx_count = priv->plat->rx_queues_to_use;
@@ -1396,7 +1438,7 @@ static int init_dma_tx_desc_rings(struct net_device *dev)
  * and allocates the socket buffers. It supports the chained and ring
  * modes.
  */
-static int init_dma_desc_rings(struct net_device *dev, gfp_t flags)
+int init_dma_desc_rings(struct net_device *dev, gfp_t flags)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 	int ret;
@@ -1458,7 +1500,7 @@ static void stmmac_free_tx_skbufs(struct stmmac_priv *priv)
  * free_dma_rx_desc_resources - free RX dma desc resources
  * @priv: private structure
  */
-static void free_dma_rx_desc_resources(struct stmmac_priv *priv)
+void free_dma_rx_desc_resources(struct stmmac_priv *priv)
 {
 	u32 rx_count = priv->plat->rx_queues_to_use;
 	u32 queue;
@@ -1525,7 +1567,7 @@ static void free_dma_tx_desc_resources(struct stmmac_priv *priv)
  * reception, for example, it pre-allocated the RX socket buffer in order to
  * allow zero-copy mechanism.
  */
-static int alloc_dma_rx_desc_resources(struct stmmac_priv *priv)
+int alloc_dma_rx_desc_resources(struct stmmac_priv *priv)
 {
 	u32 rx_count = priv->plat->rx_queues_to_use;
 	int ret = -ENOMEM;
@@ -1753,7 +1795,7 @@ static void stmmac_stop_tx_dma(struct stmmac_priv *priv, u32 chan)
  * Description:
  * This starts all the RX and TX DMA channels
  */
-static void stmmac_start_all_dma(struct stmmac_priv *priv)
+void stmmac_start_all_dma(struct stmmac_priv *priv)
 {
 	u32 rx_channels_count = priv->plat->rx_queues_to_use;
 	u32 tx_channels_count = priv->plat->tx_queues_to_use;
@@ -1772,7 +1814,7 @@ static void stmmac_start_all_dma(struct stmmac_priv *priv)
  * Description:
  * This stops the RX and TX DMA channels
  */
-static void stmmac_stop_all_dma(struct stmmac_priv *priv)
+void stmmac_stop_all_dma(struct stmmac_priv *priv)
 {
 	u32 rx_channels_count = priv->plat->rx_queues_to_use;
 	u32 tx_channels_count = priv->plat->tx_queues_to_use;
@@ -1854,17 +1896,18 @@ static void stmmac_dma_operation_mode(struct stmmac_priv *priv)
  * @queue: TX queue index
  * Description: it reclaims the transmit resources after transmission completes.
  */
-static int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
+int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 {
 	struct stmmac_tx_queue *tx_q = &priv->tx_queue[queue];
 	unsigned int bytes_compl = 0, pkts_compl = 0;
 	unsigned int entry, count = 0;
+	struct stmmac_tx_info *tx_info;
+	unsigned int xsk_return = 0;
 
 	__netif_tx_lock_bh(netdev_get_tx_queue(priv->dev, queue));
-
 	priv->xstats.tx_clean++;
-
 	entry = tx_q->dirty_tx;
+
 	while ((entry != tx_q->cur_tx) && (count < budget)) {
 		struct sk_buff *skb = tx_q->tx_skbuff[entry];
 		struct dma_desc *p;
@@ -1875,14 +1918,54 @@ static int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 		else
 			p = tx_q->dma_tx + entry;
 
-		status = stmmac_tx_status(priv, &priv->dev->stats,
-				&priv->xstats, p, priv->ioaddr);
-		/* Check if the descriptor is owned by the DMA */
+		status = stmmac_tx_status(priv, &priv->dev->stats, &priv->xstats, p,
+								  priv->ioaddr);
+
+		/* Check if descriptor is ready to use */
 		if (unlikely(status & tx_dma_own))
 			break;
 
 		count++;
 
+		/* Different types of descriptors use different ways to clean */
+		tx_info = tx_q->tx_skbuff_dma + entry;
+		if (tx_info->tx_source_type == STMMAC_TX_SOURCE_UMEM) {
+			/* UMEM */
+			tx_info->tx_source_type = STMMAC_TX_SOURCE_RESET;
+
+			stmmac_clean_desc3(priv, tx_q, p);
+			stmmac_release_tx_desc(priv, p, priv->mode);
+			tx_q->tx_skbuff_dma[entry].buf = 0;
+			tx_q->tx_skbuff_dma[entry].len = 0;
+			tx_q->tx_skbuff_dma[entry].map_as_page = false;
+			tx_q->tx_skbuff_dma[entry].last_segment = false;
+			tx_q->tx_skbuff_dma[entry].is_jumbo = false;
+
+			entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+			xsk_return++;
+			continue;
+		} else if (tx_info->tx_source_type == STMMAC_TX_SOURCE_FRAME) {
+			/* UMEM frame */
+			tx_info->tx_source_type = STMMAC_TX_SOURCE_RESET;
+
+			dma_unmap_single(priv->device,
+					 tx_q->tx_skbuff_dma[entry].buf,
+					 tx_q->tx_skbuff_dma[entry].len,
+					 DMA_TO_DEVICE);
+
+			stmmac_clean_desc3(priv, tx_q, p);
+			stmmac_release_tx_desc(priv, p, priv->mode);
+			tx_q->tx_skbuff_dma[entry].buf = 0;
+			tx_q->tx_skbuff_dma[entry].len = 0;
+			tx_q->tx_skbuff_dma[entry].map_as_page = false;
+			tx_q->tx_skbuff_dma[entry].last_segment = false;
+			tx_q->tx_skbuff_dma[entry].is_jumbo = false;
+
+			entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+			continue;
+		}
+		/* if STMMAC_TX_SOURCE_SKB */
+
 		/* Make sure descriptor fields are read after reading
 		 * the own bit.
 		 */
@@ -1906,11 +1989,12 @@ static int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 					       tx_q->tx_skbuff_dma[entry].buf,
 					       tx_q->tx_skbuff_dma[entry].len,
 					       DMA_TO_DEVICE);
-			else
+			else {
 				dma_unmap_single(priv->device,
 						 tx_q->tx_skbuff_dma[entry].buf,
 						 tx_q->tx_skbuff_dma[entry].len,
 						 DMA_TO_DEVICE);
+			}
 			tx_q->tx_skbuff_dma[entry].buf = 0;
 			tx_q->tx_skbuff_dma[entry].len = 0;
 			tx_q->tx_skbuff_dma[entry].map_as_page = false;
@@ -1934,6 +2018,13 @@ static int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 	}
 	tx_q->dirty_tx = entry;
 
+	if (xsk_return != 0) {
+		xsk_umem_complete_tx(priv->xsk_umems[queue], xsk_return);
+
+		if (xsk_umem_uses_need_wakeup(priv->xsk_umems[queue]))
+			xsk_set_tx_need_wakeup(priv->xsk_umems[queue]);
+	}
+
 	netdev_tx_completed_queue(netdev_get_tx_queue(priv->dev, queue),
 				  pkts_compl, bytes_compl);
 
@@ -1941,8 +2032,7 @@ static int stmmac_tx_clean(struct stmmac_priv *priv, int budget, u32 queue)
 								queue))) &&
 	    stmmac_tx_avail(priv, queue) > STMMAC_TX_THRESH) {
 
-		netif_dbg(priv, tx_done, priv->dev,
-			  "%s: restart transmit\n", __func__);
+		netif_dbg(priv, tx_done, priv->dev, "%s: restart transmit\n", __func__);
 		netif_tx_wake_queue(netdev_get_tx_queue(priv->dev, queue));
 	}
 
@@ -2498,6 +2588,111 @@ static void stmmac_safety_feat_configuration(struct stmmac_priv *priv)
 	}
 }
 
+/**
+ * stmmac_hw_restrict_setup() - setup GEMAC HW without configure and start DMA.
+ * @dev: network device associated with HW
+ * @init_ptp: flag to do initialization of ptp
+ *
+ * This restricted version of stmmac_hw_setup() is used to support AF_XDP.
+ * The main reason is not allow to start DMA transaction. Also it doesn't HW
+ * reset whole GEMAC controller just set registers to initial values. It helps
+ * to do restart quicker than HW restart all GEMAC.
+ */
+int stmmac_hw_restrict_setup(struct net_device *dev, bool init_ptp)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	u32 rx_cnt = priv->plat->rx_queues_to_use;
+	u32 tx_cnt = priv->plat->tx_queues_to_use;
+	u32 chan;
+	int ret;
+
+	/* DMA initialization and SW reset */
+	ret = stmmac_init_dma_engine_xsk(priv);
+	if (ret < 0) {
+		netdev_err(priv->dev, "%s: DMA engine initialization failed\n",
+			   __func__);
+		return ret;
+	}
+
+	/* Copy the MAC addr into the HW  */
+	stmmac_set_umac_addr(priv, priv->hw, dev->dev_addr, 0);
+
+	/* PS and related bits will be programmed according to the speed */
+	if (priv->hw->pcs) {
+		int speed = priv->plat->mac_port_sel_speed;
+
+		if ((speed == SPEED_10) || (speed == SPEED_100) ||
+		    (speed == SPEED_1000)) {
+			priv->hw->ps = speed;
+		} else {
+			dev_warn(priv->device, "invalid port speed\n");
+			priv->hw->ps = 0;
+		}
+	}
+
+	/* Initialize MTL*/
+	stmmac_mtl_configuration(priv);
+
+	/* Initialize Safety Features */
+	stmmac_safety_feat_configuration(priv);
+
+	ret = stmmac_rx_ipc(priv, priv->hw);
+	if (!ret) {
+		netdev_warn(priv->dev, "RX IPC Checksum Offload disabled\n");
+		priv->plat->rx_coe = STMMAC_RX_COE_NONE;
+		priv->hw->rx_csum = 0;
+	}
+
+	/* Set the HW DMA mode and the COE */
+	stmmac_dma_operation_mode(priv);
+
+	stmmac_mmc_setup(priv);
+
+	if (init_ptp) {
+		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
+		if (ret < 0)
+			netdev_warn(priv->dev, "failed to enable PTP reference clock: %d\n", ret);
+
+		ret = stmmac_init_ptp(priv);
+		if (ret == -EOPNOTSUPP)
+			netdev_warn(priv->dev, "PTP not supported by HW\n");
+		else if (ret)
+			netdev_warn(priv->dev, "PTP init failed\n");
+	}
+
+	priv->tx_lpi_timer = STMMAC_DEFAULT_TWT_LS;
+
+	if (priv->use_riwt) {
+		ret = stmmac_rx_watchdog(priv, priv->ioaddr, MIN_DMA_RIWT, rx_cnt);
+		if (!ret)
+			priv->rx_riwt = MIN_DMA_RIWT;
+	}
+
+	if (priv->hw->pcs)
+		stmmac_pcs_ctrl_ane(priv, priv->ioaddr, 1, priv->hw->ps, 0);
+
+	/* set TX and RX rings length */
+	stmmac_set_rings_length(priv);
+
+	/* Enable TSO */
+	if (priv->tso) {
+		for (chan = 0; chan < tx_cnt; chan++)
+			stmmac_enable_tso(priv, priv->ioaddr, 1, chan);
+	}
+
+	/* Enable Split Header */
+	if (priv->sph && priv->hw->rx_csum) {
+		for (chan = 0; chan < rx_cnt; chan++)
+			stmmac_enable_sph(priv, priv->ioaddr, 1, chan);
+	}
+
+	/* VLAN Tag Insertion */
+	if (priv->dma_cap.vlins)
+		stmmac_enable_vlan(priv, priv->hw, STMMAC_VLAN_INSERT);
+
+	return 0;
+}
+
 /**
  * stmmac_hw_setup - setup mac in a usable state.
  *  @dev : pointer to the device structure.
@@ -2726,6 +2921,8 @@ static int stmmac_open(struct net_device *dev)
 	stmmac_enable_all_queues(priv);
 	netif_tx_start_all_queues(priv->dev);
 
+	atomic_set(&priv->tx_lock, 0);
+
 	return 0;
 
 lpiirq_error:
@@ -3125,27 +3322,39 @@ static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
 	dma_addr_t des;
 	bool has_vlan;
 	int entry;
+	u32 tx_avail = stmmac_tx_avail(priv, queue);
 
 	tx_q = &priv->tx_queue[queue];
 
+	if (atomic_read(&priv->tx_lock))
+		return NETDEV_TX_BUSY;
+	else
+		atomic_set(&priv->tx_lock, 1);
+
 	if (priv->tx_path_in_lpi_mode)
 		stmmac_disable_eee_mode(priv);
 
 	/* Manage oversized TCP frames for GMAC4 device */
 	if (skb_is_gso(skb) && priv->tso) {
-		if (skb_shinfo(skb)->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))
-			return stmmac_tso_xmit(skb, dev);
+		if (skb_shinfo(skb)->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {
+			netdev_tx_t result;
+
+			result = stmmac_tso_xmit(skb, dev);
+			atomic_set(&priv->tx_lock, 0);
+
+			return result;
+		}
 	}
 
-	if (unlikely(stmmac_tx_avail(priv, queue) < nfrags + 1)) {
+	if (unlikely(tx_avail < nfrags + 1)) {
 		if (!netif_tx_queue_stopped(netdev_get_tx_queue(dev, queue))) {
-			netif_tx_stop_queue(netdev_get_tx_queue(priv->dev,
-								queue));
+			netif_tx_stop_queue(netdev_get_tx_queue(priv->dev, queue));
 			/* This is a hard error, log it. */
-			netdev_err(priv->dev,
-				   "%s: Tx Ring full when queue awake\n",
-				   __func__);
+			netdev_err(priv->dev, "%s: Tx Ring full when queue awake\n",
+					   __func__);
 		}
+		atomic_set(&priv->tx_lock, 0);
+
 		return NETDEV_TX_BUSY;
 	}
 
@@ -3322,12 +3531,17 @@ static netdev_tx_t stmmac_xmit(struct sk_buff *skb, struct net_device *dev)
 	stmmac_set_tx_tail_ptr(priv, priv->ioaddr, tx_q->tx_tail_addr, queue);
 	stmmac_tx_timer_arm(priv, queue);
 
+	atomic_set(&priv->tx_lock, 0);
+
 	return NETDEV_TX_OK;
 
 dma_map_err:
 	netdev_err(priv->dev, "Tx DMA map failed\n");
 	dev_kfree_skb(skb);
 	priv->dev->stats.tx_dropped++;
+
+	atomic_set(&priv->tx_lock, 0);
+
 	return NETDEV_TX_OK;
 }
 
@@ -3659,9 +3873,14 @@ static int stmmac_napi_poll_rx(struct napi_struct *napi, int budget)
 
 	priv->xstats.napi_poll++;
 
-	work_done = stmmac_rx(priv, budget, chan);
+    if (priv->xsk_umems && priv->xsk_umems[chan])
+            work_done = stmmac_rx_xsk(priv, budget, chan);
+    else
+            work_done = stmmac_rx(priv, budget, chan);
+
 	if (work_done < budget && napi_complete_done(napi, work_done))
 		stmmac_enable_dma_irq(priv, priv->ioaddr, chan);
+
 	return work_done;
 }
 
@@ -3672,12 +3891,26 @@ static int stmmac_napi_poll_tx(struct napi_struct *napi, int budget)
 	struct stmmac_priv *priv = ch->priv_data;
 	struct stmmac_tx_queue *tx_q;
 	u32 chan = ch->index;
-	int work_done;
+	int work_done = 0;
 
 	priv->xstats.napi_poll++;
 
-	work_done = stmmac_tx_clean(priv, DMA_TX_SIZE, chan);
-	work_done = min(work_done, budget);
+	if (priv->xsk_umems && priv->xsk_umems[chan]) {
+		stmmac_tx_clean(priv, DMA_TX_SIZE, chan);
+	} else {
+		work_done = stmmac_tx_clean(priv, DMA_TX_SIZE, chan);
+		work_done = min(work_done, budget);
+	}
+
+	/* If UMEM is used then start transmit with zero-copy */
+	if (!atomic_read(&priv->tx_lock)) {
+		atomic_set(&priv->tx_lock, 1);
+
+		if (priv->xsk_umems && priv->xsk_umems[chan])
+			work_done = stmmac_xdp_transmit_zc(priv, budget);
+
+		atomic_set(&priv->tx_lock, 0);
+	}
 
 	if (work_done < budget)
 		napi_complete_done(napi, work_done);
@@ -4307,6 +4540,9 @@ static const struct net_device_ops stmmac_netdev_ops = {
 	.ndo_set_mac_address = stmmac_set_mac_address,
 	.ndo_vlan_rx_add_vid = stmmac_vlan_rx_add_vid,
 	.ndo_vlan_rx_kill_vid = stmmac_vlan_rx_kill_vid,
+	.ndo_bpf = stmmac_bpf,
+	.ndo_xdp_xmit = stmmac_xdp_xmit,
+	.ndo_xsk_wakeup = stmmac_xsk_wakeup,
 };
 
 static void stmmac_reset_subtask(struct stmmac_priv *priv)
@@ -4494,6 +4730,12 @@ int stmmac_dvr_probe(struct device *device,
 		return -ENOMEM;
 	}
 
+	priv->refill_wq = create_singlethread_workqueue("stmmac_refill_wq");
+	if (!priv->refill_wq) {
+		dev_err(priv->device, "failed to create refill workqueue\n");
+		return -ENOMEM;
+	}
+
 	INIT_WORK(&priv->service_task, stmmac_service_task);
 
 	/* Override with kernel parameters if supplied XXX CRS XXX
@@ -4695,6 +4937,7 @@ int stmmac_dvr_probe(struct device *device,
 	}
 error_hw_init:
 	destroy_workqueue(priv->wq);
+	destroy_workqueue(priv->refill_wq);
 
 	return ret;
 }
@@ -4731,6 +4974,7 @@ int stmmac_dvr_remove(struct device *dev)
 	    priv->hw->pcs != STMMAC_PCS_RTBI)
 		stmmac_mdio_unregister(ndev);
 	destroy_workqueue(priv->wq);
+	destroy_workqueue(priv->refill_wq);
 	mutex_destroy(&priv->lock);
 
 	return 0;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
new file mode 100644
index 000000000..0817e0df3
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.c
@@ -0,0 +1,1536 @@
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/if.h>
+#include <linux/if_vlan.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/prefetch.h>
+#include <linux/pinctrl/consumer.h>
+#include <net/xdp_sock.h>
+#include <net/xdp.h>
+#include "stmmac_xsk.h"
+
+/**
+ * stmmac_zca_free() - this function reuse UMEM memory again with dirty desc.
+ * @alloc: copy allocator structure
+ * @handle: pointer of UMEM memory
+ *
+ * Called in case of using ZERO copy memory model when convert to XDP frame.
+ */
+static void stmmac_zca_free(struct zero_copy_allocator *alloc, unsigned long handle)
+{
+	int queue = 0;
+	struct stmmac_priv *priv = container_of(alloc, struct stmmac_priv, zca);
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+	unsigned int entry = rx_q->dirty_rx;
+	struct stmmac_xsk_desc_map *buf = &rx_q->desc_map[entry];
+	struct xdp_umem *umem = priv->xsk_umems[queue];
+	struct dma_desc *p;
+	u64 hr, mask;
+	size_t len;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	if (priv->extend_desc)
+		p = (struct dma_desc *)(rx_q->dma_erx + entry);
+	else
+		p = rx_q->dma_rx + entry;
+
+	hr = umem->headroom + XDP_PACKET_HEADROOM;
+	mask = umem->chunk_mask;
+	handle &= mask;
+
+	buf->dma_addr = xdp_umem_get_dma(umem, handle);
+	buf->dma_addr += hr;
+	buf->cpu_addr = xdp_umem_get_data(umem, handle);
+	buf->cpu_addr += hr;
+	buf->handle = xsk_umem_adjust_offset(umem, (u64)handle, umem->headroom);
+
+	len = priv->xsk_umems[queue]->chunk_size_nohr - XDP_PACKET_HEADROOM;
+	dma_sync_single_range_for_device(priv->device, buf->dma_addr,
+					 buf->page_offset, len,
+					 DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(priv->device, buf->dma_addr)) {
+		netdev_err(priv->dev, "Rx DMA map failed\n");
+		return;
+	}
+
+	stmmac_set_desc_addr(priv, p, buf->dma_addr);
+	stmmac_refill_desc3(priv, rx_q, p);
+
+	dma_wmb();
+	stmmac_set_rx_owner(priv, p, priv->use_riwt);
+	dma_wmb();
+
+	rx_q->dirty_rx = STMMAC_GET_ENTRY(entry, DMA_RX_SIZE);
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_alloc_frames_for_xsk() - allocate memory for XSK frames
+ * @priv: gemac main structure
+ * @queue: queue number of the net device
+ *
+ * Any XSK packet form UMEM can be converted to frame for use in stack or
+ * retransmit so allocate memory in advance.
+ */
+static int stmmac_alloc_frames_for_xsk(struct stmmac_priv *priv, int queue)
+{
+	struct stmmac_tx_queue *tx_q = &priv->tx_queue[queue];
+	size_t len = priv->xsk_umems[queue]->chunk_size_nohr - XDP_PACKET_HEADROOM;
+	int err_i;
+	int i;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	for (i = 0; i < DMA_TX_SIZE; i++) {
+		tx_q->tx_skbuff_dma[i].page = kcalloc(1, len, GFP_KERNEL);
+		if (!tx_q->tx_skbuff_dma[i].page)
+			goto err;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+
+err:
+	pr_err("AF_XDP: can not allocate memory for XSK frames\n");
+
+	err_i = i;
+	for (i = 0; i < err_i; ++i)
+		kfree(tx_q->tx_skbuff_dma[i].page);
+
+	return -ENOMEM;
+}
+
+/**
+ * stmmac_free_frames_for_xsk() - free memory for XSK frames
+ * @priv: gemac main structure
+ * @queue: queue number of the net device
+ */
+static void stmmac_free_frames_for_xsk(struct stmmac_priv *priv, int queue)
+{
+	struct stmmac_tx_queue *tx_q = &priv->tx_queue[queue];
+	int i;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	for (i = 0; i < DMA_TX_SIZE; i++)
+		kfree(tx_q->tx_skbuff_dma[i].page);
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_xmit_xdp_frame() - transmit one XSK frame
+ * @priv: gemac main structure
+ * @xdpf: pointer to the frame for transmitting
+ *
+ * Return: STMMAC_XDP_TX - ok	STMMAC_XDP_CONSUMED - failed
+ */
+static int stmmac_xmit_xdp_frame(struct stmmac_priv *priv, struct xdp_frame *xdpf)
+{
+	int queue = 0;
+	struct dma_desc *desc;
+	struct stmmac_tx_queue *tx_q = priv->tx_queue + queue;
+	int entry = tx_q->cur_tx;
+	dma_addr_t dma;
+	u32 tx_avail = stmmac_tx_avail(priv, queue);
+
+	if (atomic_read(&priv->tx_lock))
+		return STMMAC_XDP_CONSUMED;
+	else
+		atomic_set(&priv->tx_lock, 1);
+
+	if (!tx_avail)
+		goto err;
+
+	if (priv->extend_desc)
+		desc = (struct dma_desc *)(tx_q->dma_etx + entry);
+	else
+		desc = tx_q->dma_tx + entry;
+
+	memcpy(tx_q->tx_skbuff_dma[entry].page, xdpf->data, xdpf->len);
+	dma = dma_map_single(priv->device, tx_q->tx_skbuff_dma[entry].page,
+			     xdpf->len, DMA_TO_DEVICE);
+	if (dma_mapping_error(priv->device, dma))
+		goto err;
+
+	tx_q->cur_tx = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+	tx_q->tx_skbuff_dma[entry].tx_source_type = STMMAC_TX_SOURCE_FRAME;
+	tx_q->tx_skbuff_dma[entry].buf = dma;
+	tx_q->tx_skbuff_dma[entry].len = xdpf->len;
+	tx_q->tx_skbuff_dma[entry].page_addr = xdpf->data;
+
+	stmmac_set_desc_addr(priv, desc, dma);
+	dma_wmb();
+	stmmac_prepare_tx_desc(priv, desc, 1, xdpf->len, 0, priv->mode, 1, 1,
+			       xdpf->len);
+	dma_wmb();
+	stmmac_enable_dma_transmission(priv, priv->ioaddr);
+
+	__free_page(virt_to_page(xdpf->data));
+
+	atomic_set(&priv->tx_lock, 0);
+
+	return STMMAC_XDP_TX;
+
+err:
+	__free_page(virt_to_page(xdpf->data));
+
+	atomic_set(&priv->tx_lock, 0);
+
+	return STMMAC_XDP_CONSUMED;
+}
+
+/**
+ * stmmac_xdp_transmit_zc() - transmit UMEM packets
+ * @priv: gemac main structure
+ * @napi_budget: budget to retransmit
+ *
+ * Main transmitting routine. Transmit packets got only from UMEM.
+ *
+ * Return: number of packets has been transmitted.
+ */
+int stmmac_xdp_transmit_zc(struct stmmac_priv *priv, int napi_budget)
+{
+	struct dma_desc *desc;
+	struct xdp_desc xdp_desc;
+	struct stmmac_tx_queue *tx_q = priv->tx_queue;
+	struct stmmac_tx_info *tx_info;
+	int entry = tx_q->cur_tx;
+	int csum_insertion = 0;
+	int queue = 0;
+	u32 desc_processed = 0;
+	u32 desc_avaliable = stmmac_tx_avail(priv, queue);
+	dma_addr_t dma;
+
+	/* Save batch of descriptors to ndo_xmit() */
+	if (desc_avaliable < STMMAC_TX_XMIT_SAFE_AMOUNT)
+		return 0;
+
+	while ((napi_budget-- > 0) && (desc_avaliable-- > 0)) {
+		/* Acquire data from UMEM */
+		if (!xsk_umem_consume_tx(priv->xsk_umems[queue], &xdp_desc))
+			break;
+
+		/* Get descriptor by index */
+		if (likely(priv->extend_desc))
+			desc = (struct dma_desc *)(tx_q->dma_etx + entry);
+		else
+			desc = tx_q->dma_tx + entry;
+
+		/* We use source type when clear Tx descriptors */
+		tx_info = tx_q->tx_skbuff_dma + entry;
+		tx_info->tx_source_type = STMMAC_TX_SOURCE_UMEM;
+
+		/* Prepare for use with GEMAC */
+		dma = xdp_umem_get_dma(priv->xsk_umems[queue], xdp_desc.addr);
+		dma_sync_single_for_device(priv->device, dma, xdp_desc.len,
+					   DMA_BIDIRECTIONAL);
+
+		/* Fill in descriptors with data */
+		stmmac_set_desc_addr(priv, desc, dma);
+		stmmac_prepare_tx_desc(priv, desc, 1, xdp_desc.len,
+				       csum_insertion, priv->mode, 1, 1,
+				       xdp_desc.len);
+
+		entry = STMMAC_GET_ENTRY(entry, DMA_TX_SIZE);
+		tx_q->cur_tx = entry;
+
+		++desc_processed;
+	}
+
+	/* Notify socket in user space about written data */
+	if (desc_processed)
+		xsk_umem_consume_tx_done(priv->xsk_umems[queue]);
+
+	stmmac_enable_dma_transmission(priv, priv->ioaddr);
+
+	return desc_processed;
+}
+
+/**
+ * stmmac_rx_refill_xsk() - try to acquire descriptors for XSK from UMEM
+ * @priv: gemac main structure
+ * @queue: queue number of the net device
+ *
+ * Return: number of descriptors acquired form UMEM
+ */
+static int stmmac_rx_refill_xsk(struct stmmac_priv *priv, u32 queue)
+{
+	static atomic_t lock = ATOMIC_INIT(0);
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+	struct stmmac_xsk_desc_map *buf;
+	struct xdp_umem *umem = NULL;
+	unsigned int entry = rx_q->dirty_rx;
+	unsigned long timeout = jiffies + msecs_to_jiffies(1);
+	int dirty = stmmac_rx_dirty(priv, queue);
+	int cleaned = 0;
+	u64 hr = 0;
+	u64 handle;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	if ((priv->xsk_umems == NULL) || (priv->xsk_umems[queue] == NULL))
+		return -EPERM;
+
+	umem = priv->xsk_umems[queue];
+	hr = umem->headroom + XDP_PACKET_HEADROOM;
+
+	if (atomic_read(&lock))
+		return -EBUSY;
+
+	atomic_set(&lock, 1);
+
+	while (dirty-- > 0) {
+		struct dma_desc *p;
+		size_t buf_size;
+
+		/* Buffer info (extra data) is used for XSK */
+		buf = &rx_q->desc_map[entry];
+
+		if (priv->extend_desc)
+			p = (struct dma_desc *)(rx_q->dma_erx + entry);
+		else
+			p = rx_q->dma_rx + entry;
+
+		/* Acquire UMEM handle */
+		if (!xsk_umem_peek_addr(priv->xsk_umems[queue], &handle)) {
+			if (rx_q->rx_empty) {
+				/* Notify user space to clear RX queue and refill FQ queue */
+				if (xsk_umem_uses_need_wakeup(priv->xsk_umems[queue]))
+					xsk_set_rx_need_wakeup(priv->xsk_umems[queue]);
+
+				/* Try to acquire descriptors greedily */
+				if (time_after(jiffies, timeout))
+					break;
+				else
+					continue;
+			}
+
+			break;
+		}
+		dirty--;
+
+		buf->dma_addr = xdp_umem_get_dma(umem, handle);
+		buf->dma_addr += hr;
+		buf->cpu_addr = xdp_umem_get_data(umem, handle);
+		buf->cpu_addr += hr;
+		buf->handle = handle + umem->headroom;
+
+		/* Notify UMEM that we have taken one element */
+		xsk_umem_discard_addr(priv->xsk_umems[queue]);
+
+		rx_q->rx_empty = false;
+
+		buf_size = priv->xsk_umems[queue]->chunk_size_nohr - XDP_PACKET_HEADROOM;
+		dma_sync_single_range_for_device(priv->device, buf->dma_addr,
+						 buf->page_offset, buf_size,
+						 DMA_BIDIRECTIONAL);
+
+		if (dma_mapping_error(priv->device, buf->dma_addr)) {
+			netdev_err(priv->dev, "Rx DMA map failed\n");
+			break;
+		}
+
+		stmmac_set_desc_addr(priv, p, buf->dma_addr);
+		stmmac_refill_desc3(priv, rx_q, p);
+
+		if (rx_q->rx_zeroc_thresh > 0)
+			rx_q->rx_zeroc_thresh--;
+
+		dma_wmb();
+		stmmac_set_rx_owner(priv, p, priv->use_riwt);
+		dma_wmb();
+		entry = STMMAC_GET_ENTRY(entry, DMA_RX_SIZE);
+
+		++cleaned;
+	}
+	rx_q->dirty_rx = entry;
+
+	atomic_set(&lock, 0);
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return cleaned;
+}
+
+/**
+ * stmmac_initial_refill() - try to acquire descriptors for XSK from UMEM in
+ * initialization process.
+ * @priv: gemac main structure
+ * @queue: queue number of the net device
+ *
+ * Return: number of descriptors acquired form UMEM
+ */
+static int stmmac_initial_refill(struct stmmac_priv *priv, u32 queue)
+{
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+	struct dma_desc *p;
+	struct xdp_umem *umem;
+	int result = 0;
+	int count = 0;
+	int i;
+	u64 hr;
+	u64 handle;
+	size_t len;
+
+	/* Check if UMEM is initialized */
+	if (priv->num_xsk_umems_used == 0)
+		return result;
+
+	umem = priv->xsk_umems[queue];
+	hr = umem->headroom + XDP_PACKET_HEADROOM;
+
+	for (i = 0; i < DMA_RX_SIZE; ++i) {
+		/* Get descriptor pointer */
+		if (priv->extend_desc)
+			p = (struct dma_desc *)(rx_q->dma_erx + i);
+		else
+			p = rx_q->dma_rx + i;
+
+		/* Peek UMEM element */
+		if (!xsk_umem_peek_addr(priv->xsk_umems[queue], &handle))
+			break;
+
+		/* Place UMEM element to store */
+		rx_q->desc_map[i].dma_addr = xdp_umem_get_dma(umem, handle);
+		rx_q->desc_map[i].dma_addr += hr;
+		rx_q->desc_map[i].cpu_addr = xdp_umem_get_data(umem, handle);
+		rx_q->desc_map[i].cpu_addr += hr;
+		rx_q->desc_map[i].handle = handle + umem->headroom;
+
+		/* Notify UMEM that we take one element */
+		xsk_umem_discard_addr(priv->xsk_umems[queue]);
+
+		/* Sync DMA for use on device */
+		len = priv->xsk_umems[queue]->chunk_size_nohr - XDP_PACKET_HEADROOM;
+		dma_sync_single_range_for_device(priv->device,
+						 rx_q->desc_map[i].dma_addr,
+						 rx_q->desc_map[i].page_offset,
+						 len,
+						 DMA_BIDIRECTIONAL);
+
+		if (dma_mapping_error(priv->device, rx_q->desc_map[i].dma_addr)) {
+			netdev_err(priv->dev, "Rx DMA map failed\n");
+			break;
+		}
+
+		/* Setup DMA descriptor with new value */
+		stmmac_set_desc_addr(priv, p, rx_q->desc_map[i].dma_addr);
+		stmmac_refill_desc3(priv, rx_q, p);
+
+		dma_wmb();
+		stmmac_set_rx_owner(priv, p, priv->use_riwt);
+		dma_wmb();
+
+		++count;
+	}
+
+	if (count)
+		rx_q->rx_empty = false;
+
+	/* Setup ring descriptor pointers */
+	rx_q->cur_rx = 0;
+	rx_q->dirty_rx = count % DMA_RX_SIZE;
+
+	DBG("Ring pointers [cur:dirty] = [%u:%u]\n", rx_q->cur_rx, rx_q->dirty_rx);
+
+	/* This is unusual case just notify about it */
+	if (count < DMA_RX_SIZE)
+		pr_info("AF_XDP: Rx DMA ring is not filled completely %u of %u\n",
+			count, DMA_RX_SIZE);
+
+	return count;
+}
+
+/**
+ * stmmac_refill_timer() - timer routine for deferred refilling
+ * @t: associated timer
+ */
+static void stmmac_refill_timer(struct timer_list *t)
+{
+	struct stmmac_rx_queue *rx_q = from_timer(rx_q, t, rx_refill_timer);
+	struct stmmac_priv *priv = rx_q->priv_data;
+
+	stmmac_rx_refill_xsk(priv, rx_q->queue_index);
+
+	/* Timer can be adjusted to different time in rx_poll_xsk() if necessary */
+	mod_timer(&rx_q->rx_refill_timer,
+		  jiffies + msecs_to_jiffies(STMMAC_REFILL_MS));
+}
+
+/**
+ * stmmac_rx_timer() - timer routine to service Rx initialization and refilling
+ * @t: associated timer
+ *
+ * It can happens there are no UMEMs descriptors when initialization finish so
+ * run timer to try acquire UMEMs descriptors and finish ring initialization.
+ */
+static void stmmac_rx_timer(struct timer_list *t)
+{
+        struct stmmac_rx_queue *rx_q = from_timer(rx_q, t, rx_init_timer);
+        struct stmmac_priv *priv = rx_q->priv_data;
+        int is_refilled = 0;
+
+        DBG("%s-->\n", __FUNCTION__);
+
+        /* Try to do initial refill till it has succeed */
+        is_refilled = stmmac_initial_refill(priv, rx_q->queue_index);
+        if (!is_refilled) {
+        	mod_timer(&rx_q->rx_init_timer,
+        		  jiffies + msecs_to_jiffies(STMMAC_INITIAL_REFILL_MS));
+            return;
+        }
+
+        /* It helps to solve problem with first descriptor owing */
+        init_dma_rx_desc_rings_xsk(priv->dev);
+
+        pr_info("AF_XDP: started\n");
+    	stmmac_mac_set(priv, priv->ioaddr, true);
+    	stmmac_start_all_dma(priv);
+
+    	timer_setup(&rx_q->rx_refill_timer, stmmac_refill_timer, 0);
+    	mod_timer(&rx_q->rx_refill_timer,
+    		  jiffies + msecs_to_jiffies(STMMAC_REFILL_MS));
+
+    	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_init_rx_service_timer() - service timer initialization routine
+ * @priv: gemac main structure
+ */
+static void stmmac_init_rx_service_timer(struct stmmac_priv *priv)
+{
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[0];
+
+	timer_setup(&rx_q->rx_init_timer, stmmac_rx_timer, 0);
+	mod_timer(&rx_q->rx_init_timer, jiffies + msecs_to_jiffies(500));
+}
+
+/**
+ * stmmac_run_xdp_zc() - run XDP filter and make actions based on the result
+ * @priv: gemac main structure
+ * @xdp: buffer to make action on it
+ *
+ * Return: code of action made on xdp buffer
+ */
+static int stmmac_run_xdp_zc(struct stmmac_priv *priv, struct xdp_buff *xdp)
+{
+	struct bpf_prog *xdp_prog;
+	struct xdp_frame *xdpf;
+	int result = STMMAC_XDP_PASS;
+	int err;
+	u64 offset;
+	u32 act;
+
+	rcu_read_lock();
+
+	xdp_prog = READ_ONCE(priv->xdp_prog);
+	if (xdp_prog) {
+		act = bpf_prog_run_xdp(xdp_prog, xdp);
+	} else {
+		rcu_read_unlock();
+		return -1;
+	}
+
+	offset = xdp->data - xdp->data_hard_start;
+	xdp->handle = xsk_umem_adjust_offset(priv->xsk_umems[0], xdp->handle,
+					     offset);
+
+	switch (act) {
+	case XDP_PASS:
+		break;
+	case XDP_TX:
+		xdpf = convert_to_xdp_frame(xdp);
+		if (unlikely(!xdpf)) {
+			result = STMMAC_XDP_CONSUMED;
+			break;
+		}
+		result = stmmac_xmit_xdp_frame(priv, xdpf);
+		break;
+	case XDP_REDIRECT:
+		err = xdp_do_redirect(priv->dev, xdp, xdp_prog);
+		result = !err ? STMMAC_XDP_REDIR : STMMAC_XDP_CONSUMED;
+		break;
+	default:
+		bpf_warn_invalid_xdp_action(act);
+	case XDP_ABORTED:
+		trace_xdp_exception(priv->dev, xdp_prog, act);
+	case XDP_DROP:
+		result = STMMAC_XDP_CONSUMED;
+		break;
+	}
+
+	rcu_read_unlock();
+
+	return result;
+}
+
+/**
+ * stmmac_rx_xsk() - main receiving packets routine. Rx NAPI registered routine.
+ * @priv: gemac main structure
+ * @limit: NAPI budget
+ * @queue: queue number of the net device
+ *
+ * This function can block (set flag) receive queue so there is no any receiving
+ * operation until queue will be refilled
+ *
+ * Return: numbers of received packets
+ */
+int stmmac_rx_xsk(struct stmmac_priv *priv, int limit, u32 queue)
+{
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+	struct stmmac_channel *ch = &priv->channel[queue];
+	struct sk_buff *skb = NULL;
+	struct xdp_buff xdp;
+	unsigned int next_entry = rx_q->cur_rx;
+	unsigned int count = 0;
+	unsigned int error = 0;
+	unsigned int len = 0;
+	unsigned int xdp_res;
+	int status = 0;
+	int coe = priv->hw->rx_csum;
+	bool do_flush = false;
+
+	if (netif_msg_rx_status(priv)) {
+		void *rx_head;
+
+		netdev_dbg(priv->dev, "%s: descriptor ring:\n", __func__);
+		if (priv->extend_desc)
+			rx_head = (void *)rx_q->dma_erx;
+		else
+			rx_head = (void *)rx_q->dma_rx;
+
+		stmmac_display_ring(priv, rx_head, DMA_RX_SIZE, true);
+	}
+
+	while ((count < limit) && !rx_q->rx_empty) {
+		struct stmmac_xsk_desc_map *buf;
+		struct dma_desc *np, *p;
+		unsigned int sec_len;
+		unsigned int hlen = 0, prev_len = 0;
+		enum pkt_hash_types hash_type;
+		int entry;
+		u32 hash;
+
+		if (!count && rx_q->state_saved) {
+			skb = rx_q->state.skb;
+			error = rx_q->state.error;
+			len = rx_q->state.len;
+		} else {
+			rx_q->state_saved = false;
+			skb = NULL;
+			error = 0;
+			len = 0;
+		}
+
+		if (count >= limit)
+			break;
+
+read_again:
+		sec_len = 0;
+		entry = next_entry;
+		buf = rx_q->desc_map + entry;
+
+		if (priv->extend_desc)
+			p = (struct dma_desc *)(rx_q->dma_erx + entry);
+		else
+			p = rx_q->dma_rx + entry;
+
+		status = stmmac_rx_status(priv, &priv->dev->stats,
+					  &priv->xstats, p);
+
+		/* Check if descriptor is ready to use */
+		if (unlikely(status & dma_own))
+			break;
+
+		if (STMMAC_GET_ENTRY(rx_q->cur_rx, DMA_RX_SIZE) == rx_q->dirty_rx) {
+			/* There are no more owned and refilled descriptors.
+			 * All descriptors are read and queue is empty. Notify upper level.
+			 */
+			rx_q->rx_empty = true;
+		} else {
+			rx_q->cur_rx = STMMAC_GET_ENTRY(rx_q->cur_rx, DMA_RX_SIZE);
+			next_entry = rx_q->cur_rx;
+		}
+
+		if (priv->extend_desc)
+			np = (struct dma_desc *)(rx_q->dma_erx + next_entry);
+		else
+			np = rx_q->dma_rx + next_entry;
+
+		prefetch(np);
+		prefetch(buf->cpu_addr);
+
+		if (priv->extend_desc)
+			stmmac_rx_extended_status(priv, &priv->dev->stats,
+						  &priv->xstats,
+						  rx_q->dma_erx + entry);
+
+		if (unlikely(status == discard_frame)) {
+			error = 1;
+			if (!priv->hwts_rx_en)
+				priv->dev->stats.rx_errors++;
+		}
+
+		if (unlikely(error && (status & rx_not_ls)))
+			goto read_again;
+
+		if (unlikely(error)) {
+			dev_kfree_skb(skb);
+			count++;
+			continue;
+		}
+
+		/* Buffer is good. Go on. */
+
+		if (likely(status & rx_not_ls)) {
+			len += priv->dma_buf_sz;
+		} else {
+			prev_len = len;
+			len = stmmac_get_rx_frame_len(priv, p, coe);
+
+			/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3
+			 * Type frames (LLC/LLC-SNAP)
+			 *
+			 * llc_snap is never checked in GMAC >= 4, so this ACS
+			 * feature is always disabled and packets need to be
+			 * stripped manually.
+			 */
+			if (unlikely(priv->synopsys_id >= DWMAC_CORE_4_00) ||
+				unlikely(status != llc_snap)) {
+					len -= ETH_FCS_LEN;
+			}
+		}
+
+		/* Sanity check */
+		if (!len)
+			continue;
+
+		/* It's time to run XDP program */
+		dma_sync_single_range_for_cpu(priv->device, buf->dma_addr,
+					      buf->page_offset, len,
+					      DMA_BIDIRECTIONAL);
+
+		xdp.rxq = &rx_q->xdp_rxq;
+		xdp.data = buf->cpu_addr;
+		xdp.data_meta = xdp.data;
+		xdp.data_hard_start = xdp.data - XDP_PACKET_HEADROOM;
+		xdp.data_end = xdp.data + len;
+		xdp.handle = buf->handle;
+
+		xdp_res = stmmac_run_xdp_zc(priv, &xdp);
+		if ((xdp_res == STMMAC_XDP_REDIR)) {
+			count++;
+			do_flush = true;
+			continue;
+		} else if ((xdp_res == STMMAC_XDP_TX) || (xdp_res == STMMAC_XDP_CONSUMED)) {
+			count++;
+			continue;
+		}
+		/* Pass XDP packet forward to the network stack */
+
+		/* Allocate SKB if necessary */
+		if (!skb) {
+			int ret = stmmac_get_rx_header_len(priv, p, &hlen);
+
+			if (priv->sph && !ret && (hlen > 0)) {
+				sec_len = len;
+				if (!(status & rx_not_ls))
+					sec_len = sec_len - hlen;
+				len = hlen;
+
+				priv->xstats.rx_split_hdr_pkt_n++;
+			}
+
+			skb = napi_alloc_skb(&ch->rx_napi, len);
+			if (!skb) {
+				priv->dev->stats.rx_dropped++;
+				count++;
+				continue;
+			}
+
+			dma_sync_single_range_for_cpu(priv->device,
+						      buf->dma_addr,
+						      buf->page_offset, len,
+						      DMA_BIDIRECTIONAL);
+
+			skb_copy_to_linear_data(skb, buf->cpu_addr, len);
+			skb_put(skb, len);
+		} else {
+			unsigned int buf_len = len - prev_len;
+
+			if (likely(status & rx_not_ls))
+				buf_len = priv->dma_buf_sz;
+
+			dma_sync_single_range_for_cpu(priv->device,
+						      buf->dma_addr,
+						      buf->page_offset, len,
+						      DMA_BIDIRECTIONAL);
+
+			skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,
+					buf->cpu_addr, 0, buf_len,
+					priv->dma_buf_sz);
+		}
+
+		if (likely(status & rx_not_ls))
+			goto read_again;
+
+		/* Got entire packet into SKB. Finish it. */
+		skb->protocol = eth_type_trans(skb, priv->dev);
+
+		if (unlikely(!coe))
+			skb_checksum_none_assert(skb);
+		else
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+		if (!stmmac_get_rx_hash(priv, p, &hash, &hash_type))
+			skb_set_hash(skb, hash, hash_type);
+
+		skb_record_rx_queue(skb, queue);
+		napi_gro_receive(&ch->rx_napi, skb);
+
+		priv->dev->stats.rx_packets++;
+		priv->dev->stats.rx_bytes += len;
+		count++;
+	}
+
+	if (status & rx_not_ls) {
+		rx_q->state_saved = true;
+		rx_q->state.skb = skb;
+		rx_q->state.error = error;
+		rx_q->state.len = len;
+	}
+
+	if (do_flush)
+		xdp_do_flush_map();
+
+	stmmac_rx_refill_xsk(priv, queue);
+	/* Make a decision whether we restart refilling and when */
+	if (stmmac_rx_dirty(priv, queue) > STMMAC_REFILL_GREEDILY_THRESHOLD) {
+		/* Notify user application we run out of descriptors */
+		if (xsk_umem_uses_need_wakeup(priv->xsk_umems[queue]))
+			xsk_set_rx_need_wakeup(priv->xsk_umems[queue]);
+
+		/* Start looking for descriptors in hard way */
+		mod_timer(&rx_q->rx_refill_timer,
+			  jiffies + msecs_to_jiffies(STMMAC_REFILL_GREEDILY_MS));
+	} else {
+		/* We don't want to notify user application to start
+		 * looking for descriptors in hard way so clear flag
+		 */
+		if (xsk_umem_uses_need_wakeup(priv->xsk_umems[queue]))
+			xsk_clear_rx_need_wakeup(priv->xsk_umems[queue]);
+
+		/* Just from time to time check if clearing go well */
+		mod_timer(&rx_q->rx_refill_timer,
+			  jiffies + msecs_to_jiffies(STMMAC_REFILL_MS));
+	}
+
+	priv->xstats.rx_pkt_n += count;
+
+	/* Sanity check. If it happens notify user and let the NAPI works  */
+	if (WARN_ONCE(count > limit, "NAPI return value higher than budget!\n"))
+		count = limit;
+
+	return count;
+}
+
+/**
+ * stmmac_remove_xsk_umem() - free UMEM resources
+ * @priv: gemac main structure
+ * @qid: queue number of the net device
+ */
+static void stmmac_remove_xsk_umem(struct stmmac_priv *priv, u16 qid)
+{
+	DBG("%s-->\n", __FUNCTION__);
+
+	priv->xsk_umems[qid] = NULL;
+	priv->num_xsk_umems_used--;
+
+	if (priv->num_xsk_umems == 0) {
+		kfree(priv->xsk_umems);
+		priv->xsk_umems = NULL;
+		priv->num_xsk_umems = 0;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_alloc_xsk_umems() - alloc UMEM resources
+ * @priv: gemac main structure
+ *
+ * Return: 0 - ok	-ENOMEM - fail
+ */
+static int stmmac_alloc_xsk_umems(struct stmmac_priv *priv)
+{
+	if (priv->xsk_umems)
+		return 0;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	priv->num_xsk_umems_used = 0;
+	priv->num_xsk_umems = MTL_MAX_RX_QUEUES;
+	priv->xsk_umems = kcalloc(priv->num_xsk_umems, sizeof(*priv->xsk_umems),
+				  GFP_KERNEL);
+	if (!priv->xsk_umems) {
+		priv->num_xsk_umems = 0;
+		return -ENOMEM;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * stmmac_add_xsk_umem() - add to UMEM auxiliary data
+ * @priv: gemac main structure
+ * @umem: allocated UMEM
+ * @qid: queue number of the net device
+ *
+ * Return: 0 - ok	-ENOMEM - fail
+ */
+static int stmmac_add_xsk_umem(struct stmmac_priv *priv, struct xdp_umem *umem,
+			       u16 qid)
+{
+	int err;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	err = stmmac_alloc_xsk_umems(priv);
+	if (err)
+		return err;
+
+	priv->xsk_umems[qid] = umem;
+	priv->num_xsk_umems_used++;
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * stmmac_xsk_umem_dma_map() - map DMA memory for UMEM descriptors
+ * @priv: gemac main structure
+ * @qid: associated UMEM
+ *
+ * Return: 0 - ok	-ENOMEM - fail
+ */
+static int stmmac_xsk_umem_dma_map(struct stmmac_priv *priv,
+				   struct xdp_umem *umem)
+{
+	struct device *dev = priv->device;
+	unsigned int i, j;
+	dma_addr_t dma;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	for (i = 0; i < umem->npgs; i++) {
+		dma = dma_map_page_attrs(dev, umem->pgs[i], 0, PAGE_SIZE,
+					 DMA_BIDIRECTIONAL, DMA_ATTR);
+		if (dma_mapping_error(dev, dma))
+			goto out_unmap;
+
+		umem->pages[i].dma = dma;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+
+out_unmap:
+	for (j = 0; j < i; j++) {
+		dma_unmap_page_attrs(dev, umem->pages[i].dma, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, DMA_ATTR);
+		umem->pages[i].dma = 0;
+	}
+
+	return -ENOMEM;
+}
+
+/**
+ * stmmac_xdp_setup() - setup new XDP filter
+ * @dev: gemac main structure
+ * @prog: filter program
+ *
+ * Return: 0 - ok
+ */
+static int stmmac_xdp_setup(struct net_device *dev, struct bpf_prog *prog)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	struct bpf_prog *old_prog;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	synchronize_rcu();
+	old_prog = xchg(&priv->xdp_prog, prog);
+	rcu_assign_pointer(priv->xdp_prog, prog);
+
+	if (old_prog)
+		bpf_prog_put(old_prog);
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * free_dma_rx_desc_resources_xsk() - free DMA descriptors for every ring
+ * @priv: gemac main structure
+ */
+void free_dma_rx_desc_resources_xsk(struct stmmac_priv *priv)
+{
+	u32 rx_count = priv->plat->rx_queues_to_use;
+	u32 queue;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	/* Free RX queue resources */
+	for (queue = 0; queue < rx_count; queue++) {
+		struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+
+		/* Free DMA regions of consistent memory previously allocated */
+		if (!priv->extend_desc)
+			dma_free_coherent(priv->device,
+					  DMA_RX_SIZE * sizeof(struct dma_desc),
+					  rx_q->dma_rx, rx_q->dma_rx_phy);
+		else
+			dma_free_coherent(priv->device,
+					  DMA_RX_SIZE * sizeof(struct dma_extended_desc),
+					  rx_q->dma_erx, rx_q->dma_rx_phy);
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * alloc_dma_rx_desc_resources_xsk() - allocate DMA descriptors for every ring
+ * @priv: gemac main structure
+ *
+ * Return: 0 - ok	-ENOMEM - fail
+ */
+int alloc_dma_rx_desc_resources_xsk(struct stmmac_priv *priv)
+{
+	u32 rx_count = priv->plat->rx_queues_to_use;
+	u32 queue;
+	u32 err_queue;
+	size_t len;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	/* RX queues buffers and DMA */
+	for (queue = 0; queue < rx_count; ++queue) {
+		struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+
+		rx_q->queue_index = queue;
+		rx_q->priv_data = priv;
+
+		if (priv->extend_desc) {
+			len = DMA_RX_SIZE * sizeof(struct dma_extended_desc);
+			rx_q->dma_erx = dma_alloc_coherent(priv->device,
+							   len,
+							   &rx_q->dma_rx_phy,
+							   GFP_KERNEL);
+			if (!rx_q->dma_erx)
+				goto err_dma;
+		} else {
+			len = DMA_RX_SIZE * sizeof(struct dma_desc);
+			rx_q->dma_rx = dma_alloc_coherent(priv->device,
+							  len,
+							  &rx_q->dma_rx_phy,
+							  GFP_KERNEL);
+			if (!rx_q->dma_rx)
+				goto err_dma;
+		}
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+
+err_dma:
+	pr_err("AF_XDP: Can not allocate DMA coherent memory!\n");
+
+	err_queue = queue;
+	for (queue = 0; queue < err_queue; ++queue) {
+		struct stmmac_rx_queue *rx_q = &priv->rx_queue[queue];
+
+		if (priv->extend_desc) {
+			len = DMA_RX_SIZE * sizeof(struct dma_extended_desc);
+			dma_free_coherent(priv->device,
+					 len, rx_q->dma_erx, rx_q->dma_rx_phy);
+		} else {
+			len = DMA_RX_SIZE * sizeof(struct dma_desc);
+			dma_free_coherent(priv->device,
+					  len,  rx_q->dma_rx, rx_q->dma_rx_phy);
+		}
+	}
+
+	return -ENOMEM;
+}
+
+/**
+ * stmmac_txrx_ring_disable() - stop and free resources for ring. Stop DMA engine
+ * @priv: gemac main structure
+ * @ring: number of associated ring
+ */
+static void stmmac_txrx_ring_disable(struct stmmac_priv *priv, int ring)
+{
+	struct stmmac_channel *ch = &priv->channel[ring];
+	u32 rx_queues_cnt = priv->plat->rx_queues_to_use;
+	u32 tx_queues_cnt = priv->plat->tx_queues_to_use;
+	u32 maxq = max(rx_queues_cnt, tx_queues_cnt);
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	/* Sanity check */
+	if (ring > maxq)
+		return;
+
+	/* Stop GEMAC engine */
+	stmmac_mac_set(priv, priv->ioaddr, false);
+	stmmac_stop_all_dma(priv);
+
+	/* Wait finishing last transactions */
+	msleep(100);
+
+	netif_tx_stop_queue(netdev_get_tx_queue(priv->dev, ring));
+
+	/* Everything is ready to stop NAPIs */
+	if (ring < rx_queues_cnt)
+		napi_disable(&ch->rx_napi);
+	if (ring < tx_queues_cnt)
+		napi_disable(&ch->tx_napi);
+
+	if (priv->num_xsk_umems_used && priv->xsk_umems[ring]) {
+		/* Disable UMEM resources */
+		DBG("%s: UMEM memory model disable\n", __FUNCTION__);
+
+		xdp_do_flush_map();
+		xdp_rxq_info_unreg(&priv->rx_queue[ring].xdp_rxq);
+		stmmac_free_frames_for_xsk(priv, ring);
+		free_dma_rx_desc_resources_xsk(priv);
+	} else {
+		/* Disable resources in case of using pool of pages */
+		DBG("%s: page pool memory model disable\n", __FUNCTION__);
+
+		free_dma_rx_desc_resources(priv);
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_reset_watchdog_envent() - defer transmit time to avoid network schedule
+ * timeout.
+ * @priv: gemac main structure
+ * @ring: ring number
+ *
+ * Reset start time to allow acquire UMEM descriptors. It would be better to
+ * disable ring till it own UMEM but now it's made that way.
+ */
+static void stmmac_reset_watchdog_envent(struct stmmac_priv *priv, int ring)
+{
+	struct netdev_queue *txq;
+
+	txq = netdev_get_tx_queue(priv->dev, ring);
+	txq->trans_start = jiffies + priv->dev->watchdog_timeo;
+}
+
+/**
+ *
+ * stmmac_txrx_ring_enable() - allocate resources and run ring. Start DMA engine
+ * @priv: gemac main structure
+ * @ring: number of associated ring
+ *
+ * Return: 0 - ok	-ENOMEM - failure
+ */
+static int stmmac_txrx_ring_enable(struct stmmac_priv *priv, int ring)
+{
+	struct stmmac_channel *ch = &priv->channel[ring];
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[ring];
+	u32 rx_queues_cnt = priv->plat->rx_queues_to_use;
+	u32 tx_queues_cnt = priv->plat->tx_queues_to_use;
+	u32 maxq = max(rx_queues_cnt, tx_queues_cnt);
+	bool enable_gemac = false;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	/* Sanity check */
+	if (ring > maxq)
+		return -EPERM;
+
+	if (priv->num_xsk_umems_used && priv->xsk_umems[ring]) {
+		/* Allocate UMEM resources */
+		DBG("%s: UMEM memory model enable\n", __FUNCTION__);
+
+		priv->zca.free = stmmac_zca_free;
+		WARN_ON(xdp_rxq_info_reg_mem_model(&priv->rx_queue[ring].xdp_rxq,
+						   MEM_TYPE_ZERO_COPY,
+						   &priv->zca));
+
+		if (alloc_dma_rx_desc_resources_xsk(priv))
+			goto err;
+		stmmac_alloc_frames_for_xsk(priv, ring);
+
+		stmmac_init_rx_service_timer(priv);
+	} else {
+		/* Allocate resources in case of using pool of pages */
+		DBG("%s: page pool memory model enable\n", __FUNCTION__);
+
+		if (alloc_dma_rx_desc_resources(priv))
+			goto err;
+		init_dma_desc_rings(priv->dev, GFP_KERNEL);
+
+		/* Do restrict setup instead of full because driver isn't ready to run */
+		stmmac_hw_restrict_setup(priv->dev, true);
+
+		enable_gemac = true;
+	}
+
+	stmmac_reset_watchdog_envent(priv, ring);
+	netif_tx_start_queue(netdev_get_tx_queue(priv->dev, ring));
+
+	stmmac_init_rx_chan(priv, priv->ioaddr, priv->plat->dma_cfg,
+			    rx_q->dma_rx_phy, ring);
+
+	rx_q->rx_tail_addr = rx_q->dma_rx_phy +
+			     (DMA_RX_SIZE * sizeof(struct dma_desc));
+	stmmac_set_rx_tail_ptr(priv, priv->ioaddr,
+			       rx_q->rx_tail_addr, ring);
+
+	/* In case of UMEM this variables will be overridden in initial refill */
+	rx_q->cur_rx = 0;
+	rx_q->dirty_rx = 0;
+
+	/* Ready to start NAPIs */
+	if (ring < rx_queues_cnt)
+		napi_enable(&ch->rx_napi);
+	if (ring < tx_queues_cnt)
+		napi_enable(&ch->tx_napi);
+
+	/* Enable GEMAC engine here in case of using page pool */
+	if (enable_gemac) {
+		stmmac_mac_set(priv, priv->ioaddr, true);
+		stmmac_start_all_dma(priv);
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+
+err:
+	pr_err("AF_XDP: can not enable ring %d\n", ring);
+	return -ENOMEM;
+}
+
+/**
+ * stmmac_umem_enable() - allocate resources and enable UMEM
+ * @priv: gemac main structure
+ * @umem: pointer to socket UMEM representation
+ * @qid: number of the queue to associate with
+ *
+ * Return: 0 - ok	< 0 - fail
+ */
+static int stmmac_umem_enable(struct stmmac_priv *priv, struct xdp_umem *umem,
+			      u16 qid)
+{
+	struct xdp_umem_fq_reuse *reuseq;
+	int err = -1;
+	bool if_running;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+
+	if (qid >= priv->plat->rx_queues_to_use)
+		return -EINVAL;
+
+	err = xdp_rxq_info_reg(&priv->rx_queue[0].xdp_rxq, priv->dev, 0);
+	if (err)
+		return err;
+
+	reuseq = xsk_reuseq_prepare(DMA_RX_SIZE);
+	if (!reuseq)
+		return -ENOMEM;
+
+	if_running = netif_running(priv->dev);
+	if (if_running)
+		stmmac_txrx_ring_disable(priv, qid);
+
+	/* Setup UMEM and XDP auxiliary data */
+	if (stmmac_add_xsk_umem(priv, umem, qid))
+		return err;
+
+	xsk_reuseq_free(xsk_reuseq_swap(umem, reuseq));
+
+	err = stmmac_xsk_umem_dma_map(priv, umem);
+	if (err)
+		return err;
+
+	priv->xsk_umems[qid] = umem;
+
+	/* Enable rings */
+	if (if_running)
+		stmmac_txrx_ring_enable(priv, qid);
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * stmmac_xsk_umem_dma_unmap() - free UMEM DMA resources
+ * @priv: gemac main structure
+ * @umem: associated UMEM
+ */
+static void stmmac_xsk_umem_dma_unmap(struct stmmac_priv *priv,
+				      struct xdp_umem *umem)
+{
+	struct device *dev = priv->device;
+	unsigned int i;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	for (i = 0; i < umem->npgs; i++) {
+		dma_unmap_page_attrs(dev, umem->pages[i].dma, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, DMA_ATTR);
+		umem->pages[i].dma = 0;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+}
+
+/**
+ * stmmac_umem_disable() - free resources and disable UMEM
+ * @priv: gemac main structure
+ * @qid: number of the queue to associate with
+ *
+ * Return: 0 - ok	< 0 - fail
+ */
+static int stmmac_umem_disable(struct stmmac_priv *priv, u16 qid)
+{
+	struct xdp_umem *umem;
+	struct stmmac_rx_queue *rx_q = &priv->rx_queue[qid];
+	bool if_running;
+	
+	DBG("%s-->\n", __FUNCTION__);
+
+	umem = xdp_get_umem_from_qid(priv->dev, qid);
+	if (!umem)
+		return -EINVAL;
+
+	if_running = netif_running(priv->dev);
+
+	if (if_running)
+		stmmac_txrx_ring_disable(priv, qid);
+
+	stmmac_xsk_umem_dma_unmap(priv, umem);
+	stmmac_remove_xsk_umem(priv, qid);
+
+	del_timer_sync(&rx_q->rx_init_timer);
+	del_timer_sync(&rx_q->rx_refill_timer);
+
+	if (if_running)
+		stmmac_txrx_ring_enable(priv, qid);
+
+	priv->xsk_umems = NULL;
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * stmmac_umem_setup() - wrapper for enable/disable UMEM
+ * @priv: gemac main structure
+ * @umem: pointer to socket UMEM representation
+ * @qid: number of the associated queue
+ *
+ * Return: 0 - ok	< 0 - fail
+ */
+static int stmmac_umem_setup(struct stmmac_priv *priv, struct xdp_umem *umem,
+			     u16 qid)
+{
+	return umem ? stmmac_umem_enable(priv, umem, qid) : \
+		      stmmac_umem_disable(priv, qid);
+}
+
+/**
+ * stmmac_bpf() - callback of network stack for setup bpf or enable/disable UMEM
+ * @priv: gemac main structure
+ * @bpf: network stack representation of bpf
+ *
+ * Return: 0 - ok	< 0 - fail
+ */
+int stmmac_bpf(struct net_device *dev, struct netdev_bpf *bpf)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	switch (bpf->command) {
+		case XDP_SETUP_PROG:
+			if (!priv->xsk_umems) {
+				pr_err("AF_XDP: Copy mode is not supported\n");
+				return -EPERM;
+			}
+			return stmmac_xdp_setup(dev, bpf->prog);
+		case XDP_QUERY_PROG:
+			bpf->prog_id = priv->xdp_prog ? priv->xdp_prog->aux->id : 0;
+			return 0;
+		case XDP_SETUP_XSK_UMEM:
+			return stmmac_umem_setup(priv, bpf->xsk.umem,
+						 bpf->xsk.queue_id);
+		default:
+			return -EINVAL;
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return -EPERM;
+}
+
+/**
+ * stmmac_xdp_xmit() - do redirect to non mapped place as external network
+ * @dev: network device to transmit
+ * @n: number of XDP frames
+ * @xdp: pointer to xdp frames array
+ * @flags: extra flags from network stack
+ *
+ * Return: number of redirected frames
+ */
+int stmmac_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **xdp,
+		    u32 flags)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+	int drops = 0;
+	int result;
+	int i;
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	for (i = 0; i < n; ++i) {
+		result = stmmac_xmit_xdp_frame(priv, xdp[i]);
+		if (result != STMMAC_XDP_TX) {
+			xdp_return_frame_rx_napi(xdp[i]);
+			drops++;
+		}
+	}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return n - drops;
+}
+
+/**
+ * stmmac_xsk_wakeup() - Wake up Rx or/and Tx queue
+ * @dev: associated network device
+ * @queue_id: number of the queue
+ * @flags: sent action
+ *
+ * User space application or network stack can wake up driver in case of absence
+ * resource.
+ *
+ * Return: 0 - ok
+ */
+int stmmac_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags)
+{
+	struct stmmac_priv *priv = netdev_priv(dev);
+
+	DBG("%s-->\n", __FUNCTION__);
+
+	/* Wake up request can be sent from poll of socket */
+
+	if (flags & XDP_WAKEUP_TX)
+		/* Run NAPI tx engine to kick transfer or clean descriptors */
+		if (likely(napi_schedule_prep(&priv->channel[0].tx_napi))) {
+			__napi_schedule(&priv->channel[queue_id].tx_napi);
+			//xsk_clear_tx_need_wakeup(priv->xsk_umems[queue_id]);
+		}
+
+	if (flags & XDP_WAKEUP_RX)
+		/* Run NAPI rx engine to start receiving or clean descriptors */
+		if (likely(napi_schedule_prep(&priv->channel[0].rx_napi))) {
+			__napi_schedule(&priv->channel[queue_id].rx_napi);
+			//xsk_clear_rx_need_wakeup(priv->xsk_umems[queue_id]);
+		}
+
+	DBG("%s<--\n", __FUNCTION__);
+
+	return 0;
+}
+
+/**
+ * stmmac_init_dma_engine_xsk() - initialize DMA engine in case of using XSK
+ * @priv: gemac main structure
+ */
+int stmmac_init_dma_engine_xsk(struct stmmac_priv *priv)
+{
+	u32 rx_channels_count = priv->plat->rx_queues_to_use;
+	u32 tx_channels_count = priv->plat->tx_queues_to_use;
+	u32 dma_csr_ch = max(rx_channels_count, tx_channels_count);
+	struct stmmac_rx_queue *rx_q;
+	struct stmmac_tx_queue *tx_q;
+	u32 chan = 0;
+	int atds = 0;
+	int ret = 0;
+
+	if (!priv->plat->dma_cfg || !priv->plat->dma_cfg->pbl) {
+		dev_err(priv->device, "Invalid DMA configuration\n");
+		return -EINVAL;
+	}
+
+	if (priv->extend_desc && (priv->mode == STMMAC_RING_MODE))
+		atds = 1;
+
+	/* DMA Configuration */
+	stmmac_dma_init(priv, priv->ioaddr, priv->plat->dma_cfg, atds);
+
+	if (priv->plat->axi)
+		stmmac_axi(priv, priv->ioaddr, priv->plat->axi);
+
+	/* DMA CSR Channel configuration */
+	for (chan = 0; chan < dma_csr_ch; chan++)
+		stmmac_init_chan(priv, priv->ioaddr, priv->plat->dma_cfg, chan);
+
+	/* DMA RX Channel Configuration */
+	for (chan = 0; chan < rx_channels_count; chan++) {
+		rx_q = &priv->rx_queue[chan];
+
+		stmmac_init_rx_chan(priv, priv->ioaddr, priv->plat->dma_cfg,
+				    rx_q->dma_rx_phy, chan);
+
+		rx_q->rx_tail_addr = rx_q->dma_rx_phy +
+				     (DMA_RX_SIZE * sizeof(struct dma_desc));
+		stmmac_set_rx_tail_ptr(priv, priv->ioaddr,
+				       rx_q->rx_tail_addr, chan);
+	}
+
+	/* DMA TX Channel Configuration */
+	for (chan = 0; chan < tx_channels_count; chan++) {
+		tx_q = &priv->tx_queue[chan];
+
+		stmmac_init_tx_chan(priv, priv->ioaddr, priv->plat->dma_cfg,
+				    tx_q->dma_tx_phy, chan);
+
+		tx_q->tx_tail_addr = tx_q->dma_tx_phy;
+		stmmac_set_tx_tail_ptr(priv, priv->ioaddr,
+				       tx_q->tx_tail_addr, chan);
+	}
+
+	return ret;
+}
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.h b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.h
new file mode 100644
index 000000000..534c8c4e8
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_xsk.h
@@ -0,0 +1,49 @@
+#ifndef _STMMAC_XSK_H_
+#define _STMMAC_XSK_H_
+
+#include <net/xdp_sock.h>
+#include <net/xdp.h>
+#include <linux/bpf_trace.h>
+#include "stmmac.h"
+
+//#define DEBUG_XSK
+#ifdef DEBUG_XSK
+#define DBG(...)	pr_info(__VA_ARGS__)
+#else
+#define DBG(...)
+#endif
+
+#define STMMAC_XDP_PASS		0
+#define STMMAC_XDP_CONSUMED	BIT(0)
+#define STMMAC_XDP_TX		BIT(1)
+#define STMMAC_XDP_REDIR	BIT(2)
+
+#define STMMAC_TX_SOURCE_RESET	0
+#define STMMAC_TX_SOURCE_SKB	0
+#define STMMAC_TX_SOURCE_UMEM	1
+#define STMMAC_TX_SOURCE_FRAME	2
+
+#define STMMAC_TX_XMIT_SAFE_AMOUNT		40
+
+/* Refill timer restart time */
+#define STMMAC_REFILL_GREEDILY_MS		1
+#define STMMAC_REFILL_MS			500
+#define STMMAC_INITIAL_REFILL_MS		500
+
+#define STMMAC_REFILL_GREEDILY_THRESHOLD	10
+
+#define DMA_ATTR \
+	(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)
+
+/* NDO prototypes */
+int stmmac_bpf(struct net_device *dev, struct netdev_bpf *bpf);
+int stmmac_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **xdp, u32 flags);
+int stmmac_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags);
+
+/* Inner usage */
+inline u32 stmmac_tx_avail(struct stmmac_priv *priv, u32 queue);
+int stmmac_rx_xsk(struct stmmac_priv *priv, int limit, u32 queue);
+int stmmac_xdp_transmit_zc(struct stmmac_priv *priv, int napi_budget);
+int stmmac_init_dma_engine_xsk(struct stmmac_priv *priv);
+
+#endif
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index dcf2051ef..4f402be36 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -10,6 +10,12 @@ menuconfig MDIO_DEVICE
 
 if MDIO_DEVICE
 
+config BAIKAL_MDIO
+	tristate "Driver for the Baikal Electronics GPIO MDIO bus"
+	depends on OF && GPIOLIB && MDIO_BITBANG
+	---help---
+	  Support for Baikal Electronics GPIO MDIO bus
+
 config MDIO_BUS
 	tristate
 	default m if PHYLIB=m
@@ -258,6 +264,13 @@ config SFP
 	depends on HWMON || HWMON=n
 	select MDIO_I2C
 
+config 88X2222_PHY
+	tristate "Drivers for Marvell 88X2222 Tanceiver"
+	---help---
+	  Support for Marvell Integrated Dual-port
+	  Multi-speed Ethernet Transceivers.
+	  Currently supports 88x2222
+
 config ADIN_PHY
 	tristate "Analog Devices Industrial Ethernet PHYs"
 	help
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index a03437e09..46c7aca31 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -94,3 +94,5 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
+obj-$(CONFIG_BAIKAL_MDIO)       += mdio-be-gpio.o
+obj-$(CONFIG_88X2222_PHY)       += mv88x2222.o
diff --git a/drivers/net/phy/mdio-be-gpio.c b/drivers/net/phy/mdio-be-gpio.c
new file mode 100644
index 000000000..01a2de70c
--- /dev/null
+++ b/drivers/net/phy/mdio-be-gpio.c
@@ -0,0 +1,540 @@
+/*
+ * Baikal Electronics SFP+ mezzanine card MDIO bus driver
+ * Supports OpenFirmware.
+ *
+ * Based on Bitbanged MDIO support driver.
+ * drivers/net/phy/mdio-bitbang.c
+ *
+ * Author: Scott Wood <scottwood@freescale.com>
+ * Copyright (c) 2007 Freescale Semiconductor
+ *
+ * Based on CPM2 MDIO code which is:
+ *
+ * Copyright (c) 2003 Intracom S.A.
+ *  by Pantelis Antoniou <panto@intracom.gr>
+ *
+ * 2005 (c) MontaVista Software, Inc.
+ * Vitaly Bordug <vbordug@ru.mvista.com>
+ *
+ * Paritaly based on GPIO based MDIO bitbang driver.
+ * drivers/net/phy/mdio-gpio.c
+ *
+ * Copyright (c) 2015 Baikal Electronics JSC.
+ *
+ * Author:
+ *   Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Baikal Electronics JSC nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/mdio-bitbang.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/mdio.h>
+#include <linux/phy.h>
+#include <linux/clk.h>
+
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_mdio.h>
+
+#define MDIO_READ 			2
+#define MDIO_WRITE 			1
+
+#define MDIO_C45			(1<<15)
+#define MDIO_C45_ADDR		(MDIO_C45 | 0)
+#define MDIO_C45_READ		(MDIO_C45 | 3)
+#define MDIO_C45_WRITE		(MDIO_C45 | 1)
+#define MDIO_C45_READ_INC	(MDIO_C45 | 2)
+
+/*
+ * Minimum MDC period is 400 ns, plus some margin for error.
+ * MDIO_DELAY is done twice per period.
+ * Baikal-T SoC GPIO pins trigger clock is 1 MHz.
+ */
+#define MDIO_DELAY 14
+
+/*
+ * The PHY may take up to 300 ns to produce data, plus some margin
+ * for error.
+ * Baikal-T SoC GPIO pins trigger clock is 1 MHz.
+ */
+#define MDIO_READ_DELAY_US	10
+#define MDIO_RESET_DELAY_US	100
+
+/*
+ * Driver specific defines
+ */
+#define DRIVER_NAME	"Baikal Electronics mezzanine card MDIO bus driver"
+#define DRIVER_VERSION	"1.04a"
+#define DRIVER_DEV	"be-mdio"
+
+/* Default GPIO trigger freq is 1 MHz */
+#define MDIO_TRIG_FREQ	1000000
+
+/*
+ * Basic driver function
+ */
+struct be_mdio_data {
+	struct phy_device *phydev;
+	struct mii_bus *mii;
+	struct clk *clk;
+	int mdc, mdio, mdo, rst;
+	int mdc_active_low, mdio_active_low;
+	int mdo_active_low, rst_active_low;
+	unsigned int delay, read_delay, reset_delay;
+    /* PHY addresses to be ignored when probing */
+    unsigned int phy_mask;
+    /* IRQ mask */
+	int irqs[PHY_MAX_ADDR];
+};
+
+/*
+ * Physical level of MDIO bus
+ */
+static inline void be_mdio_dir(struct be_mdio_data *data, int dir)
+{
+	if (data->mdo >= 0) {
+		/* Separate output pin. Always set its value to high
+		 * when changing direction. If direction is input,
+		 * assume the pin serves as pull-up. If direction is
+		 * output, the default value is high.
+		 */
+		gpio_set_value(data->mdo, 1 ^ data->mdo_active_low);
+		return;
+	}
+
+	if (dir)
+		gpio_direction_output(data->mdio, 1 ^ data->mdio_active_low);
+	else
+		gpio_direction_input(data->mdio);
+}
+
+static inline int be_mdio_get(struct be_mdio_data *data)
+{
+	return gpio_get_value(data->mdio) ^ data->mdio_active_low;
+}
+
+static inline void be_mdio_set(struct be_mdio_data *data, int what)
+{
+	if (data->mdo >= 0)
+		gpio_set_value(data->mdo, what ^ data->mdo_active_low);
+	else
+		gpio_set_value(data->mdio, what ^ data->mdio_active_low);
+}
+
+static inline void be_mdc_set(struct be_mdio_data *data, int what)
+{
+	gpio_set_value(data->mdc, what ^ data->mdc_active_low);
+}
+
+/*
+ * Logical level of MDIO bus
+ */
+
+/* MDIO must already be configured as output. */
+static void be_mdio_send_bit(struct be_mdio_data *data, int val) {
+	be_mdio_set(data, val);
+	//ndelay(MDIO_DELAY);	//udelay(1..3);ndelay(400);
+	udelay(MDIO_DELAY);
+	be_mdc_set(data, 1);
+	//ndelay(MDIO_DELAY);	//udelay(1..3);ndelay(400);
+	udelay(MDIO_DELAY);
+	be_mdc_set(data, 0);
+}
+
+/* MDIO must already be configured as output. */
+/*static void be_mdio_send_ta(struct be_mdio_data *data, int val) {
+	be_mdio_set(data, val);
+	mdelay(data->read_delay);
+	be_mdc_set(data, 1);
+	mdelay(data->read_delay);
+	be_mdc_set(data, 0);
+}*/
+
+/* MDIO must already be configured as input. */
+static int be_mdio_get_bit(struct be_mdio_data *data) {
+	udelay(MDIO_DELAY);
+	be_mdc_set(data, 1);
+	udelay(MDIO_DELAY);
+	be_mdc_set(data, 0);
+	return be_mdio_get(data);
+}
+
+/* MDIO must already be configured as output. */
+static void be_mdio_send_num(struct be_mdio_data *data, u16 val, int bits) {
+	int i;
+
+	be_mdio_dir(data, 1);
+
+	for (i = bits - 1; i >= 0; i--)
+		be_mdio_send_bit(data, (val >> i) & 1);
+}
+
+/* MDIO must already be configured as input. */
+static u16 be_mdio_get_num(struct be_mdio_data *data, int bits) {
+	int i;
+	u16 ret = 0;
+
+	be_mdio_dir(data, 0);
+
+	for (i = bits - 1; i >= 0; i--) {
+		ret <<= 1;
+		ret |= be_mdio_get_bit(data);
+	}
+	return ret;
+}
+
+/*
+ * Utility to send the preamble, address, and
+ * register (common to read and write).
+ */
+static void be_mdio_cmd(struct be_mdio_data *data, int op, u8 phy, u8 reg) {
+	int i;
+
+	be_mdio_dir(data, 1);
+	/*
+	 * Send a 32 bit preamble ('1's) with an extra '1' bit for good
+	 * measure.  The IEEE spec says this is a PHY optional
+	 * requirement. This means that we are doing more preambles
+	 * than we need, but it is safer and will be much more robust.
+	 */
+	for (i = 0; i < 32; i++)
+		be_mdio_send_bit(data, 1);
+	/*
+	 * Send the start bit (01) and the read opcode (10) or write (10).
+	 * Clause 45 operation uses 00 for the start and 11, 10 for
+	 * read/write.
+	 */
+	be_mdio_send_bit(data, 0);
+	if (op & MDIO_C45)
+		be_mdio_send_bit(data, 0);
+	else
+		be_mdio_send_bit(data, 1);
+	be_mdio_send_bit(data, (op >> 1) & 1);
+	be_mdio_send_bit(data, (op >> 0) & 1);
+
+	be_mdio_send_num(data, phy, 5);
+	be_mdio_send_num(data, reg, 5);
+}
+
+/* In clause 45 mode all commands are prefixed by MDIO_ADDR to specify the
+   lower 16 bits of the 21 bit address. This transfer is done identically to a
+   MDIO_WRITE except for a different code. To enable clause 45 mode or
+   MII_ADDR_C45 into the address. Theoretically clause 45 and normal devices
+   can exist on the same bus. Normal devices should ignore the MDIO_ADDR
+   phase. */
+static int be_mdio_cmd_addr(struct be_mdio_data *data, int phy, u32 addr) {
+	unsigned int dev_addr = (addr >> 16) & 0x1F;
+	unsigned int reg = addr & 0xFFFF;
+
+	be_mdio_cmd(data, MDIO_C45_ADDR, phy, dev_addr);
+
+	/* send the turnaround (10) */
+	be_mdio_send_bit(data, 1);
+	be_mdio_send_bit(data, 0);
+
+	be_mdio_send_num(data, reg, 16);
+
+	be_mdio_dir(data, 0);
+	be_mdio_get_bit(data);
+
+	return dev_addr;
+}
+
+static int be_mdio_read(struct mii_bus *bus, int phy, int reg) {
+	struct be_mdio_data *data = bus->priv;
+	int ret, i;
+
+	if (reg & MII_ADDR_C45) {
+		reg = be_mdio_cmd_addr(data, phy, reg);
+		be_mdio_cmd(data, MDIO_C45_READ, phy, reg);
+	} else
+		be_mdio_cmd(data, MDIO_READ, phy, reg);
+
+	be_mdio_dir(data, 0);
+
+	/* check the turnaround bit: the PHY should be driving it to zero */
+	if (be_mdio_get_bit(data) != 0) {
+		/* PHY didn't drive TA low -- flush any bits it may be trying to send. */
+		for (i = 0; i < 32; i++)
+			be_mdio_get_bit(data);
+
+		return 0xffff;
+	}
+
+	ret = be_mdio_get_num(data, 16);
+	be_mdio_get_bit(data);
+	return ret;
+}
+
+static int be_mdio_write(struct mii_bus *bus, int phy, int reg, u16 val) {
+	struct be_mdio_data *data = bus->priv;
+
+	if (reg & MII_ADDR_C45) {
+		reg = be_mdio_cmd_addr(data, phy, reg);
+		be_mdio_cmd(data, MDIO_C45_WRITE, phy, reg);
+	} else
+		be_mdio_cmd(data, MDIO_WRITE, phy, reg);
+
+	/* send the turnaround (10) */
+	be_mdio_send_bit(data, 1);
+	be_mdio_send_bit(data, 0);
+
+	be_mdio_send_num(data, val, 16);
+
+	be_mdio_dir(data, 0);
+	be_mdio_get_bit(data);
+
+	return 0;
+}
+
+static int __maybe_unused be_mdio_reset(struct mii_bus *bus) {
+	struct be_mdio_data *data = bus->priv;
+
+	if (data->rst < 0)
+		return 0;
+
+	gpio_set_value(data->rst, 1 ^ data->rst_active_low);
+	mdelay(data->reset_delay);
+
+	gpio_set_value(data->rst, 0 ^ data->rst_active_low);
+	mdelay(data->reset_delay);
+
+	return 0;
+}
+
+/*
+ * MDIO bus open firmware data
+ */
+static void *be_mdio_of_get_data(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct be_mdio_data *pdata;
+	enum of_gpio_flags flags;
+	unsigned int freq = 0; 
+	int ret;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	ret =  of_get_named_gpio_flags(np, "mdc-pin", 0, &flags);
+	if (ret < 0)
+		return NULL;
+
+	pdata->mdc = ret;
+	pdata->mdc_active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	ret =  of_get_named_gpio_flags(np, "mdio-pin", 0, &flags);
+	if (ret < 0)
+		return NULL;
+	pdata->mdio = ret;
+	pdata->mdio_active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	pdata->mdo = -1;
+	ret = of_get_named_gpio_flags(np, "mdo-pin", 0, &flags);
+	if (ret >= 0) {
+		pdata->mdo = ret;
+		pdata->mdo_active_low = flags & OF_GPIO_ACTIVE_LOW;
+	}
+
+	pdata->rst = -1;
+	ret =  of_get_named_gpio_flags(np, "rst-pin", 0, &flags);
+	if (ret >= 0) {
+		pdata->rst = ret;
+		pdata->rst_active_low = flags & OF_GPIO_ACTIVE_LOW;
+	}
+
+	pdata->clk = of_clk_get(np, 0);
+
+	if (IS_ERR(pdata->clk))
+		of_property_read_u32(pdev->dev.of_node, "clock-frequency", &freq);
+	else
+		freq =  clk_get_rate(pdata->clk);
+
+	if (!freq)
+		freq = MDIO_TRIG_FREQ;
+
+	ret = 1000000 / freq;
+
+	/* Timing */
+	pdata->read_delay = (ret > MDIO_READ_DELAY_US) ? ret : MDIO_READ_DELAY_US;
+	pdata->reset_delay = (ret > MDIO_RESET_DELAY_US) ?  ret : MDIO_RESET_DELAY_US;
+
+	return pdata;
+}
+
+/*
+ * MDIO bus init
+ */
+static struct mii_bus *be_mdio_bus_init(struct device *dev, struct be_mdio_data *pdata, int bus_id) {
+	struct mii_bus *bus;
+	int i;
+
+	bus = mdiobus_alloc();
+	if (!bus) {
+		dev_err(dev, "Unable to allocate MDIO bus\n");
+		goto error;
+	}
+
+	bus->read = be_mdio_read;
+	bus->write = be_mdio_write;
+	bus->priv = pdata;
+
+	bus->name = "Baikal GPIO MDIO bus";
+
+	bus->phy_mask = pdata->phy_mask;
+	memcpy(bus->irq, pdata->irqs, PHY_MAX_ADDR);
+	bus->parent = dev;
+
+	if (bus->phy_mask == ~0) {
+		dev_err(dev, "All PHY's are masked - nothing to attach\n");
+		goto error_free_bus;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		if (!bus->irq[i])
+			bus->irq[i] = PHY_POLL;
+
+	snprintf(bus->id, MII_BUS_ID_SIZE, "mdio-gpio%d", bus_id);
+
+	if (devm_gpio_request(dev, pdata->mdc, "mdc")) {
+		dev_err(dev, "MDC line (gpio%d) request failed\n", pdata->mdc);
+		goto error_free_bus;
+	}
+
+	if (devm_gpio_request(dev, pdata->mdio, "mdio")){
+		dev_err(dev, "MDIO line (gpio%d) request failed\n", pdata->mdc);
+		goto error_free_bus;
+	}
+
+	if (pdata->mdo >= 0) {
+		if (devm_gpio_request(dev, pdata->mdo, "mdo"))
+			goto error_free_bus;
+		gpio_direction_output(pdata->mdo, 1);
+		gpio_direction_input(pdata->mdio);
+	}
+
+	if (pdata->rst >= 0) {
+		if (devm_gpio_request(dev, pdata->rst, "rst"))
+			pdata->rst= -1;
+		else 
+			gpio_direction_output(pdata->rst, 0);
+	}
+
+	gpio_direction_output(pdata->mdc, 0);
+
+	dev_set_drvdata(dev, bus);
+
+	return bus;
+
+error_free_bus:
+	mdiobus_free(bus);
+error:
+	return NULL;
+}
+
+static int be_mdio_probe(struct platform_device *pdev)
+{
+	struct be_mdio_data *pdata;
+	struct mii_bus *bus;
+	int ret, bus_id;
+
+	if (pdev->dev.of_node) {
+		pdata = be_mdio_of_get_data(pdev);
+		bus_id = of_alias_get_id(pdev->dev.of_node, "mdio-gpio");
+		if (bus_id < 0) {
+			dev_warn(&pdev->dev, "failed to get alias id\n");
+			bus_id = 0;
+		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		bus_id = pdev->id;
+	}
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "No MDIO bus platform data\n");
+		return -ENODEV;
+	}
+
+	bus = be_mdio_bus_init(&pdev->dev, pdata, bus_id);
+	if (!bus) {
+		dev_err(&pdev->dev, "MDIO bus init failed\n");
+		return -ENODEV;
+	}
+
+	if (pdev->dev.of_node)
+		ret = of_mdiobus_register(bus, pdev->dev.of_node);
+	else
+		ret = mdiobus_register(bus);
+
+	if (ret) {
+		dev_err(&pdev->dev, "MDIO bus register failed\n");
+		goto err_mdiobus_register;
+	}
+
+	// bus->reset = be_mdio_reset;
+
+	pdata->mii = bus;
+	dev_info(&pdev->dev, "MDIO ptr=%p\n", bus);
+
+	dev_info(&pdev->dev, DRIVER_NAME);
+	dev_info(&pdev->dev, "Version: " DRIVER_VERSION);
+
+	return 0;
+
+err_mdiobus_register:
+	mdiobus_free(bus);
+
+	return ret;
+}
+
+static int be_mdio_remove(struct platform_device *pdev)
+{
+
+	struct mii_bus *bus = dev_get_drvdata(&pdev->dev);
+	mdiobus_unregister(bus);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static struct of_device_id be_mdio_of_match[] = {
+	{ .compatible = "be,mdio-gpio", },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver be_mdio_driver = {
+	.probe = be_mdio_probe,
+	.remove = be_mdio_remove,
+	.driver		= {
+		.name	= "be-mdio",
+		.of_match_table = be_mdio_of_match,
+	},
+};
+
+module_platform_driver(be_mdio_driver);
+
+MODULE_ALIAS("platform:be-mdio");
+MODULE_AUTHOR("Dmitry Dunaev");
+MODULE_LICENSE("Proprinetary");
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_DESCRIPTION(DRIVER_NAME);
diff --git a/drivers/net/phy/mv88x2222.c b/drivers/net/phy/mv88x2222.c
new file mode 100644
index 000000000..1d2cdd9d2
--- /dev/null
+++ b/drivers/net/phy/mv88x2222.c
@@ -0,0 +1,473 @@
+/*
+ * drivers/net/phy/mv88x2222c
+ *
+ * Driver for Marvell Integrated Dual-port
+ * Multi-speed Ethernet Transceiver 88x2222
+ *
+ * Copyright (c) 2015, 2016, 2020 Baikal Electronics JSC.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Baikal Electronics JSC nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ */
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/mdio.h>
+#include <linux/marvell_phy.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+MODULE_DESCRIPTION("Marvell Ethernet Transceiver driver");
+MODULE_LICENSE("Proprietary");
+
+/* 31.F002 Line side mode (ch.3.1.2, pg.46) */
+#define MV_MODE_LINE_SHF			8
+#define MV_MODE_LINE_10GBR			(0x71UL << 8)
+#define MV_MODE_LINE_10GBW			(0x74UL << 8)
+#define MV_MODE_LINE_2GBX_AN_OFF		(0x76UL << 8)
+#define MV_MODE_LINE_1GBR_AN_OFF		(0x72UL << 8)
+#define MV_MODE_LINE_1GBR_AN_ON			(0x73UL << 8)
+#define MV_MODE_LINE_SGMII_SYS_AN_OFF		(0x7CUL << 8)
+#define MV_MODE_LINE_SGMII_SYS_AN_ON		(0x7DUL << 8)
+#define MV_MODE_LINE_SGMII_NET_AN_OFF		(0x7EUL << 8)
+#define MV_MODE_LINE_SGMII_NET_AN_ON		(0x7FUL << 8)
+#define MV_MODE_LINE_DEFAULT			MV_MODE_LINE_10GBR
+#define MV_MODE_LINE_OF_NAME			"mv,line-mode"
+
+/* 31.F002 Host side mode (ch.3.1.2, pg.46) */
+#define MV_MODE_HOST_SHF			0
+#define MV_MODE_HOST_10GBR			(0x71UL << 0)
+#define MV_MODE_HOST_10GBX2			(0x72UL << 0)
+#define MV_MODE_HOST_10GBX4			(0x73UL << 0)
+#define MV_MODE_HOST_2GBX_AN_OFF		(0x76UL << 0)
+#define MV_MODE_HOST_1GBR_AN_OFF		(0x7AUL << 0)
+#define MV_MODE_HOST_1GBR_AN_ON			(0x7BUL << 0)
+#define MV_MODE_HOST_SGMII_SYS_AN_OFF		(0x7CUL << 0)
+#define MV_MODE_HOST_SGMII_SYS_AN_ON		(0x7DUL << 0)
+#define MV_MODE_HOST_SGMII_NET_AN_OFF		(0x7EUL << 0)
+#define MV_MODE_HOST_SGMII_NET_AN_ON		(0x7FUL << 0)
+#define MV_MODE_HOST_DEFAULT			MV_MODE_HOST_10GBR
+#define MV_MODE_HOST_OF_NAME			"mv,host-mode"
+
+/* 31.F402 Host side line muxing (ch.3.1.5, pg.48) */
+#define MV_ATT_10GBX2_SHF			11
+#define MV_ATT_10GBX2_LANE_0145			(0UL << 11)
+#define MV_ATT_10GBX2_LANE_0123			(1UL << 11)
+#define MV_ATT_10GBR_SHF			9
+#define MV_ATT_10GBR_LANE_0246			(0UL << 9)
+#define MV_ATT_10GBR_LANE_0123			(1UL << 9)
+#define MV_ATT_2GBR_SHF				8
+#define MV_ATT_2GBR_LANE_0246			(0UL << 8)
+#define MV_ATT_2GBR_LANE_0123			(1UL << 8)
+#define MV_ATT_1GBR_SHF				8
+#define MV_ATT_1GBR_LANE_0246			(0UL << 8)
+#define MV_ATT_1GBR_LANE_0123			(1UL << 8)
+#define MV_ATT_DEFAULT				0
+#define MV_ATT_OF_NAME				"mv,mux"
+
+/* 31.F003 Software reset (ch.3.2 pg.50) */
+#define MV_SW_RST_HOST_SHF			7
+#define MV_SW_RST_HOST				(1UL << 7)
+#define MV_SW_RST_LINE_SHF			15
+#define MV_SW_RST_LINE				(1UL << 15)
+#define MV_SW_RST_ALL				(MV_SW_RST_HOST | MV_SW_RST_LINE)
+
+/* 31.F012 GPIO data */
+#define MV_GPIO_TXDISABLE_DATA_SHF		8
+
+/* 31.F013 Tristate Control */
+#define MV_GPIO_TXDISABLE_OUTP_EN_SHF		8
+
+/* 31.F016 Interrupt type 3 */
+#define MV_GPIO_TXDISABLE_FN_SHF		3
+#define MV_GPIO_TXDISABLE_FN_GPIO		0x1
+
+/* Devices in package and registers */
+#define MV_DEV_10GBW_IRQ_ENABLE			0x8000
+#define MV_DEV_10GBW_IRQ_STATUS			0x8001
+#define MV_DEV_10GBW_IRQ_REALTIME		0x8002
+
+#define MV_DEV_10GBR_ANEG               0x2000
+#define MV_DEV_10GBR_IRQ_ENABLE			0x8000
+#define MV_DEV_10GBR_IRQ_STATUS			0x8001
+#define MV_DEV_10GBR_IRQ_REALTIME		0x8002
+
+#define MV_DEV_GBX_IRQ_ENABLE			0xA000
+#define MV_DEV_GBX_IRQ_STATUS			0xA001
+#define MV_DEV_GBX_IRQ_REALTIME			0xA002
+
+#define MV_DEV_MISC_IRQ_ENABLE			0xF00A
+#define MV_DEV_MISC_IRQ_STATUS			0xF00B
+
+#define MV_DEV_GPIO_DATA			0xF012
+#define MV_DEV_GPIO_TRISTATE_CTL		0xF013
+#define MV_DEV_GPIO_INTERRUPT_TYPE_3		0xF016
+
+#define MV_DEV_CHIP_HOST_LINE			0xF002
+#define MV_DEV_CHIP_RESET			0xF003
+#define MV_DEV_CHIP_MUX				0xF402
+#define MV_DEV_CHIP_IRQ_STATUS			0xF420
+#define MV_DEV_CHIP_IRQ_CONTROL			0xF421
+
+#define MV_RESET_DELAY_US			500
+
+struct mode
+{
+    unsigned int mode_num;
+    char mode_name[16];
+}; 
+
+static struct mode line_modes[] =
+{
+        {MV_MODE_LINE_10GBR, "KR"},
+        {MV_MODE_LINE_10GBW, "10GBW"},
+        {MV_MODE_LINE_2GBX_AN_OFF, "2GBX_AN_OFF"},
+        {MV_MODE_LINE_1GBR_AN_OFF, "1GBR_AN_OFF"},
+        {MV_MODE_LINE_1GBR_AN_ON, "1GBR_AN_ON"},
+        {MV_MODE_LINE_SGMII_SYS_AN_OFF, "SGMII_SYS_AN_OFF"},
+        {MV_MODE_LINE_SGMII_SYS_AN_ON, "SGMI_SYS_AN_ON"},
+        {MV_MODE_LINE_SGMII_NET_AN_OFF, "SMGII_NET_AN_OFF"},
+        {MV_MODE_LINE_SGMII_NET_AN_ON, "SGMII_NET_AN_ON"}
+};
+
+static struct mode host_modes[] =
+{
+        {MV_MODE_HOST_10GBR, "KR"},
+        {MV_MODE_HOST_10GBX2, "10GBX2"},
+        {MV_MODE_HOST_10GBX4, "KX4"},
+        {MV_MODE_HOST_2GBX_AN_OFF, "2GBX_AN_OFF"},
+        {MV_MODE_HOST_1GBR_AN_OFF, "1GBR_AN_OFF"},
+        {MV_MODE_HOST_1GBR_AN_ON, "1GBR_AN_ON"},
+        {MV_MODE_HOST_SGMII_SYS_AN_OFF, "SGMII_SYS_AN_OFF"},
+        {MV_MODE_HOST_SGMII_SYS_AN_ON, "SGMII_SYS_AN_ON"},
+        {MV_MODE_HOST_SGMII_NET_AN_OFF, "SGMII_NE_AN_OFF"},
+        {MV_MODE_HOST_SGMII_NET_AN_ON, "SGMII_NET_AN_ON"}
+};
+
+struct mv88x2222_data {
+	int irq;
+	int rst_active_low, irq_active_low;
+	int line_mode, host_mode, mux;
+};
+
+static void *marvell_of_get_data(struct phy_device *phydev)
+{
+	struct device_node *np = phydev->mdio.dev.of_node;
+	struct mv88x2222_data *pdata;
+	enum of_gpio_flags flags;
+	int ret;
+	char mode[32];
+	unsigned int i = 0;
+	const char *pm = mode;
+
+	pdata = devm_kzalloc(&phydev->mdio.dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	ret =  of_get_named_gpio_flags(np, "irq-pin", 0, &flags);
+	if (ret >= 0) {
+		pdata->irq = ret;
+		pdata->irq_active_low = flags & OF_GPIO_ACTIVE_LOW;
+		dev_info(&phydev->mdio.dev, "irq gpio pin=%d", ret);
+	}
+
+	pdata->line_mode = MV_MODE_LINE_DEFAULT;
+	ret = of_property_read_string(np, MV_MODE_LINE_OF_NAME, &pm);
+	if (!ret) {
+		for(i = 0; i < sizeof(line_modes) / sizeof(struct mode); ++i) {
+		    if(strcasecmp(line_modes[i].mode_name, pm) == 0) {
+			pdata->line_mode = line_modes[i].mode_num;
+			break;
+		    }
+		}
+	}
+
+	pdata->host_mode = MV_MODE_HOST_DEFAULT;
+	ret = of_property_read_string(np, MV_MODE_HOST_OF_NAME, &pm);
+	if (!ret) {
+		for(i = 0; i < sizeof(host_modes) / sizeof(struct mode); ++i) {
+		    if(strcasecmp(host_modes[i].mode_name, pm) == 0) {
+			pdata->host_mode = host_modes[i].mode_num;
+			break;
+		    }
+		}
+	}
+
+	/* Default value at now */
+	pdata->mux = MV_ATT_DEFAULT;
+
+	return pdata;
+}
+
+static int marvell_soft_reset(struct phy_device *phydev) {
+	int ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_RESET,
+				MV_SW_RST_ALL);
+	int count = 50;
+
+	if (ret) {
+		dev_warn(&phydev->mdio.dev, "software reset failed\n");
+		return ret;
+	}
+
+	do {
+		usleep_range(MV_RESET_DELAY_US, MV_RESET_DELAY_US + 100);
+		ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_RESET);
+	} while ((ret & MV_SW_RST_ALL) || count--);
+
+	return 0;
+}
+
+static int marvell_config_init(struct phy_device *phydev)
+{
+	struct mv88x2222_data *pdata = phydev->priv;
+	int ret;
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE,
+			    pdata->line_mode | pdata->host_mode);
+	if (ret)
+		return 1;
+
+        phydev->speed = SPEED_10000;
+        phydev->duplex = DUPLEX_FULL;
+
+	/*
+	 * This must be done after mode set;
+	 */
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE);
+	ret |= 0x8000;
+	phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE, ret);
+	
+	marvell_soft_reset(phydev);
+
+	dev_info(&phydev->mdio.dev, "phy(%d, %x)=%x\n", MDIO_MMD_VEND2,
+			MV_DEV_CHIP_HOST_LINE,
+			phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE));
+
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Backplane_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			phydev->supported, 1);
+	linkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported, 1);
+
+	phydev->pause = 0;
+	phydev->asym_pause = 0;
+	phydev->interface = PHY_INTERFACE_MODE_XGMII;
+	phydev->duplex = DUPLEX_FULL;
+
+	switch (pdata->line_mode) {
+	case MV_MODE_LINE_10GBR:
+	case MV_MODE_LINE_10GBW:
+		phydev->speed = SPEED_10000;
+		break;
+	case MV_MODE_LINE_2GBX_AN_OFF:
+		phydev->speed = SPEED_2500;
+		break;
+	default:
+		phydev->speed = SPEED_1000;
+		break;
+	}
+
+	return 0;
+}
+
+static int marvell_adjust_tx(struct phy_device *phydev)
+{
+	int reg;
+	int line_link = 1;
+
+	/* Switch tristate to "write to pin/read from register" */
+	reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_TRISTATE_CTL);
+	phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_TRISTATE_CTL,\
+	reg | (1 << MV_GPIO_TXDISABLE_OUTP_EN_SHF));
+
+	/* Switch off TX_DISABLE */
+	reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA);
+	phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA, reg & \
+		~(1 << MV_GPIO_TXDISABLE_DATA_SHF));
+
+	/* Check if opto-cable is plugged */
+	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);
+	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+		line_link = 0;
+
+	if (line_link) {
+		/* It's fine */
+		return 0;
+
+	} else {
+		/* Switch on TX_DISABLE */
+		reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA);
+		phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA, reg | \
+			(1 << MV_GPIO_TXDISABLE_DATA_SHF));
+	}
+
+	return 1;
+}
+
+static int marvell_update_link(struct phy_device *phydev)
+{
+	int reg;
+	int host_mode = 0;
+	int line_mode = 0;
+
+	/* Default link status */
+	phydev->link = 1;
+
+	reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_CHIP_HOST_LINE);
+	if (reg < 0)
+	{
+		phydev->link = 0;
+		return 0;
+	}
+
+	host_mode = reg & 0x007F;
+	line_mode = reg & 0x7F00;
+
+	/* Read host link status */
+	if (host_mode == MV_MODE_HOST_10GBX4)
+		reg = phy_read_mmd(phydev, MDIO_MMD_PHYXS, 0x1001);
+	else
+		reg = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_STAT1);
+
+	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+		phydev->link = 0;
+
+	/* Read line link status */
+	if (line_mode == MV_MODE_LINE_10GBR)
+		reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);
+	else
+		reg = phy_read_mmd(phydev, MDIO_MMD_PCS, 0x2001);
+    
+	if ((reg < 0) || !(reg & MDIO_STAT1_LSTATUS))
+		phydev->link = 0;
+
+    	/* 
+     	 * PMAPMD link status is always broken
+     	 * later we need to update this driver;
+     	 */
+	reg = marvell_adjust_tx(phydev);
+	if (reg < 0)
+		phydev->link = 0;
+
+	return 0;
+}
+
+static int marvell_read_status(struct phy_device *phydev) 
+{
+	int reg;
+
+    	/* Update the link, but return if there was an error */
+	reg = marvell_update_link(phydev);
+	if (reg < 0)
+		return reg;
+
+	/* Read line control reg */
+	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
+	if (reg < 0)
+		return reg;
+
+	return 0;
+}
+
+static int marvell_config_aneg(struct phy_device *phydev)
+{
+	linkmode_copy(phydev->advertising, phydev->supported);
+
+	return 0;
+}
+
+static int marvell_probe(struct phy_device *phydev)
+{
+	struct mv88x2222_data *pdata = NULL;
+	int reg = 0;
+
+	if (phydev->mdio.dev.of_node)
+		pdata = marvell_of_get_data(phydev);
+
+	if (!pdata) {
+		dev_err(&phydev->mdio.dev, "No PHY platform data\n");
+		return -ENODEV;
+	}
+
+	phydev->priv = pdata;
+	dev_info(&phydev->mdio.dev, "probed %s at 0x%02x\n",
+		 phydev->drv->name, phydev->mdio.addr);
+    	reg = phy_read_mmd(phydev, MDIO_MMD_PCS, 0x0002);
+	
+    return 0;
+}
+
+static int marvell_suspend(struct phy_device *phydev)
+{
+	int reg;
+	mutex_lock(&phydev->lock);
+
+	/* Switch tristate to "write to pin/read from register" */
+	reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_TRISTATE_CTL);
+	phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_TRISTATE_CTL,\
+	reg | (1 << MV_GPIO_TXDISABLE_OUTP_EN_SHF));
+
+	/* Switch on TX_DISABLE */
+	reg = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA);
+	phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_DEV_GPIO_DATA, reg | \
+		(1 << MV_GPIO_TXDISABLE_DATA_SHF));
+	/* TBD Probably switch to lowpower mode */
+
+	mutex_unlock(&phydev->lock);
+
+	return 0;
+}
+
+static int marvell_match_phy_device(struct phy_device *phydev)
+{
+	unsigned int phy_id = phydev->c45_ids.device_ids[MDIO_MMD_PCS] & MARVELL_PHY_ID_MASK;
+	
+    return  (phy_id == MARVELL_PHY_ID_88X2222) || (phy_id == MARVELL_PHY_ID_88X2222R);
+}
+
+static struct phy_driver marvell_drivers[] = {
+	{
+		.phy_id = MARVELL_PHY_ID_88X2222,
+		.phy_id_mask = MARVELL_PHY_ID_MASK,
+		.name = "Marvell 88X2222",
+		.features = 0,
+		.config_init = marvell_config_init,
+		.config_aneg = marvell_config_aneg,
+		.probe = marvell_probe,
+		.match_phy_device = marvell_match_phy_device,
+		.read_status = marvell_read_status,
+		.soft_reset = marvell_soft_reset,
+		.resume = genphy_resume,
+		.suspend = marvell_suspend,
+	},
+};
+module_phy_driver(marvell_drivers);
+
+static struct mdio_device_id __maybe_unused marvell_tbl[] = {
+	{ MARVELL_PHY_ID_88X2222, MARVELL_PHY_ID_MASK },
+	{ MARVELL_PHY_ID_88X2222R, MARVELL_PHY_ID_MASK },
+	{ }
+};
+MODULE_DEVICE_TABLE(mdio, marvell_tbl);
diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 0ba988b5b..e47243230 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -209,6 +209,17 @@ config PCIE_ARTPEC6_EP
 	  Enables support for the PCIe controller in the ARTPEC-6 SoC to work in
 	  endpoint mode. This uses the DesignWare core.
 
+config PCI_BAIKAL
+	tristate "Baikal SoC PCIe controller"
+	depends on ARCH_BAIKAL
+	depends on OF && HAS_IOMEM
+	depends on PCI_MSI_IRQ_DOMAIN
+	select PCIE_DW_HOST
+	help
+	  Enables support for the PCIe controller in the Baikal SoC. There are
+	  three instances of PCIe controller in Baikal-M. Two of the controllers
+	  support PCIe 3.0 x4 and the remaining one supports PCIe 3.0 x8.
+
 config PCIE_KIRIN
 	depends on OF && (ARM64 || COMPILE_TEST)
 	bool "HiSilicon Kirin series SoCs PCIe controllers"
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index 69faff371..b44f54a15 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_PCI_LAYERSCAPE_EP) += pci-layerscape-ep.o
 obj-$(CONFIG_PCIE_QCOM) += pcie-qcom.o
 obj-$(CONFIG_PCIE_ARMADA_8K) += pcie-armada8k.o
 obj-$(CONFIG_PCIE_ARTPEC6) += pcie-artpec6.o
+obj-$(CONFIG_PCI_BAIKAL) += pcie-baikal.o
 obj-$(CONFIG_PCIE_KIRIN) += pcie-kirin.o
 obj-$(CONFIG_PCIE_HISI_STB) += pcie-histb.o
 obj-$(CONFIG_PCI_MESON) += pci-meson.o
diff --git a/drivers/pci/controller/dwc/pcie-baikal.c b/drivers/pci/controller/dwc/pcie-baikal.c
new file mode 100644
index 000000000..1e2f64194
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-baikal.c
@@ -0,0 +1,718 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PCIe RC driver for Baikal SoC
+ *
+ * Copyright (C) 2019-2021 Baikal Electronics, JSC
+ * Authors: Pavel Parkhomenko <pavel.parkhomenko@baikalelectronics.ru>
+ *          Mikhail Ivanov <michail.ivanov@baikalelectronics.ru>
+ */
+
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip/arm-gic-v3.h>
+#include <linux/kernel.h>
+#include <linux/mfd/baikal/lcru-pcie.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pci.h>
+#include <linux/phy/phy.h>
+#include <linux/resource.h>
+
+#include "pcie-designware.h"
+
+struct baikal_pcie_rc {
+	struct dw_pcie	 *pcie;
+	unsigned	 bus_nr;
+	struct regmap	 *lcru;
+	struct gpio_desc *reset_gpio;
+	bool		 reset_active_low;
+	char		 reset_name[32];
+	bool		 retrained;
+};
+
+#define to_baikal_pcie_rc(x)	dev_get_drvdata((x)->dev)
+
+#define PCIE_DEVICE_CONTROL_DEVICE_STATUS_REG	0x78
+#define PCIE_CAP_CORR_ERR_REPORT_EN		BIT(0)
+#define PCIE_CAP_NON_FATAL_ERR_REPORT_EN	BIT(1)
+#define PCIE_CAP_FATAL_ERR_REPORT_EN		BIT(2)
+#define PCIE_CAP_UNSUPPORT_REQ_REP_EN		BIT(3)
+
+#define PCIE_LINK_CAPABILITIES_REG		0x7c
+#define PCIE_CAP_MAX_LINK_WIDTH_MASK		0x3f0
+#define PCIE_CAP_MAX_LINK_WIDTH_SHIFT		4
+
+#define PCIE_LINK_CONTROL_LINK_STATUS_REG	0x80
+#define PCIE_CAP_LINK_SPEED_MASK		0xf0000
+#define PCIE_CAP_LINK_SPEED_SHIFT		16
+#define PCIE_CAP_NEGO_LINK_WIDTH_MASK		0x3f00000
+#define PCIE_CAP_NEGO_LINK_WIDTH_SHIFT		20
+#define PCIE_CAP_LINK_TRAINING			BIT(27)
+
+#define PCIE_ROOT_CONTROL_ROOT_CAPABILITIES_REG	0x8c
+#define PCIE_CAP_SYS_ERR_ON_CORR_ERR_EN		BIT(0)
+#define PCIE_CAP_SYS_ERR_ON_NON_FATAL_ERR_EN	BIT(1)
+#define PCIE_CAP_SYS_ERR_ON_FATAL_ERR_EN	BIT(2)
+#define PCIE_CAP_PME_INT_EN			BIT(3)
+
+#define PCIE_LINK_CONTROL2_LINK_STATUS2_REG	0xa0
+#define PCIE_CAP_TARGET_LINK_SPEED_MASK		0xf
+
+#define PCIE_UNCORR_ERR_STATUS_REG		0x104
+#define PCIE_CORR_ERR_STATUS_REG		0x110
+
+#define PCIE_ROOT_ERR_CMD_REG			0x12c
+#define PCIE_CORR_ERR_REPORTING_EN		BIT(0)
+#define PCIE_NON_FATAL_ERR_REPORTING_EN		BIT(1)
+#define PCIE_FATAL_ERR_REPORTING_EN		BIT(2)
+
+#define PCIE_ROOT_ERR_STATUS_REG		0x130
+
+#define PCIE_GEN2_CTRL_REG			0x80c
+#define PCIE_DIRECT_SPEED_CHANGE		BIT(17)
+
+#define PCIE_MSI_CTRL_ADDR_LO_REG		0x820
+#define PCIE_MSI_CTRL_ADDR_HI_REG		0x824
+
+#define PCIE_IATU_VIEWPORT_REG			0x900
+#define PCIE_IATU_REGION_INBOUND		BIT(31)
+#define PCIE_IATU_REGION_OUTBOUND		0
+#define PCIE_IATU_REGION_CTRL_2_REG		0x908
+
+static int baikal_pcie_link_up(struct dw_pcie *pcie)
+{
+	struct baikal_pcie_rc *rc = to_baikal_pcie_rc(pcie);
+	u32 reg;
+
+	reg = baikal_pcie_lcru_readl(rc->lcru,
+				     BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+
+	if (!(reg & BAIKAL_PCIE_LTSSM_ENABLE)) {
+		return 0;
+	}
+
+	reg = baikal_pcie_lcru_readl(rc->lcru,
+				     BAIKAL_LCRU_PCIE_STATUS(rc->bus_nr));
+
+	return (reg & BAIKAL_PCIE_SMLH_LINKUP) &&
+	       (reg & BAIKAL_PCIE_RDLH_LINKUP);
+}
+
+static int baikal_pcie_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *pcie = to_dw_pcie_from_pp(pp);
+	struct baikal_pcie_rc *rc = to_baikal_pcie_rc(pcie);
+	struct device *dev = pcie->dev;
+	int err;
+	int linkup;
+	unsigned idx;
+	u32 reg;
+
+	/* Disable access to PHY registers and DBI2 mode */
+	reg = baikal_pcie_lcru_readl(rc->lcru,
+				     BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+
+	reg &= ~(BAIKAL_PCIE_PHY_MGMT_ENABLE |
+		 BAIKAL_PCIE_DBI2_MODE);
+
+	baikal_pcie_lcru_writel(rc->lcru,
+				BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr), reg);
+
+	rc->retrained = false;
+	linkup = baikal_pcie_link_up(pcie);
+
+	/* If link is not established yet, reset the RC */
+	if (!linkup) {
+		/* Disable link training */
+		reg = baikal_pcie_lcru_readl(rc->lcru,
+					  BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+
+		reg &= ~BAIKAL_PCIE_LTSSM_ENABLE;
+		baikal_pcie_lcru_writel(rc->lcru,
+					BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr),
+					reg);
+
+		/* Assert PERST pin */
+		if (rc->reset_gpio != NULL) {
+			unsigned long gpio_flags;
+
+			if (rc->reset_active_low) {
+				gpio_flags = GPIOF_ACTIVE_LOW |
+					     GPIOF_OUT_INIT_LOW;
+			} else {
+				gpio_flags = GPIOF_OUT_INIT_HIGH;
+			}
+
+			err = devm_gpio_request_one(dev,
+						   desc_to_gpio(rc->reset_gpio),
+						   gpio_flags, rc->reset_name);
+			if (err) {
+				dev_err(dev, "request GPIO failed (%d)\n", err);
+				return err;
+			}
+		}
+
+		/* Reset the RC */
+		reg = baikal_pcie_lcru_readl(rc->lcru,
+					    BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+
+		reg |= BAIKAL_PCIE_NONSTICKY_RST |
+		       BAIKAL_PCIE_STICKY_RST	 |
+		       BAIKAL_PCIE_PWR_RST	 |
+		       BAIKAL_PCIE_CORE_RST	 |
+		       BAIKAL_PCIE_PHY_RESET;
+
+		/* If the RC is PCIe x8, reset PIPE0 and PIPE1 */
+		if (rc->bus_nr == 2) {
+			reg |= BAIKAL_PCIE_PIPE0_RESET |
+			       BAIKAL_PCIE_PIPE1_RESET;
+		} else {
+			reg |= BAIKAL_PCIE_PIPE_RESET;
+		}
+
+		baikal_pcie_lcru_writel(rc->lcru,
+					BAIKAL_LCRU_PCIE_RESET(rc->bus_nr),
+					reg);
+
+		usleep_range(20000, 30000);
+
+		if (rc->reset_gpio != NULL) {
+			/* Deassert PERST pin */
+			gpiod_set_value_cansleep(rc->reset_gpio, 0);
+		}
+
+		/* Deassert PHY reset */
+		reg = baikal_pcie_lcru_readl(rc->lcru,
+					    BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+
+		reg &= ~BAIKAL_PCIE_PHY_RESET;
+		baikal_pcie_lcru_writel(rc->lcru,
+					BAIKAL_LCRU_PCIE_RESET(rc->bus_nr),
+					reg);
+
+		/* Deassert all software controlled resets */
+		reg = baikal_pcie_lcru_readl(rc->lcru,
+					    BAIKAL_LCRU_PCIE_RESET(rc->bus_nr));
+
+		reg &= ~(BAIKAL_PCIE_ADB_PWRDWN	   |
+			 BAIKAL_PCIE_HOT_RESET	   |
+			 BAIKAL_PCIE_NONSTICKY_RST |
+			 BAIKAL_PCIE_STICKY_RST	   |
+			 BAIKAL_PCIE_PWR_RST	   |
+			 BAIKAL_PCIE_CORE_RST	   |
+			 BAIKAL_PCIE_PHY_RESET);
+
+		if (rc->bus_nr == 2) {
+			reg &= ~(BAIKAL_PCIE_PIPE0_RESET |
+				 BAIKAL_PCIE_PIPE1_RESET);
+		} else {
+			reg &= ~BAIKAL_PCIE_PIPE_RESET;
+		}
+
+		baikal_pcie_lcru_writel(rc->lcru,
+					BAIKAL_LCRU_PCIE_RESET(rc->bus_nr),
+					reg);
+	}
+
+	/* Deinitialise all iATU regions */
+	for (idx = 0; idx < pcie->num_viewport; ++idx) {
+		dw_pcie_writel_dbi(pcie, PCIE_IATU_VIEWPORT_REG,
+					 PCIE_IATU_REGION_OUTBOUND | idx);
+		dw_pcie_writel_dbi(pcie, PCIE_IATU_REGION_CTRL_2_REG, 0);
+	}
+
+	dw_pcie_setup_rc(pp);
+
+	/* Set prog-if 01 [subtractive decode] */
+	dw_pcie_dbi_ro_wr_en(pcie);
+	reg = dw_pcie_readl_dbi(pcie, PCI_CLASS_REVISION);
+	reg = (reg & 0xffff00ff) | (1 << 8);
+	dw_pcie_writel_dbi(pcie, PCI_CLASS_REVISION, reg);
+	dw_pcie_dbi_ro_wr_dis(pcie);
+
+	/* Enable error reporting */
+	reg = dw_pcie_readl_dbi(pcie, PCIE_ROOT_ERR_CMD_REG);
+	reg |= PCIE_CORR_ERR_REPORTING_EN      |
+	       PCIE_NON_FATAL_ERR_REPORTING_EN |
+	       PCIE_FATAL_ERR_REPORTING_EN;
+	dw_pcie_writel_dbi(pcie, PCIE_ROOT_ERR_CMD_REG, reg);
+
+	reg = dw_pcie_readl_dbi(pcie, PCIE_DEVICE_CONTROL_DEVICE_STATUS_REG);
+	reg |= PCIE_CAP_CORR_ERR_REPORT_EN	|
+	       PCIE_CAP_NON_FATAL_ERR_REPORT_EN	|
+	       PCIE_CAP_FATAL_ERR_REPORT_EN	|
+	       PCIE_CAP_UNSUPPORT_REQ_REP_EN;
+	dw_pcie_writel_dbi(pcie, PCIE_DEVICE_CONTROL_DEVICE_STATUS_REG, reg);
+
+	reg = dw_pcie_readl_dbi(pcie, PCIE_ROOT_CONTROL_ROOT_CAPABILITIES_REG);
+	reg |= PCIE_CAP_SYS_ERR_ON_CORR_ERR_EN	    |
+	       PCIE_CAP_SYS_ERR_ON_NON_FATAL_ERR_EN |
+	       PCIE_CAP_SYS_ERR_ON_FATAL_ERR_EN	    |
+	       PCIE_CAP_PME_INT_EN;
+	dw_pcie_writel_dbi(pcie, PCIE_ROOT_CONTROL_ROOT_CAPABILITIES_REG, reg);
+
+	if (linkup) {
+		dev_info(dev, "link is already up\n");
+	} else {
+		/* Use Gen1 mode for link establishing */
+		reg = dw_pcie_readl_dbi(pcie,
+					PCIE_LINK_CONTROL2_LINK_STATUS2_REG);
+		reg &= ~PCIE_CAP_TARGET_LINK_SPEED_MASK;
+		reg |= 1;
+		dw_pcie_writel_dbi(pcie,
+				   PCIE_LINK_CONTROL2_LINK_STATUS2_REG, reg);
+
+		/*
+		 * Clear DIRECT_SPEED_CHANGE bit. It has been set by
+		 * dw_pcie_setup_rc(pp). This bit causes link retraining. But
+		 * link retraining should be performed later by calling the
+		 * baikal_pcie_link_speed_fixup().
+		 */
+		reg = dw_pcie_readl_dbi(pcie, PCIE_GEN2_CTRL_REG);
+		reg &= ~PCIE_DIRECT_SPEED_CHANGE;
+		dw_pcie_writel_dbi(pcie, PCIE_GEN2_CTRL_REG, reg);
+
+		/* Establish link */
+		reg = baikal_pcie_lcru_readl(rc->lcru,
+					  BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr));
+
+		reg |= BAIKAL_PCIE_LTSSM_ENABLE;
+		baikal_pcie_lcru_writel(rc->lcru,
+					BAIKAL_LCRU_PCIE_GEN_CTL(rc->bus_nr),
+					reg);
+
+		dw_pcie_wait_for_link(pcie);
+	}
+
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		dw_pcie_msi_init(pp);
+	}
+
+	return 0;
+}
+
+static const struct dw_pcie_host_ops baikal_pcie_host_ops = {
+	.host_init = baikal_pcie_host_init
+};
+
+static void baikal_pcie_link_print_status(struct baikal_pcie_rc *rc)
+{
+	struct dw_pcie *pcie = rc->pcie;
+	struct device *dev = pcie->dev;
+	u32 reg;
+	unsigned speed, width;
+
+	reg = dw_pcie_readl_dbi(pcie, PCIE_LINK_CONTROL_LINK_STATUS_REG);
+	speed = (reg & PCIE_CAP_LINK_SPEED_MASK) >> PCIE_CAP_LINK_SPEED_SHIFT;
+	width = (reg & PCIE_CAP_NEGO_LINK_WIDTH_MASK) >>
+		PCIE_CAP_NEGO_LINK_WIDTH_SHIFT;
+
+	dev_info(dev, "link status is Gen%u%s, x%u\n", speed,
+		 reg & PCIE_CAP_LINK_TRAINING ? " (training)" : "", width);
+}
+
+static unsigned baikal_pcie_link_is_training(struct baikal_pcie_rc *rc)
+{
+	struct dw_pcie *pcie = rc->pcie;
+	return dw_pcie_readl_dbi(pcie, PCIE_LINK_CONTROL_LINK_STATUS_REG) &
+	       PCIE_CAP_LINK_TRAINING;
+}
+
+static bool baikal_pcie_link_wait_training_done(struct baikal_pcie_rc *rc)
+{
+	struct dw_pcie *pcie = rc->pcie;
+	struct device *dev = pcie->dev;
+	unsigned long start_jiffies = jiffies;
+
+	while (baikal_pcie_link_is_training(rc)) {
+		if (time_after(jiffies, start_jiffies + HZ)) {
+			dev_err(dev, "link training timeout occured\n");
+			return false;
+		}
+		udelay(100);
+	}
+	return true;
+}
+
+static void baikal_pcie_link_retrain(struct baikal_pcie_rc *rc,
+				     int target_speed)
+{
+	struct dw_pcie *pcie = rc->pcie;
+	struct device *dev = pcie->dev;
+	u32 reg;
+	unsigned long start_jiffies;
+
+	dev_info(dev, "retrain link to Gen%u\n", target_speed);
+
+	/* In case link is already training wait for training to complete */
+	baikal_pcie_link_wait_training_done(rc);
+
+	/* Set desired speed */
+	reg = dw_pcie_readl_dbi(pcie, PCIE_LINK_CONTROL2_LINK_STATUS2_REG);
+	reg &= ~PCIE_CAP_TARGET_LINK_SPEED_MASK;
+	reg |= target_speed;
+	dw_pcie_writel_dbi(pcie, PCIE_LINK_CONTROL2_LINK_STATUS2_REG, reg);
+
+	/* Deassert and assert DIRECT_SPEED_CHANGE bit */
+	reg = dw_pcie_readl_dbi(pcie, PCIE_GEN2_CTRL_REG);
+	reg &= ~PCIE_DIRECT_SPEED_CHANGE;
+	dw_pcie_writel_dbi(pcie, PCIE_GEN2_CTRL_REG, reg);
+	reg |= PCIE_DIRECT_SPEED_CHANGE;
+	dw_pcie_writel_dbi(pcie, PCIE_GEN2_CTRL_REG, reg);
+
+	/* Wait for link training begin */
+	start_jiffies = jiffies;
+	while (!baikal_pcie_link_is_training(rc)) {
+		if (time_after(jiffies, start_jiffies + HZ)) {
+			dev_err(dev, "link training has not started\n");
+			/* Don't wait for training_done() if it hasn't started */
+			return;
+		}
+		udelay(100);
+	}
+
+	/* Wait for link training end */
+	if (!baikal_pcie_link_wait_training_done(rc)) {
+		return;
+	}
+
+	if (!dw_pcie_wait_for_link(pcie)) {
+		/* Wait if link has switched to configuration/recovery state */
+		baikal_pcie_link_wait_training_done(rc);
+		baikal_pcie_link_print_status(rc);
+	}
+}
+
+static void baikal_pcie_link_speed_fixup(struct pci_dev *pdev)
+{
+	struct pcie_port *pp = pdev->bus->sysdata;
+	struct dw_pcie *pcie = to_dw_pcie_from_pp(pp);
+	struct baikal_pcie_rc *rc = to_baikal_pcie_rc(pcie);
+	unsigned dev_lnkcap_speed;
+	unsigned dev_lnkcap_width;
+	unsigned rc_lnkcap_speed;
+	unsigned rc_lnksta_speed;
+	unsigned rc_target_speed;
+	u32 reg;
+
+	/* Skip Root Bridge */
+	if (!pdev->bus->self) {
+		return;
+	}
+
+	/* Skip any devices not directly connected to the RC */
+	if (pdev->bus->self->bus->number != pp->root_bus_nr) {
+		return;
+	}
+
+	/* Skip if the bus has already been retrained */
+	if (rc->retrained) {
+		return;
+	}
+
+	reg = dw_pcie_readl_dbi(pcie, PCIE_LINK_CAPABILITIES_REG);
+	rc_lnkcap_speed = reg & PCI_EXP_LNKCAP_SLS;
+
+	reg = dw_pcie_readl_dbi(pcie, PCIE_LINK_CONTROL_LINK_STATUS_REG);
+	rc_lnksta_speed = (reg & PCIE_CAP_LINK_SPEED_MASK) >>
+			  PCIE_CAP_LINK_SPEED_SHIFT;
+
+	pcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &reg);
+	dev_lnkcap_speed = (reg & PCI_EXP_LNKCAP_SLS);
+	dev_lnkcap_width = (reg & PCI_EXP_LNKCAP_MLW) >>
+			   PCI_EXP_LNKSTA_NLW_SHIFT;
+
+	baikal_pcie_link_print_status(rc);
+	dev_info(&pdev->dev, "device link capability is Gen%u, x%u\n",
+		 dev_lnkcap_speed, dev_lnkcap_width);
+
+	/*
+	 * Gen1->Gen3 is suitable way of retraining.
+	 * Gen1->Gen2 is used when Gen3 could not be reached.
+	 * Gen2->Gen3 causes system freezing sometimes.
+	 */
+	if (rc_lnkcap_speed < dev_lnkcap_speed) {
+		rc_target_speed = rc_lnkcap_speed;
+	} else {
+		rc_target_speed = dev_lnkcap_speed;
+	}
+
+	while (rc_lnksta_speed < rc_target_speed) {
+		/* Try to change link speed */
+		baikal_pcie_link_retrain(rc, rc_target_speed);
+		reg = dw_pcie_readl_dbi(pcie,
+					PCIE_LINK_CONTROL_LINK_STATUS_REG);
+		rc_lnksta_speed = (reg & PCIE_CAP_LINK_SPEED_MASK) >>
+				  PCIE_CAP_LINK_SPEED_SHIFT;
+		/* Check if the targeted speed has not been reached */
+		if (rc_lnksta_speed < rc_target_speed && rc_target_speed > 1) {
+			/* Try to use lower speed */
+			--rc_target_speed;
+		}
+	}
+
+	rc->retrained = true;
+}
+
+static void baikal_pcie_link_retrain_bus(const struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		baikal_pcie_link_speed_fixup(dev);
+	}
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (dev->subordinate) {
+			baikal_pcie_link_retrain_bus(dev->subordinate);
+		}
+	}
+}
+
+static irqreturn_t baikal_pcie_err_irq_handler(int irq, void *priv)
+{
+	struct baikal_pcie_rc *rc = priv;
+	struct dw_pcie *pcie = rc->pcie;
+	struct device *dev = pcie->dev;
+	u32 corr_err_status;
+	u32 dev_ctrl_dev_status;
+	u32 root_err_status;
+	u32 uncorr_err_status;
+
+	uncorr_err_status   = dw_pcie_readl_dbi(pcie,
+					 PCIE_UNCORR_ERR_STATUS_REG);
+	corr_err_status	    = dw_pcie_readl_dbi(pcie,
+					 PCIE_CORR_ERR_STATUS_REG);
+	root_err_status     = dw_pcie_readl_dbi(pcie,
+					 PCIE_ROOT_ERR_STATUS_REG);
+	dev_ctrl_dev_status = dw_pcie_readl_dbi(pcie,
+					 PCIE_DEVICE_CONTROL_DEVICE_STATUS_REG);
+	dev_err(dev,
+		"dev_err:0x%x root_err:0x%x uncorr_err:0x%x corr_err:0x%x\n",
+		(dev_ctrl_dev_status & 0xf0000) >> 16,
+		root_err_status, uncorr_err_status, corr_err_status);
+
+	dw_pcie_writel_dbi(pcie,
+		    PCIE_UNCORR_ERR_STATUS_REG, uncorr_err_status);
+	dw_pcie_writel_dbi(pcie,
+		    PCIE_CORR_ERR_STATUS_REG, corr_err_status);
+	dw_pcie_writel_dbi(pcie,
+		    PCIE_ROOT_ERR_STATUS_REG, root_err_status);
+	dw_pcie_writel_dbi(pcie,
+		    PCIE_DEVICE_CONTROL_DEVICE_STATUS_REG, dev_ctrl_dev_status);
+
+	return IRQ_HANDLED;
+}
+
+static int baikal_pcie_add_pcie_port(struct baikal_pcie_rc *rc,
+				     struct platform_device *pdev)
+{
+	struct dw_pcie *pcie = rc->pcie;
+	struct pcie_port *pp = &pcie->pp;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	pp->irq = platform_get_irq(pdev, 0);
+	if (pp->irq < 0) {
+		return pp->irq;
+	}
+
+	ret = devm_request_irq(dev, pp->irq, baikal_pcie_err_irq_handler,
+			       IRQF_SHARED, "baikal-pcie-error-irq", pcie);
+
+	if (ret) {
+		dev_err(dev, "failed to request irq %d\n", pp->irq);
+		return ret;
+	}
+
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		pp->msi_irq = platform_get_irq(pdev, 1);
+		if (pp->msi_irq < 0) {
+			return pp->msi_irq;
+		}
+	}
+
+	pp->ops = &baikal_pcie_host_ops;
+	pp->root_bus_nr = -1;
+
+	ret = dw_pcie_host_init(pp);
+	if (ret) {
+		dev_err(dev, "Failed to initialize host\n");
+		return ret;
+	}
+
+	baikal_pcie_link_retrain_bus(pp->root_bus);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int baikal_pcie_pm_resume(struct device *dev)
+{
+	struct baikal_pcie_rc *rc = dev_get_drvdata(dev);
+	struct dw_pcie *pcie = rc->pcie;
+	u32 reg;
+
+	/* Set Memory Space Enable (MSE) bit */
+	reg = dw_pcie_readl_dbi(pcie, PCI_COMMAND);
+	reg |= PCI_COMMAND_MEMORY;
+	dw_pcie_writel_dbi(pcie, PCI_COMMAND, reg);
+	return 0;
+}
+
+static int baikal_pcie_pm_resume_noirq(struct device *dev)
+{
+	return 0;
+}
+
+static int baikal_pcie_pm_suspend(struct device *dev)
+{
+	struct baikal_pcie_rc *rc = dev_get_drvdata(dev);
+	struct dw_pcie *pcie = rc->pcie;
+	u32 reg;
+
+	/* Clear Memory Space Enable (MSE) bit */
+	reg = dw_pcie_readl_dbi(pcie, PCI_COMMAND);
+	reg &= ~PCI_COMMAND_MEMORY;
+	dw_pcie_writel_dbi(pcie, PCI_COMMAND, reg);
+	return 0;
+}
+
+static int baikal_pcie_pm_suspend_noirq(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops baikal_pcie_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(baikal_pcie_pm_suspend,
+				baikal_pcie_pm_resume)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(baikal_pcie_pm_suspend_noirq,
+				      baikal_pcie_pm_resume_noirq)
+};
+
+static const struct of_device_id of_baikal_pcie_match[] = {
+	{ .compatible = "baikal,pcie-m" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_baikal_pcie_match);
+
+static const struct dw_pcie_ops baikal_pcie_ops = {
+	.link_up = baikal_pcie_link_up
+};
+
+static int baikal_pcie_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct baikal_pcie_rc *rc;
+	struct dw_pcie *pcie;
+	int ret;
+	u32 idx[2];
+	enum of_gpio_flags gpio_flags;
+	int reset_gpio;
+	struct resource *res;
+
+	if (!of_match_device(of_baikal_pcie_match, dev)) {
+		dev_err(dev, "device can't be handled by pcie-baikal\n");
+		return -EINVAL;
+	}
+
+	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie) {
+		return -ENOMEM;
+	}
+
+	pcie->dev = dev;
+	pcie->ops = &baikal_pcie_ops;
+
+	rc = devm_kzalloc(dev, sizeof(*rc), GFP_KERNEL);
+	if (!rc) {
+		return -ENOMEM;
+	}
+
+	rc->pcie = pcie;
+	rc->lcru = syscon_regmap_lookup_by_phandle(dev->of_node,
+						   "baikal,pcie-lcru");
+	if (IS_ERR(rc->lcru)) {
+		dev_err(dev, "No LCRU phandle specified\n");
+		rc->lcru = NULL;
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(dev->of_node, "baikal,pcie-lcru", idx, 2)) {
+		dev_err(dev, "failed to read LCRU\n");
+		rc->lcru = NULL;
+		return -EINVAL;
+	}
+
+	if (idx[1] > 2) {
+		dev_err(dev, "incorrect pcie-lcru index\n");
+		rc->lcru = NULL;
+		return -EINVAL;
+	}
+
+	rc->bus_nr = idx[1];
+	reset_gpio = of_get_named_gpio_flags(dev->of_node, "reset-gpios", 0,
+					     &gpio_flags);
+	if (gpio_is_valid(reset_gpio)) {
+		rc->reset_gpio = gpio_to_desc(reset_gpio);
+		rc->reset_active_low = !!(gpio_flags & OF_GPIO_ACTIVE_LOW);
+		snprintf(rc->reset_name, sizeof(rc->reset_name), "pcie%u-reset",
+			 rc->bus_nr);
+	} else {
+		rc->reset_gpio = NULL;
+	}
+
+	pm_runtime_enable(dev);
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0) {
+		dev_err(dev, "pm_runtime_get_sync failed\n");
+		goto err_pm_disable;
+	}
+
+	platform_set_drvdata(pdev, rc);
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dbi");
+	if (res) {
+		devm_request_resource(dev, &iomem_resource, res);
+		pcie->dbi_base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(pcie->dbi_base)) {
+			dev_err(dev, "error with ioremap\n");
+			ret = PTR_ERR(pcie->dbi_base);
+			goto err_pm_put;
+		}
+	} else {
+		dev_err(dev, "missing *dbi* reg space\n");
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	ret = baikal_pcie_add_pcie_port(rc, pdev);
+	if (ret < 0) {
+		goto err_pm_put;
+	}
+
+	return 0;
+
+err_pm_put:
+	pm_runtime_put(dev);
+err_pm_disable:
+	pm_runtime_disable(dev);
+	return ret;
+}
+
+static struct platform_driver baikal_pcie_driver = {
+	.driver = {
+		.name = "baikal-pcie",
+		.of_match_table = of_baikal_pcie_match,
+		.suppress_bind_attrs = true,
+		.pm = &baikal_pcie_pm_ops
+	},
+	.probe = baikal_pcie_probe
+};
+
+module_platform_driver(baikal_pcie_driver);
+
+MODULE_DESCRIPTION("Baikal PCIe host controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 5bf754208..80e9d79be 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -218,6 +218,9 @@ config SPI_DESIGNWARE
 	help
 	  general driver for SPI controller core from DesignWare
 
+config SPI_DIGITALBLOCK_ESPI
+	tristate "DigitalBlock ESPI controller"
+
 config SPI_DW_PCI
 	tristate "PCI interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE && PCI
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index bb49c9e6d..f4f46ff01 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_SPI_DLN2)			+= spi-dln2.o
 obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
 obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
 obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
+obj-$(CONFIG_SPI_DIGITALBLOCK_ESPI)	+= spi-db-espi.o
 spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
 obj-$(CONFIG_SPI_EFM32)			+= spi-efm32.o
 obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
diff --git a/drivers/spi/spi-db-espi.c b/drivers/spi/spi-db-espi.c
new file mode 100644
index 000000000..7c724ee84
--- /dev/null
+++ b/drivers/spi/spi-db-espi.c
@@ -0,0 +1,431 @@
+/*
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/highmem.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/property.h>
+#include <linux/io.h>
+
+#include "spi-db-espi.h"
+
+
+static void espi_set_cs       (struct spi_device *spi, bool enable);
+static int  espi_setup        (struct spi_device *spi);
+
+static void espi_writer       (struct espi_data *priv);
+static void espi_reader       (struct espi_data *priv);
+static void espi_reset        (struct espi_data *priv);
+static void espi_enable_tx    (struct espi_data *priv);
+static void espi_enable_rx    (struct espi_data *priv);
+
+
+/* ---------------- */
+/* LOW-LEVEL        */
+/* ---------------- */
+static void espi_reset (struct espi_data *priv)
+{
+	/* NORESET */
+	espi_cr1_t cr1;
+	cr1.bits.scr = ESPI_CR1_SCR_NORESET;
+	espi_writel (priv, ESPI_CR1, cr1.val);
+
+	/* RESET */
+	cr1.bits.scr = ESPI_CR1_SCR_RESET;
+	espi_writel (priv, ESPI_CR1, cr1.val);
+}
+
+static void espi_enable_rx (struct espi_data *priv)
+{
+	espi_cr2_t cr2;
+	cr2.val = espi_readl(priv, ESPI_CR2);
+	cr2.bits.srd = ESPI_CR2_SRD_RX_ENABLE;
+	espi_writel(priv, ESPI_CR2, cr2.val);
+}
+
+static void espi_enable_tx (struct espi_data *priv)
+{
+	espi_cr2_t cr2;
+	int cnt = espi_readl(priv, ESPI_TX_FBCAR);
+	cr2.val = espi_readl(priv, ESPI_CR2);
+
+	if (cnt && cr2.bits.mte != ESPI_CR2_MTE_TX_ENABLE){
+		cr2.bits.mte = ESPI_CR2_MTE_TX_ENABLE;
+		espi_writel(priv, ESPI_CR2, cr2.val);
+	}
+}
+
+static void espi_set_cs (struct spi_device *spi, bool enable)
+{
+	struct espi_data *priv;
+	espi_cr2_t cr2;
+	int gpio;
+
+	priv = spi_master_get_devdata(spi->master);
+
+	/* cs-host */
+	cr2.val = espi_readl (priv, ESPI_CR2);
+	cr2.bits.sso = spi->chip_select;
+	espi_writel (priv, ESPI_CR2, cr2.val);
+
+	/* cs-gpio */
+	if (spi->chip_select < priv->cnt_gpios) {
+		gpio = priv->cs_gpios[spi->chip_select];
+		if (gpio_is_valid(gpio))
+			gpio_set_value(gpio, !enable);
+	}
+}
+
+
+static void espi_writer (struct espi_data *priv)
+{
+	volatile uint8_t data = ESPI_DUMMY_DATA;
+	uint32_t free = ESPI_FIFO_LEN - espi_readl(priv, ESPI_TX_FBCAR);
+	uint32_t cnt = min(free,priv->txlen);
+
+	priv->txlen -= cnt;
+
+	/* fifo */
+	while (cnt--) {
+		if (priv->tx)
+			data = *priv->tx++;
+		espi_writel(priv, ESPI_TX_FIFO, data);
+	}
+
+	/* mask irq */
+	if (priv->txlen == 0) {
+		espi_irq_t mask;
+		mask.val = espi_readl(priv, ESPI_IMR);
+		mask.bits.tx_almost_empty = ESPI_IRQ_DISABLE;
+		espi_writel(priv, ESPI_IMR, mask.val);
+	}
+
+	/* start */
+	espi_enable_tx (priv);
+}
+
+
+static void espi_reader (struct espi_data *priv)
+{
+	volatile uint8_t data;
+	uint32_t have = espi_readl(priv, ESPI_RX_FBCAR);
+	uint32_t cnt = min(have,priv->rxlen);
+
+	priv->rxlen -= cnt;
+
+	/* fifo */
+	while (cnt--) {
+		data = espi_readl(priv, ESPI_RX_FIFO);
+		if (priv->rx)
+			*priv->rx++ = data;
+	}
+}
+
+
+static irqreturn_t espi_irq_handler (int irq, void *dev_id)
+{
+	espi_irq_t status;
+	struct spi_master *master = dev_id;
+	struct espi_data  *priv   = spi_master_get_devdata(master);
+	int ret = -1;
+
+	/* get */
+	status.val = espi_readl(priv, ESPI_IVR);
+	espi_writel(priv, ESPI_ISR, status.val);
+
+	/* check */
+	if (!status.val) {
+		dev_err(&master->dev, "irq_none\n");
+		return IRQ_NONE;
+	}
+	if (status.bits.tx_underflow) {
+		dev_err(&master->dev, "tx_underflow\n");
+		goto exit;
+	}
+	if (status.bits.tx_overrun) {
+		dev_err(&master->dev, "tx_overrun\n");
+		goto exit;
+	}
+	if (status.bits.rx_underrun) {
+		dev_err(&master->dev, "rx_underrun\n");
+		goto exit;
+	}
+	if (status.bits.rx_overrun) {
+		dev_err(&master->dev, "rx_overrun\n");
+		goto exit;
+	}
+	/*
+	if (status.bits.tx_done_master && (priv->txlen || priv->rxlen)) {
+		dev_err(&master->dev, "tx_done_master && len != 0\n");
+		goto exit;
+	}
+	*/
+
+
+	/* transfer */
+	espi_reader(priv);
+	espi_writer(priv);
+	ret = 0;
+
+exit:
+	/* reset */
+	if (ret)
+		espi_reset(priv);
+
+	/* finalize */
+	if (ret || (priv->txlen == 0 && priv->rxlen == 0)) {
+		espi_writel(priv, ESPI_IMR, ESPI_IMR_DISABLE);
+		espi_writel(priv, ESPI_ISR, ESPI_ISR_CLEAR);
+
+		if (master->cur_msg) {
+			if(ret)
+				master->cur_msg->status = -EIO;
+			spi_finalize_current_transfer(master);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+
+static int espi_transfer_one(
+		struct spi_master   *master,
+		struct spi_device   *spi,
+		struct spi_transfer *transfer)
+{
+	struct espi_data *priv = spi_master_get_devdata(spi->master);
+
+	/* transfer */
+	priv->tx = (void*) transfer->tx_buf;
+	priv->rx = (void*) transfer->rx_buf;
+	priv->txlen = transfer->len;
+	priv->rxlen = transfer->len;
+
+	/* clear */
+	espi_writel(priv, ESPI_IMR, ESPI_IMR_DISABLE);
+	espi_writel(priv, ESPI_ISR, ESPI_ISR_CLEAR);
+
+	/* threshold */
+	espi_writel(priv, ESPI_TX_FAETR, ESPI_FIFO_LEN/2);
+	espi_writel(priv, ESPI_RX_FAFTR, ESPI_FIFO_LEN/8);
+
+	/* clk */
+	if (transfer->speed_hz && (transfer->speed_hz != spi->max_speed_hz))
+		clk_set_rate(priv->clk, transfer->speed_hz);
+
+	espi_enable_rx(priv);  /* enable rx */
+	espi_writer(priv);     /* prepare data */
+	espi_writel(priv, ESPI_IMR, ESPI_IMR_ENABLE);  /* mask */
+
+	return 0;
+}
+
+
+static int espi_setup (struct spi_device *spi)
+{
+	struct espi_data *priv = spi_master_get_devdata(spi->master);
+	espi_cr1_t cr1;
+	espi_cr2_t cr2;
+
+	/* reset */
+	espi_reset(priv);
+
+	/* control */
+	cr1.val = espi_readl(priv, ESPI_CR1);
+	cr1.bits.scr = ESPI_CR1_SCR_NORESET;
+	cr1.bits.sce = ESPI_CR1_SCE_CORE_ENABLE;
+	cr1.bits.mss = ESPI_CR1_MSS_MODE_MASTER;
+	cr1.bits.cph = (spi->mode|SPI_CPHA)? ESPI_CR1_CPH_CLKPHASE_ODD : ESPI_CR1_CPH_CLKPHASE_EVEN;
+	cr1.bits.cpo = (spi->mode|SPI_CPOL)? ESPI_CR1_CPO_CLKPOLAR_LOW : ESPI_CR1_CPO_CLKPOLAR_HIGH;
+	espi_writel(priv, ESPI_CR1, cr1.val);
+
+	cr2.val = espi_readl(priv, ESPI_CR2);
+	cr2.bits.srd = ESPI_CR2_SRD_RX_ENABLE;
+	cr2.bits.mte = ESPI_CR2_MTE_TX_DISABLE;
+	cr2.bits.sri = ESPI_CR2_SRI_FIRST_RESIEV;
+	cr2.bits.mlb = (spi->mode|SPI_LSB_FIRST)? ESPI_CR2_MLB_LSB : ESPI_CR2_MLB_MSB;
+	espi_writel(priv, ESPI_CR2, cr2.val);
+
+	return 0;
+}
+
+
+/* ---------------- */
+/* DRIVER           */
+/* ---------------- */
+static int espi_probe (struct platform_device *pdev)
+{
+	struct device *dev = &(pdev->dev);
+	struct espi_data *priv;
+	struct resource *mem;
+	int i;
+	int err;
+	struct spi_master *master;
+
+	/* ------ */
+	/* PRIV   */
+	/* ------ */
+
+	/* init */
+	priv = devm_kzalloc(dev, sizeof(struct espi_data), GFP_KERNEL);
+	if (!priv){
+		dev_err(dev, "no memory\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, priv);
+
+	/* reg */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem){
+		return -EINVAL;
+	}
+
+	priv->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "region map failed\n");
+		return PTR_ERR(priv->regs);
+	}
+
+	/* irq */
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0) {
+		dev_err(&pdev->dev, "no irq resource\n");
+		return priv->irq;
+	}
+
+	/* clk */
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "could not get spi clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	/* gpio */
+	priv->cnt_gpios = of_gpio_named_count(dev->of_node, "cs-gpios");
+	priv->cs_gpios = devm_kzalloc (dev, sizeof(int) * priv->cnt_gpios, GFP_KERNEL);
+
+	for (i = 0; i < priv->cnt_gpios; i++)
+		priv->cs_gpios[i] = -ENOENT;
+
+	for (i = 0; i < priv->cnt_gpios; i++) {
+		int gpio = of_get_named_gpio(dev->of_node, "cs-gpios", i);
+		if (gpio_is_valid(gpio) && !devm_gpio_request(dev, gpio, dev_name(dev))){
+			priv->cs_gpios[i] = gpio;
+			gpio_direction_output (gpio, 1);
+		}
+	}
+
+	/* ------ */
+	/* MASTER */
+	/* ------ */
+
+	/* alloc */
+	master = spi_alloc_master(dev, 0);
+	if (!master){
+		return -ENOMEM;
+	}
+	priv->master = master;
+
+	/* cs-num */
+	master->num_chipselect = 8;
+	device_property_read_u16(dev, "num-cs", &master->num_chipselect);
+	master->num_chipselect = max_t(int, master->num_chipselect, priv->cnt_gpios);
+
+	/* clk */
+	err = clk_prepare_enable(priv->clk);
+	if (err){
+		return err;
+	}
+	if (device_property_read_u32(dev, "spi-max-frequency", &master->max_speed_hz)){
+		dev_err(dev, "no valid 'spi-max-frequency' property\n");
+		master->max_speed_hz = clk_get_rate(priv->clk);
+	}
+
+	/* misk */
+	master->mode_bits = SPI_CPHA | SPI_CPOL;
+	master->dev.of_node = dev->of_node;
+
+	/* operation */
+	master->transfer_one = espi_transfer_one;
+	master->set_cs = espi_set_cs;
+	master->setup = espi_setup;
+	master->bus_num = of_alias_get_id(master->dev.of_node, "espi");
+
+	/* irq */
+	err = devm_request_irq(dev, priv->irq, espi_irq_handler, IRQF_SHARED, pdev->name, master);
+	if (err) {
+		dev_err(&pdev->dev, "unable to request irq %d\n", priv->irq);
+		return err;
+	}
+
+	/* data */
+	spi_master_set_devdata(master, priv);
+
+
+	/* register */
+	err = devm_spi_register_master(dev, master);
+	if (err) {
+		dev_err(&master->dev, "problem registering spi master\n");
+		goto err_free_master;
+	}
+	return 0;
+
+err_free_master:
+	spi_master_put(master);
+	return err;
+}
+
+
+static int espi_remove (struct platform_device *pdev)
+{
+	struct espi_data *priv = platform_get_drvdata(pdev);
+	espi_reset(priv);
+	clk_disable_unprepare(priv->clk);
+	return 0;
+}
+
+
+/* ---------------- */
+/* PLATFORM         */
+/* ---------------- */
+static const struct of_device_id espi_table[] = {
+	{ .compatible = "be,espi", },
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, espi_table);
+
+static struct platform_driver espi_driver = {
+	.probe		= espi_probe,
+	.remove		= espi_remove,
+	.driver		= {
+		.name	= "be,espi",
+		.of_match_table = espi_table,
+	},
+};
+module_platform_driver(espi_driver);
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("");
+MODULE_LICENSE("GPL v2");
+
+
+
diff --git a/drivers/spi/spi-db-espi.h b/drivers/spi/spi-db-espi.h
new file mode 100644
index 000000000..6b4fe0cfc
--- /dev/null
+++ b/drivers/spi/spi-db-espi.h
@@ -0,0 +1,170 @@
+#ifndef SPI_DB_ESPI_H
+#define SPI_DB_ESPI_H
+
+
+#define ESPI_FIFO_LEN	256
+#define ESPI_DUMMY_DATA	0xFF
+#define ESPI_FREQUENCY	25000000
+
+
+/* driver data */
+struct espi_data {
+	struct spi_master	*master;
+
+	/* hardware */
+	int			irq;
+	void __iomem		*regs;
+	struct clk		*clk;
+	int			*cs_gpios;
+	int			cnt_gpios;
+
+	/* transfer */
+	uint32_t		rxlen;
+	uint32_t		txlen;
+	uint8_t			*tx;
+	uint8_t			*rx;
+};
+
+
+/* ---------- */
+/* regs       */
+/* ---------- */
+
+#define ESPI_CR1	0x0	/* control 1 */
+#define ESPI_CR2	0x4	/* control 2 */
+#define ESPI_TX_FIFO	0xc 	/* fifo */
+#define ESPI_TX_FBCAR	0x14	/* byte count */
+#define ESPI_TX_FAETR	0x18	/* almost empty threshold */
+#define ESPI_RX_FIFO	0x1c	/* fifo */
+#define ESPI_RX_FBCAR	0x24	/* byte count */
+#define ESPI_RX_FAFTR	0x28	/* almost full threshold */
+#define ESPI_ISR	0x30	/* irq status */
+#define ESPI_IMR	0x34	/* irq mask */
+#define ESPI_IVR	0x38	/* irq vector */
+#define ESPI_CR3	0x54	/* espi control */
+#define ESPI_RBCR	0x58	/* espi response byte count */
+#define ESPI_CIR1	0xe0	/* id1 */
+#define ESPI_CIR2	0xe4	/* id2 */
+#define ESPI_DCR	0x40	/* dma control */
+#define ESPI_TDBAR	0x44	/* dma transmit base address */
+#define ESPI_TDCAR	0x48	/* dma transmit current address */
+#define ESPI_RDBAR	0x4c	/* dma receive base address */
+#define ESPI_RDCAR	0x50	/* dma receive current address */
+
+
+typedef union {
+	uint32_t val;
+	struct {
+		//low
+		uint32_t scr :1;	/* reset */
+		uint32_t sce :1;	/* enable */
+		uint32_t mss :1;	/* select - master/slave */
+		uint32_t cph :1;	/* clock phase */
+		uint32_t cpo :1;	/* clock polarity */
+		//hi
+	} bits;
+} espi_cr1_t;
+#define ESPI_CR1_SCR_RESET          0
+#define ESPI_CR1_SCR_NORESET        1
+#define ESPI_CR1_SCE_CORE_DISABLE   0
+#define ESPI_CR1_SCE_CORE_ENABLE    1
+#define ESPI_CR1_MSS_MODE_MASTER    0
+#define ESPI_CR1_MSS_MODE_SLAVE     1
+#define ESPI_CR1_CPH_CLKPHASE_ODD   0
+#define ESPI_CR1_CPH_CLKPHASE_EVEN  1
+#define ESPI_CR1_CPO_CLKPOLAR_LOW   0
+#define ESPI_CR1_CPO_CLKPOLAR_HIGH  1
+
+typedef union {
+	uint32_t val;
+	struct {
+		//low
+		uint32_t  sso :3;	/* slave select (ss0-ss7) */
+		uint32_t  srd :1;	/* read disable */
+		uint32_t  sri :1;	/* read first byte ignore */
+		uint32_t  mlb :1;	/* least sign git first */
+		uint32_t  mte :1;	/* master transfer enable */
+		//hi
+	} bits;
+} espi_cr2_t;
+
+#define ESPI_CR2_SRD_RX_DISABLE 0
+#define ESPI_CR2_SRD_RX_ENABLE 1
+#define ESPI_CR2_SRI_FIRST_RESIEV 0
+#define ESPI_CR2_SRI_FIRST_IGNORE 1
+#define ESPI_CR2_MLB_MSB 0
+#define ESPI_CR2_MLB_LSB 1
+#define ESPI_CR2_MTE_TX_DISABLE 0
+#define ESPI_CR2_MTE_TX_ENABLE 1   /* self clear !! */
+
+/* struct espi_tx_fifo_t  {} */
+/* struct espi_rx_fifo_t  {} */
+/* struct espi_tx_fbcar_t {} */
+/* struct espi_rx_fbcar_t {} */
+/* struct espi_tx_faetr_t {} */
+/* struct espi_rx_faftr_t {} */
+
+#define  ESPI_RX_FAFTR_DISABLE 0xFF
+#define  ESPI_TX_FAETR_DISABLE 0x0
+#define  ESPI_ISR_CLEAR        0xFF   /* clear by writing "1" */
+#define  ESPI_IMR_DISABLE      0x0
+#define  ESPI_IMR_ENABLE       0xFF
+
+/* isr, imr, ivr */
+typedef union {
+	uint32_t val;
+	struct {
+		//lo
+		uint32_t tx_underflow        :1;
+		uint32_t tx_overrun          :1;
+		uint32_t rx_underrun         :1;
+		uint32_t rx_overrun          :1;
+		uint32_t tx_almost_empty     :1;
+		uint32_t rx_almost_full      :1;
+		uint32_t tx_done_master      :1;
+		uint32_t tx_done_slave       :1;
+		uint32_t alert               :8;
+		uint32_t rx_crc_error        :1;
+		//hi
+	} bits;
+} espi_irq_t;
+#define ESPI_IRQ_DISABLE 0
+#define ESPI_IRQ_ENABLE  1
+
+/* struct espi_dcr_t   {} */
+/* struct espi_tdbar_t {} */
+/* struct espi_tdcar_t {} */
+/* struct espi_rdbar_t {} */
+/* struct espi_rdcar_t {} */
+
+typedef union {
+	uint32_t val;
+	struct {
+		//low
+		uint32_t  ese :1;	/* enable */
+		uint32_t  rms :1;	/* reset# direction */
+		uint32_t  raa :1;	/* reset# assertion active */
+		uint32_t  cre :1;	/* crc receive enable */
+		uint32_t  crf :1;	/* crc receive byte placed in fifo */
+		uint32_t  wsr :1;	/* wait state response */
+		uint32_t  sdl :2;	/* spi data lines (single, dual, quad) */
+		//hi
+	} bits;
+} espi_cr3_t;
+
+/* struct espi_rbcr_t {} */
+/* struct espi_cir1_t {} */
+/* struct espi_cir2_t {} */
+
+
+static inline uint32_t espi_readl(struct espi_data *priv, uint32_t offset)
+{
+	return __raw_readl(priv->regs + offset);
+}
+static inline void espi_writel(struct espi_data *priv, uint32_t offset, uint32_t val)
+{
+	__raw_writel(val, priv->regs + offset);
+}
+
+
+#endif /* SPI_DB_ESPI_H */
\ No newline at end of file
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 51a7d3b19..28c6f876a 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -296,11 +296,11 @@ static void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
 	if (!ret)
 		p->uartclk = rate;
 
-out:
 	p->status &= ~UPSTAT_AUTOCTS;
 	if (termios->c_cflag & CRTSCTS)
 		p->status |= UPSTAT_AUTOCTS;
 
+out:
 	serial8250_do_set_termios(p, termios, old);
 }
 
@@ -373,9 +373,13 @@ static void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)
 		data->uart_16550_compatible = true;
 	}
 
+	if (has_acpi_companion(p->dev))
+		p->set_termios = dw8250_set_termios;
+
 	/* Platforms with iDMA 64-bit */
 	if (platform_get_resource_byname(to_platform_device(p->dev),
 					 IORESOURCE_MEM, "lpss_priv")) {
+		p->set_termios = dw8250_set_termios;
 		data->data.dma.rx_param = p->dev->parent;
 		data->data.dma.tx_param = p->dev->parent;
 		data->data.dma.fn = dw8250_idma_filter;
@@ -414,7 +418,6 @@ static int dw8250_probe(struct platform_device *pdev)
 	p->serial_in	= dw8250_serial_in;
 	p->serial_out	= dw8250_serial_out;
 	p->set_ldisc	= dw8250_set_ldisc;
-	p->set_termios	= dw8250_set_termios;
 
 	p->membase = devm_ioremap(dev, regs->start, resource_size(regs));
 	if (!p->membase)
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index 556a876c7..c7b783f33 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -138,4 +138,13 @@ config USB_DWC3_QCOM
 	  for peripheral mode support.
 	  Say 'Y' or 'M' if you have one such device.
 
+config USB_DWC3_BAIKAL
+	tristate "Baikal Electronics Platforms"
+	depends on OF
+	default USB_DWC3
+	help
+	  Baikal Electronics SoCs with one DesignWare Core USB3 IP
+	  inside.
+	  Say 'Y' or 'M' if you have one such device.
+
 endif
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index ae86da0dc..0dcaf92a4 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -51,3 +51,4 @@ obj-$(CONFIG_USB_DWC3_MESON_G12A)	+= dwc3-meson-g12a.o
 obj-$(CONFIG_USB_DWC3_OF_SIMPLE)	+= dwc3-of-simple.o
 obj-$(CONFIG_USB_DWC3_ST)		+= dwc3-st.o
 obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
+obj-$(CONFIG_USB_DWC3_BAIKAL)		+= dwc3-baikal.o
diff --git a/drivers/usb/dwc3/dwc3-baikal.c b/drivers/usb/dwc3/dwc3-baikal.c
new file mode 100644
index 000000000..2426dc49b
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-baikal.c
@@ -0,0 +1,126 @@
+/**
+ * dwc3-baikal.c - Baikal Electronics SoCs Specific Glue layer
+ *
+ * Copyright (C) 2015 Baikal Electronics JSC - http://www.baikalelectronics.ru
+ *
+ * Author: Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2  of
+ * the License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/usb_phy_generic.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+
+struct dwc3_baikal {
+	struct device	*dev;
+	struct clk	*clk;
+};
+
+static int be_dwc3_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*node = pdev->dev.of_node;
+	struct dwc3_baikal	*dwc;
+	int			ret;
+
+	dwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);
+	if (!dwc)
+		return -ENOMEM;
+
+	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));
+	if (ret) {
+		dev_err(dev, "DMA mask error %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, dwc);
+	dwc->dev = dev;
+
+	dwc->clk = devm_clk_get(dwc->dev, "usb");
+	if (IS_ERR(dwc->clk)) {
+		dev_err(dev, "no interface clk specified\n");
+		return -EINVAL;
+	}
+
+	ret = clk_prepare_enable(dwc->clk);
+	if (ret < 0) {
+		dev_err(dwc->dev, "unable to enable usb clock\n");
+		return ret;
+	}
+
+	if (node) {
+			ret = of_platform_populate(node, NULL, NULL, dev);
+			if (ret) {
+				dev_err(&pdev->dev, "failed to create dwc3 core\n");
+				goto __error;
+			}
+	} else {
+		dev_err(dev, "no device node, failed to add dwc3 core\n");
+		ret = -ENODEV;
+		goto __error;
+	}
+
+	return 0;
+
+__error:
+	clk_disable_unprepare(dwc->clk);
+
+	return ret;
+}
+
+static int be_dwc3_remove_core(struct device *dev, void *c)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+static int be_dwc3_remove(struct platform_device *pdev)
+{
+	struct dwc3_baikal *dwc = platform_get_drvdata(pdev);
+
+	device_for_each_child(&pdev->dev, NULL, be_dwc3_remove_core);
+	clk_disable_unprepare(dwc->clk);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id be_dwc3_of_match[] = {
+	{ .compatible = "be,baikal-dwc3", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, be_dwc3_of_match);
+
+static struct platform_driver be_dwc3_driver = {
+	.probe		= be_dwc3_probe,
+	.remove		= be_dwc3_remove,
+	.driver		= {
+		.name	= "baikal-dwc3",
+		.of_match_table	= be_dwc3_of_match,
+	},
+};
+
+module_platform_driver(be_dwc3_driver);
+
+MODULE_ALIAS("platform:baikal-dwc3");
+MODULE_AUTHOR("Dmitry Dunaev <dmitry.dunaev@baikalelectronics.ru>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DesignWare USB3 Baikal SoCs Glue Layer");
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 427a993c7..c844d5135 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -19,6 +19,8 @@ source "drivers/gpu/ipu-v3/Kconfig"
 
 source "drivers/gpu/drm/Kconfig"
 
+source "drivers/gpu/arm/Kconfig"
+
 menu "Frame buffer Devices"
 source "drivers/video/fbdev/Kconfig"
 endmenu
diff --git a/include/linux/marvell_phy.h b/include/linux/marvell_phy.h
index 1847a0784..1c3a53eb6 100644
--- a/include/linux/marvell_phy.h
+++ b/include/linux/marvell_phy.h
@@ -22,6 +22,8 @@
 #define MARVELL_PHY_ID_88E3016		0x01410e60
 #define MARVELL_PHY_ID_88X3310		0x002b09a0
 #define MARVELL_PHY_ID_88E2110		0x002b09b0
+#define MARVELL_PHY_ID_88X2222          0x01410f10
+#define MARVELL_PHY_ID_88X2222R         0x014131b0
 
 /* These Ethernet switch families contain embedded PHYs, but they do
  * not have a model ID. So the switch driver traps reads to the ID2
diff --git a/include/linux/mfd/baikal/lcru-pcie.h b/include/linux/mfd/baikal/lcru-pcie.h
new file mode 100644
index 000000000..40562d00a
--- /dev/null
+++ b/include/linux/mfd/baikal/lcru-pcie.h
@@ -0,0 +1,140 @@
+/*
+ * Baikal SoC series Local Clock and Reset Unit (LCRU) register offsets
+ * and bit definitions.
+ *
+ * Copyright (C) 2019 Baikal Electronics JSC.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_
+#define _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_
+
+#include <linux/regmap.h>
+
+//#define BAIKAL_CMU_PCIE_STEP	0x30
+
+//#define BAIKAL_CMU_PCIE_MSTRCLK	0x20
+//#define BAIKAL_CMU_PCIE_SLVCLK	0x30
+//#define BAIKAL_CMU_PCIE_CFGCLK	0x40
+
+#define BAIKAL_LCRU_PCIE_RESET_BASE		0x50000		/* GPR0_RW */
+#define BAIKAL_LCRU_PCIE_RESET(x)		((x * 0x20) + BAIKAL_LCRU_PCIE_RESET_BASE)
+#define BAIKAL_PCIE_ADB_PWRDWN			(1 << 13)
+#define BAIKAL_PCIE_HOT_RESET			(1 << 12)
+#define BAIKAL_PCIE_NONSTICKY_RST		(1 << 11)
+#define BAIKAL_PCIE_STICKY_RST			(1 << 10)
+#define BAIKAL_PCIE_PWR_RST				(1 << 9)
+#define BAIKAL_PCIE_CORE_RST			(1 << 8)
+#define BAIKAL_PCIE_PIPE1_RESET			(1 << 5) /* x8 controller only */
+#define BAIKAL_PCIE_PIPE0_RESET			(1 << 4) /* x8 controller only */
+#define BAIKAL_PCIE_PIPE_RESET			(1 << 4) /* x4 controllers only */
+#define BAIKAL_PCIE_PHY_RESET			(1 << 0)
+
+#define BAIKAL_LCRU_PCIE_STATUS_BASE	0x50004		/* GPR0_RO */
+#define BAIKAL_LCRU_PCIE_STATUS(x)		((x * 0x20) + BAIKAL_LCRU_PCIE_STATUS_BASE)
+#define BAIKAL_PCIE_TURNOFF_ACK			(1 << 31)
+#define BAIKAL_PCIE_ADB_PWRACK			(1 << 30)
+#define BAIKAL_PCIE_WAKE_DET			(1 << 24)
+#define BAIKAL_PCIE_AUX_PM_EN			(1 << 22)
+#define BAIKAL_PCIE_PM_PME_STATUS		(1 << 21)
+#define BAIKAL_PCIE_PM_PME_EN			(1 << 20)
+#define BAIKAL_PCIE_PM_DSTATE_SHIFT		16
+#define BAIKAL_PCIE_PM_DSTATE_MASK		0x7
+#define BAIKAL_PCIE_PM_DSTATE_D0		0
+#define BAIKAL_PCIE_PM_DSTATE_D1		1
+#define BAIKAL_PCIE_PM_DSTATE_D2		2
+#define BAIKAL_PCIE_PM_DSTATE_D3		3
+#define BAIKAL_PCIE_PM_DSTATE_UNINIT	4
+#define BAIKAL_PCIE_LTSSM_RCVRY_EQ		(1 << 15)
+#define BAIKAL_PCIE_PIPE_CLK_REQ		(1 << 14)
+#define BAIKAL_PCIE_SMLH_REQ_RST		(1 << 13)
+#define BAIKAL_PCIE_LINK_REQ_RST		(1 << 12)
+#define BAIKAL_PCIE_PM_LINKSTATE_L2		(1 << 10)
+#define BAIKAL_PCIE_PM_LINKSTATE_L1		(1 << 9)
+#define BAIKAL_PCIE_PM_LINKSTATE_L0S	(1 << 8)
+#define BAIKAL_PCIE_RDLH_LINKUP			(1 << 7)
+#define BAIKAL_PCIE_SMLH_LINKUP			(1 << 6)
+#define BAIKAL_PCIE_LTSSM_STATE_SHIFT					0
+#define BAIKAL_PCIE_LTSSM_STATE_MASK					0x3F
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_QUIET			0x00
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_ACT				0x01
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_ACTIVE			0x02
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_COMPLIANCE		0x03
+#define BAIKAL_PCIE_LTSSM_STATE_POLLING_CONFIG			0x04
+#define BAIKAL_PCIE_LTSSM_STATE_PRE_DETECT_QUIET		0x05
+#define BAIKAL_PCIE_LTSSM_STATE_DETECT_WAIT				0x06
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LINK_WD_START		0x07
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LINK_WD_ACCEPT		0x08
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LANE_NUM_WAIT		0x09
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_LANE_NUM_ACCEPT		0x0A
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_COMPLETE			0x0B
+#define BAIKAL_PCIE_LTSSM_STATE_CFG_IDLE				0x0C
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_LOCK				0x0D
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_SPEED				0x0E
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_RCVR_CFG			0x0F
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_IDLE				0x10
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ0				0x20
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ1				0x21
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ2				0x22
+#define BAIKAL_PCIE_LTSSM_STATE_RCVRY_EQ3				0x23
+#define BAIKAL_PCIE_LTSSM_STATE_L0						0x11
+#define BAIKAL_PCIE_LTSSM_STATE_L0S						0x12
+#define BAIKAL_PCIE_LTSSM_STATE_L123_SEND_IDLE			0x13
+#define BAIKAL_PCIE_LTSSM_STATE_L1_IDLE					0x14
+#define BAIKAL_PCIE_LTSSM_STATE_L2_IDLE					0x15
+#define BAIKAL_PCIE_LTSSM_STATE_L2_WAKE					0x16
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED_ENTRY			0x17
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED_IDLE			0x18
+#define BAIKAL_PCIE_LTSSM_STATE_DISABLED				0x19
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_ENTRY			0x1A
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_ACTIVE			0x1B
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_EXIT			0x1C
+#define BAIKAL_PCIE_LTSSM_STATE_LOOPBACK_EXIT_TIMEOUT	0x1D
+#define BAIKAL_PCIE_LTSSM_STATE_HOT_RESET_ENTRY			0x1E
+#define BAIKAL_PCIE_LTSSM_STATE_HOT_RESET				0x1F
+
+#define BAIKAL_LCRU_PCIE_GEN_CTL_BASE		0x50008		/* GPR1_RW*/
+#define BAIKAL_LCRU_PCIE_GEN_CTL(x)			((x * 0x20) + BAIKAL_LCRU_PCIE_GEN_CTL_BASE)
+#define BAIKAL_PCIE_AUX_PWR_DET				(1 << 24)
+#define BAIKAL_PCIE_TXLANE_FLIP_EN			(1 << 17)
+#define BAIKAL_PCIE_RXLANE_FLIP_EN			(1 << 16)
+#define BAIKAL_PCIE_PHY_MGMT_ENABLE			(1 << 3)
+#define BAIKAL_PCIE_DBI2_MODE				(1 << 2)
+#define BAIKAL_PCIE_LTSSM_ENABLE			(1 << 1)
+
+#define BAIKAL_LCRU_PCIE_POWER_CTL_BASE		0x50010		/* GPR2_RW */
+#define BAIKAL_LCRU_PCIE_POWER_CTL(x)		((x * 0x20) + BAIKAL_LCRU_POWER_CTL_BASE)
+#define BAIKAL_PCIE_PHY_CLK_REQ				(1 << 27)
+#define BAIKAL_PCIE_APP_CLK_REQ				(1 << 26)
+#define BAIKAL_PCIE_PERSTN					(1 << 25)
+#define BAIKAL_PCIE_TURNOFF_REQ				(1 << 24)
+#define BAIKAL_PCIE_REQ_EXIT_L1				(1 << 17)
+#define BAIKAL_PCIE_L1_PENDING				(1 << 16)
+#define BAIKAL_PCIE_MAC_CLK_REQ				(1 << 5)
+#define BAIKAL_PCIE_PCS_CLK_REQ				(1 << 4)
+
+#define BAIKAL_LCRU_PCIE_MSI_TRANS_CTL0		0x500E8
+#define BAIKAL_PCIE_MSI_AWUSER_SHIFT		0
+#define BAIKAL_PCIE_MSI_AWUSER_MASK			0xF
+
+#define BAIKAL_LCRU_PCIE_MSI_TRANS_CTL2		0x500F8
+#define BAIKAL_PCIE_MSI_TRANS_EN(x)			(1 << (9 + (x)))
+#define BAIKAL_PCIE_MSI_RCNUM(x)			((x) << (2 * (x)))
+#define BAIKAL_PCIE_MSI_RCNUM_MASK(x)		(0x3 << (2 * (x)))
+
+inline u32 baikal_pcie_lcru_readl(struct regmap *lcru, u32 offset)
+{
+    u32 val;
+    regmap_read(lcru, offset, &val);
+    return val;
+}
+
+inline void baikal_pcie_lcru_writel(struct regmap *lcru, u32 offset, u32 val)
+{
+    regmap_write(lcru, offset, val);
+}
+
+#endif /* _LINUX_MFD_SYSCON_BAIKAL_LCRU_H_ */
diff --git a/samples/Kconfig b/samples/Kconfig
index c8dacb4dd..77f400b5b 100644
--- a/samples/Kconfig
+++ b/samples/Kconfig
@@ -169,4 +169,11 @@ config SAMPLE_VFS
 	  as mount API and statx().  Note that this is restricted to the x86
 	  arch whilst it accesses system calls that aren't yet in all arches.
 
+config SAMPLE_BPF
+        bool "Build BPF sample code"
+        depends on HEADERS_INSTALL
+        help
+          Build samples of BPF filters using various methods of
+          BPF filter construction.
+
 endif # SAMPLES
diff --git a/samples/Makefile b/samples/Makefile
index 7d6e4ca28..3b33993ac 100644
--- a/samples/Makefile
+++ b/samples/Makefile
@@ -20,3 +20,4 @@ obj-$(CONFIG_SAMPLE_TRACE_PRINTK)	+= trace_printk/
 obj-$(CONFIG_VIDEO_PCI_SKELETON)	+= v4l/
 obj-y					+= vfio-mdev/
 subdir-$(CONFIG_SAMPLE_VFS)		+= vfs
+subdir-$(CONFIG_SAMPLE_BPF)             += bpf
diff --git a/sound/soc/codecs/tlv320aic3x.c b/sound/soc/codecs/tlv320aic3x.c
index 424faafcb..64328506c 100644
--- a/sound/soc/codecs/tlv320aic3x.c
+++ b/sound/soc/codecs/tlv320aic3x.c
@@ -1853,6 +1853,9 @@ static int aic3x_i2c_probe(struct i2c_client *i2c,
 		if (ret != 0)
 			goto err;
 		gpio_direction_output(aic3x->gpio_reset, 0);
+
+		udelay(100);
+		gpio_set_value(aic3x->gpio_reset, 1);
 	}
 
 	for (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)
diff --git a/sound/soc/dwc/Makefile b/sound/soc/dwc/Makefile
index 91e1aaab9..5d88dae30 100644
--- a/sound/soc/dwc/Makefile
+++ b/sound/soc/dwc/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # SYNOPSYS Platform Support
 obj-$(CONFIG_SND_DESIGNWARE_I2S) += designware_i2s.o
+obj-$(CONFIG_ARCH_BAIKAL) += be_snd.o
 
 designware_i2s-y := dwc-i2s.o
 designware_i2s-$(CONFIG_SND_DESIGNWARE_PCM) += dwc-pcm.o
diff --git a/sound/soc/dwc/be_snd.c b/sound/soc/dwc/be_snd.c
new file mode 100644
index 000000000..b6048758b
--- /dev/null
+++ b/sound/soc/dwc/be_snd.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) Baikal Electronics 2019
+ *
+ * Author: Ekaterina Skachko (Ekaterina.Skachko@baikalelectronics.ru)
+ *         for Baikal Electronics.
+ *
+ * License terms:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#include "local.h"
+
+static struct snd_soc_dai_link snd_be_dai = {
+	.name = "dw_i2s",
+	.stream_name = "dw_i2s",
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM,
+};
+
+static struct snd_soc_card snd_be_card = {
+	.name		= "snd_be_card",
+	.owner		= THIS_MODULE,
+	.dai_link	= &snd_be_dai,
+	.num_links	= 1,
+};
+
+static int snd_soc_be_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *codec_np, *be_np;
+	struct snd_soc_dai_link_component *comp;
+
+	snd_be_card.dev = &pdev->dev;
+
+	be_np = of_parse_phandle(np, "baikal,cpu-dai", 0);
+	codec_np  = of_parse_phandle(np, "baikal,audio-codec", 0);
+
+	if (!(be_np && codec_np)) {
+		dev_err(&pdev->dev, "Phandle missing or invalid\n");
+		return -EINVAL;
+	}
+	/* for cpus/codecs/platforms */
+	comp = devm_kzalloc(&pdev->dev, 3 * sizeof(*comp), GFP_KERNEL);
+	if (!comp)
+		return -ENOMEM;
+
+	snd_be_dai.cpus = &comp[0];
+	snd_be_dai.num_cpus = 1;
+	snd_be_dai.codecs = &comp[1];
+	snd_be_dai.num_codecs = 1;
+	snd_be_dai.platforms = &comp[2];
+	snd_be_dai.num_platforms = 1;
+
+	snd_be_dai.codecs->of_node = codec_np;
+	snd_be_dai.cpus->of_node = be_np;
+	snd_be_dai.platforms->of_node = be_np;
+
+	snd_soc_of_parse_card_name(&snd_be_card, "baikal,card-name");
+
+
+	dev_dbg(&pdev->dev, "%s: Card %s: Set platform drvdata.\n",
+		__func__, snd_be_card.name);
+	platform_set_drvdata(pdev, &snd_be_card);
+
+	snd_soc_card_set_drvdata(&snd_be_card, NULL);
+
+	dev_dbg(&pdev->dev, "%s: Card %s: num_links = %d\n",
+		__func__, snd_be_card.name, snd_be_card.num_links);
+	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: name = %s\n",
+		__func__, snd_be_card.name, snd_be_card.dai_link[0].name);
+	dev_dbg(&pdev->dev, "%s: Card %s: DAI-link 0: stream_name = %s\n",
+		__func__, snd_be_card.name,
+		snd_be_card.dai_link[0].stream_name);
+
+	ret = snd_soc_register_card(&snd_be_card);
+	if (ret)
+		dev_err(&pdev->dev,
+			"Error: snd_soc_register_card failed (%d)!\n", ret);
+
+
+	return ret;
+}
+
+static int snd_soc_be_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *snd_be_card = platform_get_drvdata(pdev);
+
+	pr_debug("%s: Enter.\n", __func__);
+
+	snd_soc_unregister_card(snd_be_card);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id snd_soc_be_of_match[] = {
+	{ .compatible = "baikal,snd_soc_be",	 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, snd_soc_be_of_match);
+#endif
+
+
+static struct platform_driver snd_soc_be_driver = {
+	.probe		= snd_soc_be_probe,
+	.remove		= snd_soc_be_remove,
+	.driver		= {
+		.name	= "snd_soc_be",
+		.of_match_table = of_match_ptr(snd_soc_be_of_match),
+	},
+};
+
+module_platform_driver(snd_soc_be_driver);
+
+MODULE_AUTHOR("Ekaterina Skachko <Ekaterina.Skachko@baikalelectronics.ru>");
+MODULE_DESCRIPTION("Baikal-M SoC Sound Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/dwc/dwc-i2s.c b/sound/soc/dwc/dwc-i2s.c
index 65112b9d8..ec12c1859 100644
--- a/sound/soc/dwc/dwc-i2s.c
+++ b/sound/soc/dwc/dwc-i2s.c
@@ -100,6 +100,7 @@ static inline void i2s_enable_irqs(struct dw_i2s_dev *dev, u32 stream,
 
 static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
 {
+	static int rxor_count;
 	struct dw_i2s_dev *dev = dev_id;
 	bool irq_valid = false;
 	u32 isr[4];
@@ -138,7 +139,9 @@ static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
 
 		/* Error Handling: TX */
 		if (isr[i] & ISR_RXFO) {
-			dev_err(dev->dev, "RX overrun (ch_id=%d)\n", i);
+			if ((rxor_count % 1000) == 0)
+				dev_err(dev->dev, "RX overrun (ch_id=%d)\n", i);
+			rxor_count++;
 			irq_valid = true;
 		}
 	}
@@ -611,12 +614,13 @@ static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
 
 }
 
+
 static int dw_i2s_probe(struct platform_device *pdev)
 {
 	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
 	struct dw_i2s_dev *dev;
 	struct resource *res;
-	int ret, irq;
+	int ret, irq, irq_num;
 	struct snd_soc_dai_driver *dw_i2s_dai;
 	const char *clk_id;
 
@@ -638,16 +642,25 @@ static int dw_i2s_probe(struct platform_device *pdev)
 		return PTR_ERR(dev->i2s_base);
 
 	dev->dev = &pdev->dev;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq >= 0) {
-		ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
+        irq_num = platform_irq_count(pdev);
+
+        if (irq_num < 0) /* -EPROBE_DEFER */
+		return irq_num;
+	else if (!irq_num)
+                dev_err(&pdev->dev, "No irq found on device\n");
+
+        do {
+                irq = platform_get_irq(pdev, irq_num);
+                if (irq >= 0) {
+                        printk(KERN_INFO "%s Registered IRQ number %d %d\n",__func__, irq, irq_num);
+                        ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
 				pdev->name, dev);
-		if (ret < 0) {
-			dev_err(&pdev->dev, "failed to request irq\n");
-			return ret;
-		}
-	}
+                        if (ret < 0) {
+                                dev_err(&pdev->dev, "failed to request irq\n");
+                                return ret;
+                        }
+                }
+        } while(irq_num--);
 
 	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
 	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
@@ -711,8 +724,10 @@ static int dw_i2s_probe(struct platform_device *pdev)
 	}
 
 	pm_runtime_enable(&pdev->dev);
+	
 	return 0;
 
+
 err_clk_disable:
 	if (dev->capability & DW_I2S_MASTER)
 		clk_disable_unprepare(dev->clk);
diff --git a/tools/build/Makefile.include b/tools/build/Makefile.include
index 8dadaa0fb..fa9a2ff4b 100644
--- a/tools/build/Makefile.include
+++ b/tools/build/Makefile.include
@@ -1,8 +1,12 @@
 # SPDX-License-Identifier: GPL-2.0-only
 build := -f $(srctree)/tools/build/Makefile.build dir=. obj
 
+ifdef CROSS_COMPILE
+fixdep:
+else
 fixdep:
 	$(Q)$(MAKE) -C $(srctree)/tools/build CFLAGS= LDFLAGS= $(OUTPUT)fixdep
+endif
 
 fixdep-clean:
 	$(Q)$(MAKE) -C $(srctree)/tools/build clean
-- 
2.17.1

